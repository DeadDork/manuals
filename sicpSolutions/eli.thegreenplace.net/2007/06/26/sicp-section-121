<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">
<head>
    <title>SICP section 1.2.1 - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../../favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../../theme/css/bootstrap.min.css" type="text/css"/>
    <link href="../../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../../../theme/css/pygments/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../theme/css/style.css" type="text/css"/>

        <link href="../../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Eli Bendersky's website ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../../index.html" class="navbar-brand">
                <img src="../../../images/logosmall.png" width="32"/> 
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../../pages/about">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="../../../pages/code">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Code</span>
                    </a>
                </li>
                <li>
                    <a href="../../../archives/all">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="sicp-section-121"
                       rel="bookmark"
                       title="Permalink to SICP section 1.2.1">
                        SICP section 1.2.1
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> June 26, 2007 at 05:14</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="../../../tag/sicp">SICP</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                
        <h3>Section 1.2.1</h3>


	<p>The section begins with presenting two approaches to computing factorial. The first is a recursive process (translated to CL, as usual):</p>


<pre>
  (defun factorial-rec (n)
    (if (= n 1)
        1
        (* n (factorial-rec (1- n)))))
</pre>

	<p>The second uses an iterative process, although it is coded recursively as well:</p>


<pre>
  (defun factorial-iter-aux (product counter max-count)
    (if (&gt; counter max-count)
        product
        (factorial-iter-aux (* counter product)
                            (+ counter 1)
                            max-count)))

  (defun factorial-iter (n)
    (factorial-iter-aux 1 1 n))
</pre>

	<p>The discussion that follows in the book about the difference between iterative and recursive processes is priceless, a must read for anyone not intimately familiar with the subject. I won&#8217;t repeat it here, but instead will focus on the implementation details.</p>


	<p>This topic is a great place to discuss another subtle difference between Scheme and CL. To make the process generated by the <code> factorial-iter-aux </code> function really iterative, the compiler must support what&#8217;s called <em>tail call optimization</em>, meaning that it must know to translate the recursive call in <code> factorial-iter-aux </code> into a jump instead of a function call.</p>


	<p>Well, the Scheme standard requires compilers to implement tail call optimization. The CL standard does not, although many implementations do. I use <span class="caps">CLISP 2</span>.41 on Windows, and lets see how it handles this, using the <code>disassemble</code> command. For the recursive process:</p>


<pre>
  [10]&gt; (disassemble  factorial-rec)

  Disassembly of function FACTORIAL-REC
  (CONST 0) = 1
  1 required argument
  0 optional arguments
  No rest parameter
  No keyword parameters
  12 byte-code instructions:
  0     L0
  0     (LOAD&#38;PUSH 1)
  1     (CONST&#38;PUSH 0)                      ; 1
  2     (CALLSR&#38;JMPIF 1 45 L16)             ; =
  6     (LOAD&#38;PUSH 1)
  7     (LOAD&#38;DEC&#38;PUSH 2)
  9     (JSR&#38;PUSH L0)
  11    (CALLSR 2 55)                       ; *
  14    (SKIP&#38;RET 2)
  16    L16
  16    (CONST 0)                           ; 1
  17    (SKIP&#38;RET 2)
  NIL
</pre>

	<p>Although these &#8220;assembly&#8221; codes are <span class="caps">CLISP</span>-specific, most should look familiar to anyone who has learned any assembly. Note the <code>CALLSR</code> calls &#8211; these call system functions, and the comment to the right helpfully shows which. But what is really interesting is the <code>JSR</code> on line 9 &#8211; this is the <em>jump subroutine</em> command which  recursively calls <code>factororial-rec</code>. It is coupled with a <code>PUSH</code> &#8211; which grows the stack. So indeed, a recursive process is generated here.</p>


	<p>On the other hand, if we dissasemble <code>factorial-iter-aux</code>:</p>


<pre>
  [19]&gt; (disassemble 'FACTORIAL-ITER)

  Disassembly of function FACTORIAL-ITER
  3 required arguments
  0 optional arguments
  No rest parameter
  No keyword parameters
  13 byte-code instructions:
  0     L0
  0     (LOAD&#38;PUSH 2)
  1     (LOAD&#38;PUSH 2)
  2     (CALLSR&#38;JMPIF 1 48 L18)             ; &gt;
  6     (LOAD&#38;PUSH 2)
  7     (LOAD&#38;PUSH 4)
  8     (CALLSR&#38;PUSH 2 55)                  ; *
  11    (LOAD&#38;INC&#38;PUSH 3)
  13    (LOAD&#38;PUSH 3)
  14    (JMPTAIL 3 7 L0)
  18    L18
  18    (LOAD 3)
  19    (SKIP&#38;RET 4)
  NIL
</pre>

	<p>We see <code>JMPTAIL</code> on line 14 &#8211; which is the tail recursive jump. Indeed, <span class="caps">CLISP</span> implements the tail call optimization. To see one difference between them, we can run the two factorial functions on some large input (say 4000). While <code>factorial-rec</code> will fail with a stack overflow, <code>factorial-iter</code> won&#8217;t<sup><a href="sicp-section-121#fn1">1</a></sup> &#8211; this is because the stack does not grow.</p>


	<h4>Looping in Common Lisp</h4>


	<p>I don&#8217;t know about you, but to me <code>factorial-rec</code> seems more natural than <code>factorial-iter</code>. This is probably because the tail recursive approach is not the best for representing the solution in iterative form. Generally, Common Lisp programmers prefer to use the built-in looping constructs<sup><a href="sicp-section-121#fn2">2</a></sup> of the language instead of explicit tail recursion for iteration. Apart from being simpler to understand, it also removes the need for defining an auxiliary function (such as <code>factorial-iter-aux</code>) whenever a loop is needed. Here are a few definitions of the factorial function with CL loops:</p>


<pre>
  ; This is a bit contrived because DOTIMES always counts from 0 to n - 1,
  ; so we have to ignore 0.
  ;
  (defun factorial-dotimes (n)
    (let ((product 1))
      (dotimes (i (+ n 1))
        (when (&gt; i 0)
          (setq product (* product i))))
      product))

  ; DO is a flexible looping construct. By using DO* that sequentually
  ; performs the variable settings we can avoid an explicit temporary
  ; 'product' with a LET. But DO can also be used as a simple for loop
  ; of 'C'
  ;
  (defun factorial-do (n)
    (if (= n 0)
      1
      (do* ((i 1 (1+ i))
            (product 1 (* product i)))  
          ((= i n) product))))

  ; LOOP is the most powerful iteration construct of them all. A mini-language
  ; in itself, it is a bit of a controversy in the CL world.
  ; There are probably several ways to achieve this with a loop, and this is
  ; not the best one...
  ;
  (defun factorial-loop (n)
    (loop 
      for i from 1 to n
      and product = 1 then (* product i)
      finally (return product)))
</pre>

	<p>I think that for someone who has written some CL code and is generally familiar with the looping macros, this code should be clear and self-descriptive.</p>


	<h4>Exercise 1.9</h4>


	<p>The first + is recursive, the second iterative. It is quite easy to figure out without explicitly going through the substitution model, actually. Just try to see if calling itself is absolutely the last thing a function does.</p>

<pre><code>
  (defun add-rec (a b)
    (if (= a 0)
      b
      (1+ (add-rec (1- a) b))))

  ; (add-rec 4 5)
  ; (1+ (add-rec 3 5))
  ; (1+ (1+ (add-rec 2 5)))
  ; (1+ (1+ (1+ (add-rec 1 5))))
  ; (1+ (1+ (1+ (1+ (add-rec 0 5)))))
  ; (1+ (1+ (1+ (1+ 5))))
  ; (1+ (1+ (1+ 6)))
  ; (1+ (1+ 7))
  ; (1+ 8)
  ; 9

  (defun add-iter (a b)
    (if (= a 0)
        b
        (add-iter (1- a) (1+ b))))

  ; (add-iter 4 5)
  ; (add-iter 3 6)
  ; (add-iter 2 7)
  ; (add-iter 1 8)
  ; (add-iter 0 9)
  ; 9
</code>
</pre>

	<h4>Exercise 1.10</h4>


	<p>The Ackermann&#8217;s function is a very interesting mathematical curiosity. It is recursive in nature (note that there is a double recursion, so it&#8217;s not tail recursive) and produces astoundingly huge numbers very quickly. Here are a <a href="http://en.wikipedia.org/wiki/Ackermann_function">couple</a> of <a href="http://mathworld.wolfram.com/AckermannFunction.html">places</a> to read more about it<sup><a href="sicp-section-121#fn3">3</a></sup>. Anyway, here are the expansions:</p>


<pre>
  (defun A (x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (t (A (- x 1)
                (A x (- y 1))))))

  ; (A 1 10)
  ; (A 0 (A 1 9))
  ; (* 2 (A 1 9))
  ; (* 2 (A 0 (A 1 8)))
  ; (* 2 (* 2 (A 1 8)))
  ; (* 2 (* 2 ... 10 times
  ; So, (A 1 10) = 2^10 = 1024

  ; (A 2 4)
  ; (A 1 (A 2 3))
  ; we saw that (A 1 x) is 2^x
  ; let's see what's (A 2 3)
  ; (A 1 (A 2 2)
  ; (A 1 (A 1 (A 2 1)))
  ; (A 1 (A 1 2)) =&gt; 2^(2^2) =&gt; 16
  ; So, (A 2 4) = 2^16 = 65536

  ; (A 3 3)
  ; (A 2 (A 3 2))
  ; (A 2 (A 2 (A 3 1)))
  ; (A 2 (A 2 2))
  ; (A 2 4)
  ; from above, this is 65536
  ; So, (A 3 3) = 2^16 = 65536
</pre>

	<p>And here is the solution for the second part:</p>


<pre>
  (defun f (n) (A 0 n))
  ; 2n

  (defun g (n) (A 1 n))
  ; 2^n

  (defun h (n) (A 2 n))
  ; 2^2^... (n times)
</pre>

	<p>We can see from this how fast the Ackermann function grows. Even <code>(A 2 n)</code> produces huge numbers quickly. It&#8217;s fascinating to ponder what <code>(A 3 n)</code> is like. Actually, I think that from the progression of <code>f, g, h</code> we can guess, but it&#8217;s not something our mathematical notation is capable of expressing explicitly. Something like the 4th dimension in space, which we can play with mathematically but can&#8217;t really gasp intuitively.</p>


	<h4>Footnotes</h4>


	<p id="fn1"><sup>1</sup> If you&#8217;re using <span class="caps">CLISP</span>, you must compile <code>factorial-iter</code> in order to see tail call optimization in action. The interpreter doesn&#8217;t implement it for uncompiled functions.</p>


	<p id="fn2"><sup>2</sup> &#8220;Built-in&#8221; is a question of definition here. The looping constructs are actually CL macros, and you could define them yourself if they weren&#8217;t there.</p>


	<p id="fn3"><sup>3</sup> Although the definition <span class="caps">SICP</span> gives for Ackermann&#8217;s function seems non-standard, it&#8217;s the same general idea anyway.</p>

    
            </div>
            <!-- /.entry-content -->
    <hr />
    <section class="comments" id="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'elibenderskyswebsite'; // required: replace example with your forum shortname
            var disqus_identifier = 'sicp-section-121';
            var disqus_url = 'http://eli.thegreenplace.net/2007/06/26/sicp-section-121';
            var disqus_config = function () {
                this.language = "en";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            &copy; 2003-2014 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="sicp-section-121#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../../theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="../../../theme/js/respond.min.js"></script>

<script type="text/javascript">

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54426790-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>