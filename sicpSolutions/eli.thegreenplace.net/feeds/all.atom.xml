<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eli Bendersky's website</title><link href="http://eli.thegreenplace.net/" rel="alternate"></link><link href="http://eli.thegreenplace.net/feeds/all.atom.xml" rel="self"></link><id>http://eli.thegreenplace.net/</id><updated>2014-11-03T05:52:00-08:00</updated><entry><title>Perfect forwarding and universal references in C++</title><link href="http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/" rel="alternate"></link><updated>2014-11-03T05:52:00-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-11-03:2014/perfect-forwarding-and-universal-references-in-c/</id><summary type="html">&lt;p&gt;One of the new features in C++11 aimed at increased code efficiency is the
&lt;tt class="docutils literal"&gt;emplace&lt;/tt&gt; family of methods in containers.  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::vector&lt;/span&gt;&lt;/tt&gt;, for example, has
an &lt;tt class="docutils literal"&gt;emplace_back&lt;/tt&gt; method to parallel &lt;tt class="docutils literal"&gt;push_back&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;emplace&lt;/tt&gt; to
parallel &lt;tt class="docutils literal"&gt;insert&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Here's a short demonstration of the benefits these new methods bring:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyKlass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
  &lt;span class="n"&gt;MyKlass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ii_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;ff_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;

&lt;span class="nl"&gt;private:&lt;/span&gt;
  &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;MyKlass&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyKlass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;3.14f&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;3.14f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you trace the execution of the constructors and destructor of &lt;tt class="docutils literal"&gt;MyKlass&lt;/tt&gt;,
you'll see something like the following for the &lt;tt class="docutils literal"&gt;push_back&lt;/tt&gt; call:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Constructor for a temporary &lt;tt class="docutils literal"&gt;MyKlass&lt;/tt&gt; object&lt;/li&gt;
&lt;li&gt;Move constructor (if one was defined for &lt;tt class="docutils literal"&gt;MyKlass&lt;/tt&gt;, otherwise a copy
constructor) for the object actually allocated inside the vector&lt;/li&gt;
&lt;li&gt;Destructor for the temporary&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is quite a lot of work. Much of it isn't required though, since the object
passed to &lt;tt class="docutils literal"&gt;push_back&lt;/tt&gt; is obviously an rvalue that ceases to exist after the
statement is completed; there's no reason to create and destroy a temporary -
why not just construct the object inside the vector directly?&lt;/p&gt;
&lt;p&gt;This is exactly what &lt;tt class="docutils literal"&gt;emplace_back&lt;/tt&gt; does. For the &lt;tt class="docutils literal"&gt;v.emplace_back(2, 3.14f)&lt;/tt&gt;
call above, all you see is a single constructor invocation. This is the object
constructed &lt;em&gt;inside&lt;/em&gt; the vector. No temporaries are needed.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;emplace_back&lt;/tt&gt; accomplishes this by invoking the constructor of &lt;tt class="docutils literal"&gt;MyKlass&lt;/tt&gt; on
its own and forwarding its arguments to the constructor. This feat is made
possible by two new features in C++11:
&lt;a class="reference external" href="http://eli.thegreenplace.net/2014/variadic-templates-in-c/"&gt;variadic templates&lt;/a&gt;
and perfect forwarding. In this article I want to explain how perfect forwarding
works and how to use it.&lt;/p&gt;
&lt;div class="section" id="the-perfect-forwarding-problem"&gt;
&lt;h2&gt;The perfect forwarding problem&lt;/h2&gt;
&lt;p&gt;Let &lt;tt class="docutils literal"&gt;func(E1, E2, &lt;span class="pre"&gt;...,&lt;/span&gt; En)&lt;/tt&gt; be an arbitrary function call with generic
parameters &lt;tt class="docutils literal"&gt;E1, E2, &lt;span class="pre"&gt;...,&lt;/span&gt; En&lt;/tt&gt;. We'd like to write a function &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; such
that &lt;tt class="docutils literal"&gt;wrapper(E1, E2, &lt;span class="pre"&gt;...,&lt;/span&gt; En)&lt;/tt&gt; is equivalent to &lt;tt class="docutils literal"&gt;func(E1, E2, &lt;span class="pre"&gt;...,&lt;/span&gt; En)&lt;/tt&gt;. In
other words, we'd like to define a function with generic parameters that
forwards its parameters &lt;em&gt;perfectly&lt;/em&gt; to some other function.&lt;/p&gt;
&lt;p&gt;To have something concrete to relate this definition to, think of the
&lt;tt class="docutils literal"&gt;emplace_back&lt;/tt&gt; method discussed above. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;vector&amp;lt;T&amp;gt;::emplace_back&lt;/span&gt;&lt;/tt&gt; forwards
its parameters to a constructor of &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;, without actually knowing how &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;
looks like.&lt;/p&gt;
&lt;p&gt;Next, I'm going to show a few examples of how we might approach this in pre-11
C++. For simplicity's sake, I'll put variadic templates aside; let's assume all
we need to forward is two arguments.&lt;/p&gt;
&lt;p&gt;The first approach that comes to mind is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will obviously not work if &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; accepts its parameters by reference,
since &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; introduces a by-value passing step. If &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; modifies its
by-reference parameter, it won't be visible in the caller of &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; (only
the copy created by &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; itself will be affected).&lt;/p&gt;
&lt;p&gt;OK, then, we can make &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; accept its parameters by reference. This
should not interfere with &lt;tt class="docutils literal"&gt;func&lt;/tt&gt;'s taking parameters by value, because the
call to &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; within &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; will create the required copy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This has another problem, though. Rvalues cannot be bound to function parameters
that are references, so the following completely reasonable calls will now fail:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;3.14f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                  &lt;span class="c1"&gt;// error: invalid initialization of&lt;/span&gt;
                                     &lt;span class="c1"&gt;//        non-const reference from&lt;/span&gt;
                                     &lt;span class="c1"&gt;//        an rvalue&lt;/span&gt;

&lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;foo_returning_float&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   &lt;span class="c1"&gt;// same error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And no, making those reference parameters &lt;tt class="docutils literal"&gt;const&lt;/tt&gt; won't cut it either, because
&lt;tt class="docutils literal"&gt;func&lt;/tt&gt; may legitimately want to accept non-&lt;tt class="docutils literal"&gt;const&lt;/tt&gt; reference parameters.&lt;/p&gt;
&lt;p&gt;What remains is the brute-force approach taken by some libraries: define
overloads for both &lt;tt class="docutils literal"&gt;const&lt;/tt&gt; and non-&lt;tt class="docutils literal"&gt;const&lt;/tt&gt; references:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Exponential explosion. You can imagine how much fun this becomes when we want to
cover some reasonable amount of function parameters. To make things worse, C++11
adds rvalue references to the mix (which we'd also want to forward correctly),
and this clearly isn't a scalable solution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reference-collapsing-and-special-type-deduction-for-rvalues"&gt;
&lt;h2&gt;Reference collapsing and special type deduction for rvalues&lt;/h2&gt;
&lt;p&gt;To explain how C++11 solves the perfect forwarding problem, we have to first
understand two new rules that were added to the language.&lt;/p&gt;
&lt;p&gt;Reference collapsing is the easier one to explain, so let's start with it.
Taking a reference to a reference is illegal in C++. However, it can sometimes
arise in the context of templates and type deduction:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happens if we call this function as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ii&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ii&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the template instantiation, &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; is explicitly set to &lt;tt class="docutils literal"&gt;int&amp;amp;&lt;/tt&gt;. So what is
the type of &lt;tt class="docutils literal"&gt;k&lt;/tt&gt; inside? What the compiler &amp;quot;sees&amp;quot; is &lt;tt class="docutils literal"&gt;int&amp;amp; &amp;amp;&lt;/tt&gt; - while this
isn't something the user is allowed to write in code, the compiler simply infers
a single reference from this. In fact, prior to C++11 this wasn't standardized,
but many compilers accepted such code anyway because these cases occasionally
arise in template metaprogramming. With the addition of &lt;a class="reference external" href="http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c"&gt;rvalue references&lt;/a&gt;
in C++11, it became important to define what happens when various reference
types augment (e.g. what does &lt;tt class="docutils literal"&gt;int&amp;amp;&amp;amp; &amp;amp;&lt;/tt&gt; mean?).&lt;/p&gt;
&lt;p&gt;The result is the &lt;em&gt;reference collapsing&lt;/em&gt; rule. The rule is very simple. &lt;tt class="docutils literal"&gt;&amp;amp;&lt;/tt&gt;
always wins. So &lt;tt class="docutils literal"&gt;&amp;amp; &amp;amp;&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;&amp;amp;&lt;/tt&gt;, and so are &lt;tt class="docutils literal"&gt;&amp;amp;&amp;amp; &amp;amp;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&amp;amp; &amp;amp;&amp;amp;&lt;/tt&gt;. The only
case where &lt;tt class="docutils literal"&gt;&amp;amp;&amp;amp;&lt;/tt&gt; emerges from collapsing is &lt;tt class="docutils literal"&gt;&amp;amp;&amp;amp; &amp;amp;&amp;amp;&lt;/tt&gt;. You can think of it as a
logical-OR, with &lt;tt class="docutils literal"&gt;&amp;amp;&lt;/tt&gt; being 1 and &lt;tt class="docutils literal"&gt;&amp;amp;&amp;amp;&lt;/tt&gt; being 0.&lt;/p&gt;
&lt;p&gt;The other addition to C++11 relevant to this article is special type deduction
rules for rvalue references in some cases &lt;a class="footnote-reference" href="#id5" id="id1"&gt;[1]&lt;/a&gt;. Given a function template like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Don't let &lt;tt class="docutils literal"&gt;T&amp;amp;&amp;amp;&lt;/tt&gt; fool you here - &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; is not an rvalue reference &lt;a class="footnote-reference" href="#id6" id="id2"&gt;[2]&lt;/a&gt;. When it
appears in a type-deducing context, &lt;tt class="docutils literal"&gt;T&amp;amp;&amp;amp;&lt;/tt&gt; acquires a special meaning. When
&lt;tt class="docutils literal"&gt;func&lt;/tt&gt; is instantiated, &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; depends on whether the argument passed to
&lt;tt class="docutils literal"&gt;func&lt;/tt&gt; is an lvalue or an rvalue. If it's an lvalue of type &lt;tt class="docutils literal"&gt;U&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; is
deduced to &lt;tt class="docutils literal"&gt;U&amp;amp;&lt;/tt&gt;. If it's an rvalue, &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; is deduced to &lt;tt class="docutils literal"&gt;U&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 4 is an rvalue: T deduced to int&lt;/span&gt;

&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// d is an lvalue; T deduced to double&amp;amp;&lt;/span&gt;

&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;          &lt;span class="c1"&gt;// f() is an rvalue; T deduced to float&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// i is an lvalue; T deduced to int&amp;amp;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This rule may seem unusual and strange. That's because it is. However, it starts
making sense when we realize it was designed to solve the perfect forwarding
problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="solving-perfect-forwarding-with-std-forward"&gt;
&lt;h2&gt;Solving perfect forwarding with std::forward&lt;/h2&gt;
&lt;p&gt;Let's get back to our original &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; template. Here's how it should be
written in C++11:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this is &lt;tt class="docutils literal"&gt;forward&lt;/tt&gt; &lt;a class="footnote-reference" href="#id7" id="id3"&gt;[3]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;remove_reference&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;noexcept&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's say we call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ii&lt;/span&gt; &lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt; &lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ii&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Examining the first argument (since the second is handled similarly): &lt;tt class="docutils literal"&gt;ii&lt;/tt&gt;
is an lvalue, so &lt;tt class="docutils literal"&gt;T1&lt;/tt&gt; is deduced to &lt;tt class="docutils literal"&gt;int&amp;amp;&lt;/tt&gt; following the special deduction
rules. We get the call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;func(forward&amp;lt;int&amp;amp;&amp;gt;(e1),&lt;/span&gt; &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;. Therefore, &lt;tt class="docutils literal"&gt;forward&lt;/tt&gt;
is instantiated with &lt;tt class="docutils literal"&gt;int&amp;amp;&lt;/tt&gt; and we get this version of it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;noexcept&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now it's time to apply the reference collapsing rule:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;noexcept&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, the argument is passed on by reference to &lt;tt class="docutils literal"&gt;func&lt;/tt&gt;, as needed
for lvalues.&lt;/p&gt;
&lt;p&gt;The other case to handle is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;3.14f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here the arguments are rvalues, so &lt;tt class="docutils literal"&gt;T1&lt;/tt&gt; is deduced to &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;. We get the
call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;func(forward&amp;lt;int&amp;gt;(e1),&lt;/span&gt; &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;. Therefore, &lt;tt class="docutils literal"&gt;forward&lt;/tt&gt; is instantiated
with &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; and we get this version of it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;noexcept&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The by-reference argument is casted to an rvalue reference, which is what we
wanted from &lt;tt class="docutils literal"&gt;forward&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;One can see &lt;tt class="docutils literal"&gt;forward&lt;/tt&gt; as a pretty wrapper around &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(t)&lt;/span&gt;&lt;/tt&gt;
when &lt;tt class="docutils literal"&gt;T&lt;/tt&gt; can be deduced to either &lt;tt class="docutils literal"&gt;U&amp;amp;&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;U&amp;amp;&amp;amp;&lt;/tt&gt;, depending on the kind of
argument to the wrapper (lvalue or rvalue). Now we get &lt;tt class="docutils literal"&gt;wrapper&lt;/tt&gt; as a single
template that handles all kinds of forwarding cleanly.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;forward&lt;/tt&gt; template exists in C++11, in the &lt;tt class="docutils literal"&gt;&amp;lt;utility&amp;gt;&lt;/tt&gt; header, as
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::forward&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Another thing I want to mention is the use of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::remove_reference&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/tt&gt;. In
fact, it you think about it, &lt;tt class="docutils literal"&gt;forward&lt;/tt&gt; could do without it. Reference
collapsing does the job already, so &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::remove_reference&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/tt&gt; is superfluous.
It's there to turn the &lt;tt class="docutils literal"&gt;T&amp;amp; t&lt;/tt&gt; into a non-deducing context (according to the
C++ standard, section 14.8.2.5), thus forcing us to explicitly specify the
template parameter when calling &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::forward&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="universal-references"&gt;
&lt;h2&gt;Universal references&lt;/h2&gt;
&lt;p&gt;In his talks, blog posts and book, Scott Myers gave the name &amp;quot;universal
references&amp;quot; to rvalues that appear in a type-deducing context. Whether this is a
useful mnemonic or not depends on the beholder; personally, when I first read
the relevant chapters of the new &amp;quot;Effective C++&amp;quot;, I found myself seriously
confused on this topic. Only later, when I understood the underlying mechanisms
(reference collapsing and special deduction rules), the topic became somewhat
clearer.&lt;/p&gt;
&lt;p&gt;The trap is that saying &amp;quot;universal references&amp;quot; &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[4]&lt;/a&gt; is surely more succinct and
nice than &amp;quot;rvalue references in a type deducing context&amp;quot;, but once you want to
really understand some piece of code (rather than just cargo-culting
boilerplate), you'll find that avoiding the full definition is impossible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="examples-of-using-perfect-forwarding"&gt;
&lt;h2&gt;Examples of using perfect forwarding&lt;/h2&gt;
&lt;p&gt;Perfect forwarding is extremely useful, because it enables a kind of higher
order programming. &lt;em&gt;Higher order functions&lt;/em&gt; are functions that may take other
functions as arguments or return them. Without perfect forwarding, higher order
functions are cumbersome because there is no convenient way to forward arguments
to wrapped functions. And by &amp;quot;functions&amp;quot; here I mean classes as well, whose
constructors are still functions.&lt;/p&gt;
&lt;p&gt;In the beginning of the article I mentioned the &lt;tt class="docutils literal"&gt;emplace_back&lt;/tt&gt; method of
containers. Another good examples is &lt;tt class="docutils literal"&gt;make_unique&lt;/tt&gt;, which I described in the
&lt;a class="reference external" href="http://eli.thegreenplace.net/2014/variadic-templates-in-c/"&gt;previous article&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)...));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There, I pleaded to ignore the strange &lt;tt class="docutils literal"&gt;&amp;amp;&amp;amp;&lt;/tt&gt; syntax and focus on the variadic
template packs, but now there's no trouble fully understanding the code. It goes
without saying that perfect forwarding and variadic templates very often go hand
in hand, because we generally don't know how many arguments the
functions or constructors we pass around accept.&lt;/p&gt;
&lt;p&gt;For a significantly more complex use of perfect forwarding, you may also want
to take a look at &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::bind&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="links-to-resources"&gt;
&lt;h2&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;Here are some of the resources I found helpful while preparing this article:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The 4th edition of &amp;quot;The C++ Programming Language&amp;quot; by Bjarne Stroustrup&lt;/li&gt;
&lt;li&gt;The new &amp;quot;Effective Modern C++&amp;quot; by Scott Myers has an extensive discussion of
&amp;quot;universal references&amp;quot;. In fact, more than 1/5th of the book is dedicated to
the topic (gasp!).&lt;/li&gt;
&lt;li&gt;Technical paper &lt;a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm"&gt;n1385&lt;/a&gt;:
&amp;quot;The forwarding problem: Arguments&amp;quot;.&lt;/li&gt;
&lt;li&gt;Thomas Becker's &lt;a class="reference external" href="http://thbecker.net/articles/rvalue_references/section_01.html"&gt;C++ Rvalue references explained&lt;/a&gt;
is extremely well-written and useful.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There rules apply in other situations, like &lt;tt class="docutils literal"&gt;auto&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;decltype&lt;/tt&gt;.
Here I'm only presenting the template case.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I think it's unfortunate that the C++ commitee didn't pick a different
syntax for this case and overloaded the meaning of &lt;tt class="docutils literal"&gt;&amp;amp;&amp;amp;&lt;/tt&gt; instead. I
realize it seems like a relatively uncommon use, for which it'd be a
shame to change the language syntax (a thing the commitee tries to avoid
as much as possible), but IMHO the situation is too confusing now. Even
Scott Myers admitted in a talk and some comments on his blog that after 3
years this material is still &amp;quot;sinking in&amp;quot;. And Bjarne Stroustrup has a
mistake in the 4th edition of &amp;quot;The C++ Programming Language&amp;quot; when
describing &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::forward&lt;/span&gt;&lt;/tt&gt; - forgetting to explicitly provide a template
argument when calling it. This stuff is complex!&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is a simplified version of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::forward&lt;/span&gt;&lt;/tt&gt; from the C++11 standard
library. That one has an additional overload explicitly for rvalues, the
goal of which I'm still trying to decipher. Let me know if you have an
idea.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&amp;quot;Forwarding references&amp;quot; is another name I've heard used elsewhere.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="C &amp; C++"></category><category term="Articles"></category></entry><entry><title>Variadic templates in C++</title><link href="http://eli.thegreenplace.net/2014/variadic-templates-in-c/" rel="alternate"></link><updated>2014-10-24T06:11:00-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-10-24:2014/variadic-templates-in-c/</id><summary type="html">&lt;p&gt;Prior to C++11, the only way to write functions that take an arbitrary number of
arguments was to use variadic functions like &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt;, with the ellipsis
syntax (&lt;tt class="docutils literal"&gt;...&lt;/tt&gt;) and the accompanying &lt;tt class="docutils literal"&gt;va_&lt;/tt&gt; family of macros. If you've ever
written code using this approach you know how cumbersome it is. In addition to
being type unsafe (all type resolution has to be done explicitly with casts in
&lt;tt class="docutils literal"&gt;va_arg&lt;/tt&gt;, at runtime), it's also tricky to get right. The &lt;tt class="docutils literal"&gt;va_&lt;/tt&gt; macros
perform low-level memory manipulation, and I've seen a lot of code that
segfaults because it isn't using them carefully enough.&lt;/p&gt;
&lt;p&gt;But what always bothered me most with this approach is leaving something that
is clearly known at compile-time, to run-time. Yes, when we write a variadic
function we don't know all the ways it's going to be used. But when the compiler
puts the whole program together, &lt;em&gt;it does know&lt;/em&gt;. It sees perfectly well all the
invocations of the function throughout the program, and all the possible
argument types it gets passed (types are, after all, resolved at compile-time in
C++).&lt;/p&gt;
&lt;div class="section" id="variadic-templates"&gt;
&lt;h2&gt;Variadic templates&lt;/h2&gt;
&lt;p&gt;One of the new features of C++11 is &lt;em&gt;variadic templates&lt;/em&gt;. Finally, there's a way
to write functions that take an arbitrary number of arguments in a type-safe way
and have all the argument handling logic resolved at compile-time, rather than
run-time. Variadic templates can be used for much more than just functions that
take an arbitrary number of arguments; in this article I want to demonstrate
some of these capabilities.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="basic-example"&gt;
&lt;h2&gt;Basic example&lt;/h2&gt;
&lt;p&gt;Let's dive in, by implementing a function that adds all of its arguments
together:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And here are a couple of ways we could call it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;aa&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;yy&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;ssum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;adder&lt;/tt&gt; will accept any number of arguments, and will compile properly as long
as it can apply the &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; operator to them. This checking is done by the
compiler, at compile time. There's nothing magical about it - it follows C++'s
usual template and overload resolution rules.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;typename...&lt;/span&gt; Args&lt;/tt&gt; is called a &lt;em&gt;template parameter pack&lt;/em&gt;, and &lt;tt class="docutils literal"&gt;Args.. args&lt;/tt&gt;
is called a &lt;em&gt;function parameter pack&lt;/em&gt; (&lt;tt class="docutils literal"&gt;Args&lt;/tt&gt; is, of course, a completely
arbitrary name and could be anything else). Variadic templates are written just
the way you'd write recursive code - you need a base case (the &lt;tt class="docutils literal"&gt;adder(T v)&lt;/tt&gt;
declaration above) and a general case which &amp;quot;recurses&amp;quot; &lt;a class="footnote-reference" href="#id7" id="id1"&gt;[1]&lt;/a&gt;. The recursion
itself happens in the call &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;adder(args...)&lt;/span&gt;&lt;/tt&gt;. Note how the general &lt;tt class="docutils literal"&gt;adder&lt;/tt&gt; is
defined - the first argument is peeled off the template parameter pack into type
&lt;tt class="docutils literal"&gt;T&lt;/tt&gt; (and accordingly, argument &lt;tt class="docutils literal"&gt;first&lt;/tt&gt;). So with each call, the parameter
pack gets shorter by one parameter. Eventually, the base case is encountered.&lt;/p&gt;
&lt;p&gt;To get a better feel for the process, one can use the &lt;tt class="docutils literal"&gt;__PRETTY_FUNCTION__&lt;/tt&gt;
macro &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[2]&lt;/a&gt;. If we insert the following as the first line in both versions
of &lt;tt class="docutils literal"&gt;adder&lt;/tt&gt; above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;__PRETTY_FUNCTION__&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then execute &lt;tt class="docutils literal"&gt;adder(1, 2, 3, 8, 7)&lt;/tt&gt;, we'll see:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;T adder(T, Args...) [T = int, Args = &amp;lt;int, int, int, int&amp;gt;]
T adder(T, Args...) [T = int, Args = &amp;lt;int, int, int&amp;gt;]
T adder(T, Args...) [T = int, Args = &amp;lt;int, int&amp;gt;]
T adder(T, Args...) [T = int, Args = &amp;lt;int&amp;gt;]
T adder(T) [T = int]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="some-simple-variations"&gt;
&lt;h2&gt;Some simple variations&lt;/h2&gt;
&lt;p&gt;When reading about C++ template meta-programming, one often hears about &amp;quot;pattern
matching&amp;quot; and how this part of the language constitutes a fairly complete
compile-time functional language.&lt;/p&gt;
&lt;p&gt;The example shown above is very basic - template arguments are peeled off one
by one until the base case is hit. Here's a somewhat more interesting display
of pattern matching:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;pair_comparer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// In real-world code, we wouldn&amp;#39;t compare floating point values like&lt;/span&gt;
  &lt;span class="c1"&gt;// this. It would make sense to specialize this function for floating&lt;/span&gt;
  &lt;span class="c1"&gt;// point types to use approximate comparison.&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;pair_comparer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pair_comparer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;pair_comparer&lt;/tt&gt; accepts any number of arguments and returns &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; if and
only if they are pair-wise equal. The types are not enforced - everything that
can be compared goes. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pair_comparer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Returns &lt;tt class="docutils literal"&gt;true&lt;/tt&gt;. But if we change the second argument to just &lt;tt class="docutils literal"&gt;1&lt;/tt&gt;, this won't
compile since a &lt;tt class="docutils literal"&gt;double&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; are not the same type.&lt;/p&gt;
&lt;p&gt;More interestingly, &lt;tt class="docutils literal"&gt;pair_comparer&lt;/tt&gt; will only work for an even number of
arguments because they are peeled off in pairs and the base case compares two.
The following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pair_comparer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Does not compile; the compiler complains that the base case expects 2 arguments
but only 1 is provided. To fix this, we can add another variation of the
function template:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;pair_comparer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we force all odd-numbered sequences of arguments to return &lt;tt class="docutils literal"&gt;false&lt;/tt&gt;,
because when only a single argument is left this version is matched.&lt;/p&gt;
&lt;p&gt;Note that &lt;tt class="docutils literal"&gt;pair_comparer&lt;/tt&gt; forces both members of the compared pair to be of
the exact same type. A simple variation would be to allow different types,
as long as they can be compared. I'll leave this an an exercise to the
interested reader.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;If you're concerned with the performance of code that relies on variadic
templates, worry not. As there's no actual recursion involved, all we have is
a sequence of function calls pre-generated at compile-time. This sequence is, in
practice, fairly short (variadic calls with more than 5-6 arguments are rare).
Since modern compilers are aggressively inlining code, it's likely to end up
being compiled to machine code that has absolutely no function calls. What you
end up with, actually, is not unlike loop unrolling.&lt;/p&gt;
&lt;p&gt;Compared to the C-style variadic functions, this is a marked win, because
C-style variadic arguments have to be resolved at runtime. The &lt;tt class="docutils literal"&gt;va_&lt;/tt&gt; macros
are literally manipulating the runtime stack. Therefore, variadic templates are
often a performance optimization for variadic functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="type-safe-variadic-functions"&gt;
&lt;h2&gt;Type-safe variadic functions&lt;/h2&gt;
&lt;p&gt;I have mentioned &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; in the beginning of the article, as an example of a
variadic function that doesn't use templates. However, as we all know,
&lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; and its kin are not &lt;em&gt;type safe&lt;/em&gt;. If you pass a number into a &lt;tt class="docutils literal"&gt;%s&lt;/tt&gt;
format, bad things may happen and the compiler won't warn you about it &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It's pretty obvious how variadic templates enable us to write type safe
functions. In the case of &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt;, when the implementation reaches a new
formatting directive it can actually assert the type of the argument passed.
This assertion won't fire at compile-time, but it &lt;em&gt;will&lt;/em&gt; fire - and a nice error
message can be generated instead of undefined behavior.&lt;/p&gt;
&lt;p&gt;I will not discuss the implementation of a type-safe &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; further - it has
been rehashed many times already. For some good examples see Stroustrup's new
edition of &amp;quot;The C++ Programming Language&amp;quot;, or Alexandrescu's &amp;quot;Variadic templates
are funadic&amp;quot; talk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="varidic-data-structures"&gt;
&lt;h2&gt;Varidic data structures&lt;/h2&gt;
&lt;p&gt;This use-case is much more interesting, IMHO, because it was something that just
wasn't possible prior to introduction of C++11, at least without considerable
hackery.&lt;/p&gt;
&lt;p&gt;Custom data structures (&lt;tt class="docutils literal"&gt;struct&lt;/tt&gt;s since the times of C and &lt;tt class="docutils literal"&gt;class&lt;/tt&gt;es in
C++) have compile-time defined fields. They can represent types that grow at
runtime (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::vector&lt;/span&gt;&lt;/tt&gt;, for example) but if you want to add new fields, this
is something the compiler has to see. Variadic templates make it possible to
define data structures that could have an arbitrary number of fields, and have
this number configured per use. The prime example of this is a &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt; class,
and here I want to show how to construct one &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's start with the type definition:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt;&lt;span class="p"&gt;...),&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

  &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We start with the base case - the definition of a class template named
&lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt;, which is empty. The specialization that follows peels off the first
type from the parameter pack, and defines a member of that type named &lt;tt class="docutils literal"&gt;tail&lt;/tt&gt;.
It also derives from the tuple instantiated with the rest of the pack. This is a
recursive definition that stops when there are no more types to peel off, and
the base of the hierarchy is an empty &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt;. To get a better feel for the
resulting data structure, let's use a concrete example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;12.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;big&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ignoring the constructor, here's a pseudo-trace of the &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt; structs
created:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;struct tuple&amp;lt;double, uint64_t, const char*&amp;gt; : tuple&amp;lt;uint64_t, const char*&amp;gt; {
  double tail;
}

struct tuple&amp;lt;uint64_t, const char*&amp;gt; : tuple&amp;lt;const char*&amp;gt; {
  uint64_t tail;
}

struct tuple&amp;lt;const char*&amp;gt; : tuple {
  const char* tail;
}

struct tuple {
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The layout of data members in the original 3-element &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt; will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[const char* tail, uint64_t tail, double tail]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the empty base consumes no space, due to
&lt;a class="reference external" href="http://en.cppreference.com/w/cpp/language/ebo"&gt;empty base optimization&lt;/a&gt;.
Using Clang's &lt;a class="reference external" href="http://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/"&gt;layout dump feature&lt;/a&gt;,
we can verify this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;*** Dumping AST Record Layout
   0 | struct tuple&amp;lt;double, unsigned long, const char *&amp;gt;
   0 |   struct tuple&amp;lt;unsigned long, const char *&amp;gt; (base)
   0 |     struct tuple&amp;lt;const char *&amp;gt; (base)
   0 |       struct tuple&amp;lt;&amp;gt; (base) (empty)
   0 |       const char * tail
   8 |     unsigned long tail
  16 |   double tail
     | [sizeof=24, dsize=24, align=8
     |  nvsize=24, nvalign=8]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Indeed, the size of the data structure and the internal layout of members is as
expected.&lt;/p&gt;
&lt;p&gt;So, the &lt;tt class="docutils literal"&gt;struct&lt;/tt&gt; definition above lets us create tuples, but there's not much
else we can do with them yet. The way to access tuples is with the &lt;tt class="docutils literal"&gt;get&lt;/tt&gt;
function template &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[5]&lt;/a&gt;, so let's see how it works. First, we'll have to define
a helper type that lets us access the type of the k-th element in a tuple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;elem_type_holder&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;elem_type_holder&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;elem_type_holder&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;elem_type_holder&lt;/tt&gt; is yet another variadic class template. It takes a number
&lt;tt class="docutils literal"&gt;k&lt;/tt&gt; and the &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt; type we're interested in as template parameters. Note
that this is a compile-time template metaprogramming construct - it acts on
constants and types, not on runtime objects. For example, given
&lt;tt class="docutils literal"&gt;elem_type_holder&amp;lt;2, some_tuple_type&amp;gt;&lt;/tt&gt;, we'll get the following pseudo
expansion:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;struct elem_type_holder&amp;lt;2, tuple&amp;lt;T, Ts...&amp;gt;&amp;gt; {
  typedef typename elem_type_holder&amp;lt;1, tuple&amp;lt;Ts...&amp;gt;&amp;gt;::type type;
}

struct elem_type_holder&amp;lt;1, tuple&amp;lt;T, Ts...&amp;gt;&amp;gt; {
  typedef typename elem_type_holder&amp;lt;0, tuple&amp;lt;Ts...&amp;gt;&amp;gt;::type type;
}

struct elem_type_holder&amp;lt;0, tuple&amp;lt;T, Ts...&amp;gt;&amp;gt; {
  typedef T type;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the &lt;tt class="docutils literal"&gt;elem_type_holder&amp;lt;2, some_tuple_type&amp;gt;&lt;/tt&gt; peels off two types from the
beginning of the tuple, and sets its &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; to the type of the third one,
which is what we need. Armed with this, we can implement &lt;tt class="docutils literal"&gt;get&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
    &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;elem_type_holder&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
    &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;elem_type_holder&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;a class="reference external" href="http://eli.thegreenplace.net/2014/sfinae-and-enable_if/"&gt;enable_if&lt;/a&gt; is
used to select between two template overloads of &lt;tt class="docutils literal"&gt;get&lt;/tt&gt; - one for when &lt;tt class="docutils literal"&gt;k&lt;/tt&gt; is
zero, and one for the general case which peels off the first type and recurses,
as usual with variadic function templates.&lt;/p&gt;
&lt;p&gt;Since it returns a reference, we can use &lt;tt class="docutils literal"&gt;get&lt;/tt&gt; to both read tuple elements and
write to them:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;12.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;big&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0th elem is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1th elem is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2th elem is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;103&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1th elem is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="variadic-templates-for-catch-all-functions"&gt;
&lt;h2&gt;Variadic templates for catch-all functions&lt;/h2&gt;
&lt;p&gt;Here is another example I find interesting. It's different from the ones already
shown in the article, because it doesn't really use the traditional recursive
approach of implementing variadic templates. Rather, it uses them to express the
&amp;quot;any template parameters can go here&amp;quot; concept.&lt;/p&gt;
&lt;p&gt;Say we want to write a function that can print out standard library
containers. We want it to work for any container, and we also want the user to
type as little as possible, so we don't want to act on iterators. We just want
&lt;tt class="docutils literal"&gt;print_container(c)&lt;/tt&gt; to work for any container &lt;tt class="docutils literal"&gt;c&lt;/tt&gt;. Here's a first approach:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ContainerType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;ValueType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;AllocType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;print_container&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ContainerType&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ValueType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AllocType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Many of the STL containers are templates that can be parameterized by the value
type and an allocator type; for example &lt;tt class="docutils literal"&gt;vector&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;deque&lt;/tt&gt;, and so
on. So we can write:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;vd&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;3.14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;8.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;3.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;print_container&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;print_container&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this works as expected. However, if we try to use it for &lt;tt class="docutils literal"&gt;map&lt;/tt&gt;, we get a
compile error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;std::map&amp;lt;std::string, int&amp;gt; msi{{&amp;quot;foo&amp;quot;, 42}, {&amp;quot;bar&amp;quot;, 81}, {&amp;quot;bazzo&amp;quot;, 4}};
print_container(msi);
^~~~~~~~~~~~~~~
error: no matching function for call to &amp;#39;print_container&amp;#39;
note: candidate template ignored: substitution failure :
      template template argument has different template
      parameters than its corresponding template template parameter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is because &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; is a template parameterized by 4 template arguments, not
2. The same problem would occur for a &lt;tt class="docutils literal"&gt;set&lt;/tt&gt;, which has 3 template arguments.
This is annoying - while the contents of the &lt;tt class="docutils literal"&gt;print_container&lt;/tt&gt; function would
be the same for all these containers, the signature has to be different. What
can we do without duplicating code? Variadic templates for the rescue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ContainerType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;ValueType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;print_container&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ContainerType&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ValueType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What this says is - &lt;tt class="docutils literal"&gt;ContainerType&lt;/tt&gt; is a template template parameter with any
amount of template parameters itself. We don't care really, as long as the
compiler can type-deduce them at the call. This version of the function will
work for &lt;tt class="docutils literal"&gt;map&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;set&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;unordered_map&lt;/tt&gt; and other containers &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[6]&lt;/a&gt;. One
small addition we have to make to support mappings is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Implement &amp;lt;&amp;lt; for pairs: this is needed to print out mappings where range&lt;/span&gt;
&lt;span class="c1"&gt;// iteration goes over (key, value) pairs.&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;, &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="variadic-templates-for-forwarding"&gt;
&lt;h2&gt;Variadic templates for forwarding&lt;/h2&gt;
&lt;p&gt;A somewhat related example is templates that don't do much on their own, but
have to forward all their arguments to some other template or function. This
turns out to be very useful because C++ has a commonly used construct that
is inherently &amp;quot;variadic&amp;quot; when viewed from a template parameter point of view -
the constructor. Given a generic type &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;, to invoke the constructor of &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;,
we may need to pass in an arbitrary number of arguments. Unlike function types
that specify their arguments at compile time, given just a generic type &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;
we don't know which constructor(s) it has and how many arguments the constructor
accepts.&lt;/p&gt;
&lt;p&gt;A very important example of this is the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::make_unique&lt;/span&gt;&lt;/tt&gt; function, available
in the standard library since C++14. We want to be able to use it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;FooType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;FooType&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;str&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;2.13&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;FooType&lt;/tt&gt; is an arbitrary type and can be constructed in arbitrary ways. How
does &lt;tt class="docutils literal"&gt;make_unique&lt;/tt&gt; know the signature of its constructor? With variadic
templates, it doesn't have to know! Here's how &lt;tt class="docutils literal"&gt;make_unique&lt;/tt&gt; is typically
implemented:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;make_unique&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)...));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ignore the &lt;tt class="docutils literal"&gt;&amp;amp;&amp;amp;&lt;/tt&gt; syntax and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::forward&lt;/span&gt;&lt;/tt&gt; for now; I will cover them in a
future article. What's important for the sake of our current discussion is the
use of a variadic template to convey &amp;quot;any amount of arguments can go here&amp;quot; and
passing them through to the constructor of &lt;tt class="docutils literal"&gt;c&lt;/tt&gt; in the &lt;tt class="docutils literal"&gt;new&lt;/tt&gt; expression.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="links-to-resources"&gt;
&lt;h2&gt;Links to resources&lt;/h2&gt;
&lt;p&gt;I found a number of resources useful while preparing this article:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The 4th edition of &amp;quot;The C++ Programming Language&amp;quot; (by Bjarne Stroustrup) has
a good discussion of variadic templates in chapter 28.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://stackoverflow.com/a/14311714/8206"&gt;This StackOverflow thread&lt;/a&gt; for
the &lt;tt class="docutils literal"&gt;print_container&lt;/tt&gt; example and also for mentioning
&lt;tt class="docutils literal"&gt;__PRETTY_FUNCTION__&lt;/tt&gt; in the context of variadic templates.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://lbrandy.com/blog/2013/03/variadic_templates/"&gt;C++ variadic templates, for the doubters&lt;/a&gt; by Louis Brandy.&lt;/li&gt;
&lt;li&gt;Andrei Alexandrescu's &amp;quot;Variadic templates are funadic&amp;quot; talk from Going Native
2012 was very useful - it's also the basis for my &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt; example
implementation.&lt;/li&gt;
&lt;li&gt;Finally, if recursive use of variadic templates reminds you of pattern
matching in functional languages, you're right! &lt;a class="reference external" href="http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/"&gt;Bartosz Milewski's article&lt;/a&gt;
dives into more details about this.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Technically, this is not recursion, because a different function is
called. The compiler ends up generating a different function for every
used length of the parameter pack. It's useful to reason about it
recursively, though.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;It's a gcc extension, supported by Clang as well.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;To be fair, modern compilers &lt;em&gt;may&lt;/em&gt; warn you about it (Clang almost
certainly will); but this is just special-casing the &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; family
of functions. In other variadic code, you're on your own.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::tuple&lt;/span&gt;&lt;/tt&gt; is part of the standard library in C++11, and it's a more
sophisticated version of what I'm showing here.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;get&lt;/tt&gt; is a standalone function rather than a member, because it would
be awkward to use as a member. Since it requires explicit template
parameter specification and can't use deduction, we'd have to write
something like &lt;tt class="docutils literal"&gt;tup.template &lt;span class="pre"&gt;get&amp;lt;2&amp;gt;()&lt;/span&gt;&lt;/tt&gt; to use it, which is ugly and
too verbose.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Exercise for the reader: there is a C++11 container this still won't
work for. Which one?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="C &amp; C++"></category><category term="Articles"></category></entry><entry><title>SFINAE and enable_if</title><link href="http://eli.thegreenplace.net/2014/sfinae-and-enable_if/" rel="alternate"></link><updated>2014-10-20T05:48:00-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-10-20:2014/sfinae-and-enable_if/</id><summary type="html">&lt;p&gt;There's an interesting issue one has to consider when mixing function
overloading with templates in C++. The problem with templates is that they are
usually overly inclusive, and when mixed with overloading, the result may be
surprising:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;unsigned &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;template &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What do you think a call to &lt;tt class="docutils literal"&gt;foo(42)&lt;/tt&gt; would print? The answer is
&lt;tt class="docutils literal"&gt;&amp;quot;template 42&amp;quot;&lt;/tt&gt;, and the reason for this is that integer literals are signed
by default (they only become unsigned with the &lt;tt class="docutils literal"&gt;U&lt;/tt&gt; suffix). When the compiler
examines the overload candidates to choose from for this call, it sees that the
first function needs a conversion, while the second one matches perfectly, so
that is the one it picks &lt;a class="footnote-reference" href="#id4" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When the compiler looks at overload candidates that are templates, it has to
actually perform &lt;em&gt;substitution&lt;/em&gt; of explicitly specified or deduced types into
the template arguments. This doesn't always result in sensical code, as the
following example demonstrates; while artificial, it's representative of a lot
of generic code written in modern C++:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;negate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value_type&lt;/span&gt; &lt;span class="n"&gt;negate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Consider a call to &lt;tt class="docutils literal"&gt;negate(42)&lt;/tt&gt;. It will pick up the first overload and return
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-42&lt;/span&gt;&lt;/tt&gt;. However, while looking for the best overload, all candidates have to
be considered. When the compiler considers the templated &lt;tt class="docutils literal"&gt;negate&lt;/tt&gt;, it
substitutes the deduced argument type of the call (&lt;tt class="docutils literal"&gt;int&lt;/tt&gt; in this case) into
the template, and comes up with the declaration:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value_type&lt;/span&gt; &lt;span class="n"&gt;negate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code is invalid, of course, since &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; has no member named
&lt;tt class="docutils literal"&gt;value_type&lt;/tt&gt;. So one could ask - should the compiler fail and emit an error
message in this case? Well, no. If it did, writing generic code in C++ would be
very difficult. In fact, the C++ standard has a special clause for such cases,
explaining exactly how a compiler should behave.&lt;/p&gt;
&lt;div class="section" id="sfinae"&gt;
&lt;h2&gt;SFINAE&lt;/h2&gt;
&lt;p&gt;In the latest draft of the C++11 standard, the relevant section is 14.8.2; it
states that when a substitution failure, such as the one shown above, occurs,
type deduction for this particular type fails. That's it. There's no error
involved. The compiler simply ignores this candidate and looks at the others.&lt;/p&gt;
&lt;p&gt;In the C++ folklore, this rule was dubbed &amp;quot;Substitution Failure Is Not An
Error&amp;quot;, or
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error"&gt;SFINAE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The standard states:&lt;/p&gt;
&lt;blockquote&gt;
If a substitution results in an invalid type or expression, type deduction
fails. An invalid type or expression is one that would be ill-formed if
written using the substituted arguments. Only invalid types and expressions
in the immediate context of the function type and its template parameter
types can result in a deduction failure.&lt;/blockquote&gt;
&lt;p&gt;And then goes on to list the possible scenarios that are deemed invalid, such as
using a type that is not a class or enumeration type in a qualified name,
attempting to create a reference to &lt;tt class="docutils literal"&gt;void&lt;/tt&gt;, and so on.&lt;/p&gt;
&lt;p&gt;But wait, what does it mean by the last sentence about &amp;quot;immediate context&amp;quot;?
Consider this (non-sensical) example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;negate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;value_type&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If type deduction matches this overload for some fundamental type, we'll
actually get a compile error due to the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;T::value_type&lt;/span&gt;&lt;/tt&gt; inside the function
body. This is outside of the &amp;quot;immediate context of the function type and its
template parameter types&amp;quot; mentioned by the standard. The lesson here is that if
we want to write a template that only makes sense for some types, we must make
it fail deduction for invalid types right in the declaration, to cause
substitution failure. If the invalid type sneaks past the overload candidate
selection phase, the program won't compile.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="enable-if-a-compile-time-switch-for-templates"&gt;
&lt;h2&gt;enable_if - a compile-time switch for templates&lt;/h2&gt;
&lt;p&gt;SFINAE has proved so useful that programmers started to &lt;em&gt;explicitly&lt;/em&gt; rely on it
very early on in the history of C++. One of the most notable tools used for this
purpose is &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt;. It can be defined as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;
&lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can do things like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;do_stuff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_integral&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// an implementation for integral types (int, char, unsigned, etc.)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;do_stuff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// an implementation for class types&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note SFINAE at work here. When we make the call &lt;tt class="docutils literal"&gt;do_stuff(25)&lt;/tt&gt;, the compiler
selects the first overload: since the condition &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::is_integral&amp;lt;int&amp;gt;&lt;/span&gt;&lt;/tt&gt; is
&lt;tt class="docutils literal"&gt;true&lt;/tt&gt;, the specialization of &lt;tt class="docutils literal"&gt;struct enable_if&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; is used, and
its internal &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; is set to &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;. The second overload is omitted because
without the &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; specialization (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::is_class&amp;lt;int&amp;gt;&lt;/span&gt;&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;false&lt;/tt&gt;) the
general form of &lt;tt class="docutils literal"&gt;struct enable_if&lt;/tt&gt; is selected, and it doesn't have a
&lt;tt class="docutils literal"&gt;type&lt;/tt&gt;, so the type of the argument results in a substitution failure.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt; has been part of Boost for many years, and since C++11 it's also
in the standard C++ library as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::enable_if&lt;/span&gt;&lt;/tt&gt;. Its usage is somewhat
verbose though, so C++14 adds this type alias for convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="kt"&gt;enable_if_t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this, the examples above can be rewritten a bit more succinctly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;do_stuff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;enable_if_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_integral&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;do_stuff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;enable_if_t&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="uses-of-enable-if"&gt;
&lt;h2&gt;Uses of enable_if&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt; is an extremely useful tool. There are hundreds of references to
it in the C++11 standard template library. It's so useful because it's a key
part in using &lt;em&gt;type traits&lt;/em&gt;, a way to restrict templates to types that have
certain properties. Without &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt;, templates are a rather blunt
&amp;quot;catch-all&amp;quot; tool. If we define a function with a template argument, this
function will be invoked on all possible types. Type traits and &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt;
let us create different functions that act on different kinds of types, while
still remaining generic &lt;a class="footnote-reference" href="#id5" id="id3"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;One usage example I like is the two-argument constructor of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::vector&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Create the vector {8, 8, 8, 8}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Create another vector {8, 8, 8, 8}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// Create the vector {1, 2, 3, 4}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are two forms of the two-argument constructor used here. Ignoring
allocators, this is how these constructors could be declared:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;vector&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InputIterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputIterator&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;InputIterator&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Both constructors take two arguments, but the second one has the catch-all
property of templates. Even though the template argument &lt;tt class="docutils literal"&gt;InputIterator&lt;/tt&gt; has a
descriptive name, it has no semantic meaning - the compiler wouldn't mind
if it was called &lt;tt class="docutils literal"&gt;ARG42&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;. The problem here is that even for &lt;tt class="docutils literal"&gt;v1&lt;/tt&gt;,
the &lt;em&gt;second&lt;/em&gt; constructor would be invoked if we didn't do something special.
This is because the type of &lt;tt class="docutils literal"&gt;4&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; rather than &lt;tt class="docutils literal"&gt;size_t&lt;/tt&gt;. So to
invoke the first constructor, the compiler would have to perform a type
conversion. The second constructor would fit perfectly though.&lt;/p&gt;
&lt;p&gt;So how does the library implementor avoid this problem and make sure that the
second constructor is only called for iterators? By now we know the answer -
with &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Here is how the second constructor is &lt;em&gt;really&lt;/em&gt; defined:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_InputIterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_InputIterator&lt;/span&gt; &lt;span class="n"&gt;__first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;__is_input_iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_InputIterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                          &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;__is_forward_iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_InputIterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                          &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;conditions&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
                          &lt;span class="n"&gt;_InputIterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__last&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It uses &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt; to only enable this overload for types that are input
iterators, though not forward iterators. For forward iterators, there's a
separate overload, because the constructors for these can be implemented more
efficiently.&lt;/p&gt;
&lt;p&gt;As I mentioned, there are many uses of &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt; in the C++11 standard
library. The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;string::append&lt;/span&gt;&lt;/tt&gt; method has a very similar use to the above,
since it has several overloads that take two arguments and a template overload
for iterators.&lt;/p&gt;
&lt;p&gt;A somewhat different example is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::signbit&lt;/span&gt;&lt;/tt&gt;, which is supposed to be
defined for all arithmetic types (integer or floating point). Here's a
simplified version of its declaration in the &lt;tt class="docutils literal"&gt;cmath&lt;/tt&gt; header:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_arithmetic&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;span class="n"&gt;signbit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// implementation&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without using &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt;, think about the options the library implementors
would have. One would be to overload the function for each of the known
arithmetic type. That's very verbose. Another would be to just use an
unrestricted template. But then, had we actually passed a wrong type into it,
say &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::string&lt;/span&gt;&lt;/tt&gt;, we'd most likely get a fairly obscure error &lt;em&gt;at the point
of use&lt;/em&gt;. With &lt;tt class="docutils literal"&gt;enable_if&lt;/tt&gt;, we neither have to write boilerplate, nor to
produce bad error messages. If we invoke &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::signbit&lt;/span&gt;&lt;/tt&gt; as defined above with
a bad type we'll get a fairly helpful error saying that a suitable function
cannot be found.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-more-advanced-version-of-enable-if"&gt;
&lt;h2&gt;A more advanced version of enable_if&lt;/h2&gt;
&lt;p&gt;Admittedly, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::enable_if&lt;/span&gt;&lt;/tt&gt; is clumsy, and even &lt;tt class="docutils literal"&gt;enable_if_t&lt;/tt&gt; doesn't help
much, though it's a bit less verbose. You still have to mix it into the
declaration of a function in a way that often obscures the return type or an
argument type. This is why &lt;a class="reference external" href="http://flamingdangerzone.com/cxx11/2012/06/01/almost-static-if.html"&gt;some&lt;/a&gt;
&lt;a class="reference external" href="http://loungecpp.wikidot.com/tips-and-tricks:enable-if-for-c-11"&gt;sources&lt;/a&gt;
online suggest crafting more advanced versions that &amp;quot;get out of the way&amp;quot;.
Personally, I think this is the wrong tradeoff to make.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::enable_if&lt;/span&gt;&lt;/tt&gt; is a rarely used construct. So making it less verbose doesn't
buy us much. On the other hand, making it more mysterious is detrimental,
because every time we see it we have to think about how it works. The
implementation shown here is fairly simple, and I'd keep it this way. Finally
I'll note that the C++ standard library uses the verbose, &amp;quot;clumsy&amp;quot; version of
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::enable_if&lt;/span&gt;&lt;/tt&gt; without defining more complex versions. I think that's the
right decision.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;If we had an overload for &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;, however, this is the one that would be
picked, because in overload resolution non-templates are preferred over
templates.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Think of it as a mid-way between overloading and templates. C++ has
another tool to implement something similar - runtime polymorphism.
Type traits let us do that at compile time, without incurring any runtime
cost.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="C &amp; C++"></category><category term="Articles"></category></entry><entry><title>Summary of reading: July - September 2014</title><link href="http://eli.thegreenplace.net/2014/summary-of-reading-july-september-2014/" rel="alternate"></link><updated>2014-10-04T11:23:41-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-10-04:2014/summary-of-reading-july-september-2014/</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;The Autobiography of Benjamin Franklin&amp;quot; by Benjamin Franklin (audiobook) -
this book is surprisingly good, especially the first 2/3rds of it or so.
Franklin was a very inspiring individual, worth learning from.&lt;/li&gt;
&lt;li&gt;&amp;quot;Abundance: The Future Is Better Than You Think&amp;quot; by Peter Diamanidis and
Steven Kotler - it's hard to avoid comparing this book to Matt Ridley's
&amp;quot;Rational Optimist&amp;quot;, if only because the authors quote from Ridley quite a
bit. IMHO it's a strictly worse book - the interesting parts can all be
found in Ridley's book, just explained better. This is not to say that
it's a bad book; I certainly enjoyed parts of it. But if you only have
to pick one book on this subject, &amp;quot;Rational Optimist&amp;quot; should be your choice.&lt;/li&gt;
&lt;li&gt;&amp;quot;Creation: How Science is Reinventing Life Itself&amp;quot; by Adam Rutherford
(audiobook) - very interesting book focusing on the biologic origins of life
and genetic engineering. The first 2/3rds of the book are superb. The part
that came later - about the ethical debate surrounding genetic
engineering - I found too polemic and somewhat less interesting. I'd hope
for more dive-ins into the latest scientific discoveries. The author does
pick that up in the afterword that's actually a long and interesting
chapter, describing more of the latest research.&lt;/li&gt;
&lt;li&gt;&amp;quot;The Philadelphia chromosome&amp;quot; by Jessica Wapner (audiobook) - this is
definitely one of the best books I've read this year. A very well
put-together account of the research leading to a revolutionary treatment
for CML - a type of leukemia. The treatment is one of the first drugs
targeted specifically at the core cause of the cancer at the molecular
level. Most of the book deals with the basic biological and genetic
research, the slow scientific advances during decades, that enabled
the drug. It also talks about the clinical trial process of new drugs, FDA
approvals, and so on. Very highly recommended for anyone with an interest in
biology &amp;amp; genetics.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Re-reads:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;La Soledad de los Numeros Primos&amp;quot; by Paolo Giordano&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="Book reviews"></category></entry><entry><title>Highlighting the active tab in GNOME terminal</title><link href="http://eli.thegreenplace.net/2014/highlighting-the-active-tab-in-gnome-terminal/" rel="alternate"></link><updated>2014-09-17T22:54:25-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-09-17:2014/highlighting-the-active-tab-in-gnome-terminal/</id><summary type="html">&lt;p&gt;On Ubuntu, I like using the default GNOME terminal for all my command-line
needs, and I'm a big fan of its tabs. One of the problems with tabs, however, is
that it's not always easy to tell which tab you're currently in - which tab is
the active one. By default, the terminal application makes a very slight visual
distinction between the active and inactive tabs, and it would be really nice if
it was more prominent.&lt;/p&gt;
&lt;p&gt;Luckily, it isn't difficult to configure GNOME to do this:&lt;/p&gt;
&lt;img alt="Terminal Screenshot" class="align-center" src="http://eli.thegreenplace.net/images/2014/terminal-screenshot.png" /&gt;
&lt;p&gt;For Ubuntu 14.04, create a file named &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.config/gtk-3.0/gtk.css&lt;/span&gt;&lt;/tt&gt;, and place
the following into it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;TerminalWindow&lt;/span&gt; &lt;span class="nc"&gt;.notebook&lt;/span&gt; &lt;span class="nt"&gt;tab&lt;/span&gt;&lt;span class="nd"&gt;:active&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;background-color&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;#b0c0f0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The color itself can be customized, of course. This technique supposedly works
on all the latest Ubuntu versions starting with 12.10; it doesn't work on 12.04,
though. What did work on 12.04 for me is the technique described in &lt;a class="reference external" href="http://ubuntuforums.org/showthread.php?t=2038854"&gt;this forum
post&lt;/a&gt;.&lt;/p&gt;
</summary><category term="Linux"></category></entry><entry><title>Blogging setup with Pelican</title><link href="http://eli.thegreenplace.net/2014/blogging-setup-with-pelican/" rel="alternate"></link><updated>2014-09-12T05:54:00-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-09-12:2014/blogging-setup-with-pelican/</id><summary type="html">&lt;p&gt;When I launched the new look of the website earlier this week, a lot of people
asked me over email what kind of setup I'm using - blogging engine, hosting and
so on. Here's a short writeup.&lt;/p&gt;
&lt;p&gt;A lot has changed for this website. First of all, I switched my hosting provider
from a shared Bluehost account (which I've had for the past 9 years or so) to a
VPS on &lt;a class="reference external" href="https://www.digitalocean.com/"&gt;Digital Ocean&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Second, the blogging platform was changed from Wordpress to &lt;a class="reference external" href="https://github.com/getpelican"&gt;Pelican&lt;/a&gt;. Pelican is a really nice and fast static-site
generator with a fairly clean Python codebase. It's easy to use and configure,
and the documentation is great; so overall I'd say I'm pretty happy with it. The
theme is my hacked up version of one of the existing bootstrap3-based themes.
One of the benefits of this is that the site is now much more usable on mobile.&lt;/p&gt;
&lt;p&gt;As for moving the existing content from the old Wordpress site, there are two
options. For smaller sites you may consider the auto-import capability Pelican
has for Wordpress imports. I didn't end up using it because I needed to preserve
the exact permalinks of my old website (there are &lt;em&gt;a lot&lt;/em&gt; of incoming links to
it out there, and it would be a shame to break them all), as well as
some other reasons. I just wrote a quick script that did my own importing from a
Wordpress XML dump.&lt;/p&gt;
&lt;p&gt;Pelican lets older (back-ported) HTML content peacefully coexist with new,
ReST-authored content, which is very useful. For preserving the old permalinks,
it has the handy &lt;tt class="docutils literal"&gt;save_as&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;url&lt;/tt&gt; attributes. Pelican also comes with
built-in integration to Google Analytics and Disqus, both of which took about 5
minutes to configure.&lt;/p&gt;
&lt;p&gt;All in all, I'm very happy with the transition. Static pages just make more
sense for a blog (even a fairly large one with over 1000 articles); the site now
feels incredibly fast to me. This is hardly surprising, given that it moved from
querying a DB and processing a bunch of PHP on a fairly congested machine to
just running a bare web server accessing the filesystem on a reasonably fast,
dedicated machine.&lt;/p&gt;
</summary><category term="Blogging"></category></entry><entry><title>Goodbye Wordpress - a new blog</title><link href="http://eli.thegreenplace.net/2014/goodbye-wordpress-a-new-blog/" rel="alternate"></link><updated>2014-09-04T18:10:00-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-09-04:2014/goodbye-wordpress-a-new-blog/</id><summary type="html">&lt;p&gt;I've been unhappy with Wordpress for &lt;a class="reference external" href="http://eli.thegreenplace.net/2012/10/14/thinking-of-dumping-wordpress"&gt;quite some time&lt;/a&gt;. Finally, it's time to
move on.&lt;/p&gt;
&lt;p&gt;You'll notice that the site looks different now. Hopefully you'll also notice
that it loads much faster, is more reliable and looks better on mobile.&lt;/p&gt;
&lt;p&gt;Please let me know if anything looks wrong or broken.&lt;/p&gt;
</summary><category term="Blogging"></category></entry><entry><title>AST matchers and Clang refactoring tools</title><link href="http://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools" rel="alternate"></link><updated>2014-07-29T20:22:19-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-07-29:2014/07/29/ast-matchers-and-clang-refactoring-tools</id><summary type="html">
        &lt;p&gt;Clang tooling sees lots of interest and development focus in the past few years. At last, we have a convenient, accurate, open-source and well supported framework for programmatically analyzing and refactoring C++ code; I find this very exciting.&lt;/p&gt;
&lt;p&gt;A great outcome of this rapid pace of development is that new APIs and tools spring up all the time. For example, some time ago the Clang tooling developers figured out folks doing AST traversals have to write a lot of repetitive code to find interesting AST nodes, so they came up with a great new API called &lt;a class="reference external" href="http://clang.llvm.org/docs/LibASTMatchers.html"&gt;AST matchers&lt;/a&gt;, which I want to discuss here.&lt;/p&gt;
&lt;div class="section" id="visitors-vs-matchers"&gt;
&lt;h3&gt;Visitors vs. matchers&lt;/h3&gt;
&lt;p&gt;Here's a motivating example. Suppose we're looking for pointer-typed variables being used in &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; comparisons. To make this more specific, let's say we're looking for cases where the pointer-typed variable is on the left-hand-side of an equality comparison (&lt;tt class="docutils literal"&gt;==&lt;/tt&gt;). To find such nodes in a recursive visitor, we'd have to write something like this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;bool&lt;/span&gt; VisitIfStmt(IfStmt *s) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BinaryOperator *BinOP =
          llvm::dyn_cast&amp;lt;BinaryOperator&amp;gt;(s-&amp;gt;getCond())) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (BinOP-&amp;gt;getOpcode() == BO_EQ) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Expr *LHS = BinOP-&amp;gt;getLHS();
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; ImplicitCastExpr *Cast =
              llvm::dyn_cast&amp;lt;ImplicitCastExpr&amp;gt;(LHS)) {
        LHS = Cast-&amp;gt;getSubExpr();
      }

      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; DeclRefExpr *DeclRef = llvm::dyn_cast&amp;lt;DeclRefExpr&amp;gt;(LHS)) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; VarDecl *Var =
                llvm::dyn_cast&amp;lt;VarDecl&amp;gt;(DeclRef-&amp;gt;getDecl())) {
          &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (Var-&amp;gt;getType()-&amp;gt;isPointerType()) {
            Var-&amp;gt;dump();  &lt;span style="color: #007f00"&gt;// YAY found it!!&lt;/span&gt;
          }
        }
      }
    }
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is quite a bit of code, but nothing out of the ordinary if you've been working with Clang ASTs for a while. Perhaps it can be golfed down into a somewhat shorter form, but the main problem is that to write this one has to go through quite a bit of documentation and header files to figure out which methods to call and what kinds of objects they return.&lt;/p&gt;
&lt;p&gt;Here's the equivalent AST matcher:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Finder.addMatcher(
    ifStmt(hasCondition(binaryOperator(
        hasOperatorName(&lt;span style="color: #7f007f"&gt;&amp;quot;==&amp;quot;&lt;/span&gt;),
        hasLHS(ignoringParenImpCasts(declRefExpr(
            to(varDecl(hasType(pointsTo(AnyType))).bind(&lt;span style="color: #7f007f"&gt;&amp;quot;lhs&amp;quot;&lt;/span&gt;)))))))),
    &amp;amp;HandlerForIf);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some difference, right? The declarative nature of matcher definitions makes this very natural to read and to map to the actual problem. &lt;tt class="docutils literal"&gt;HandlerForIf&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;MatchCallback&lt;/tt&gt; object that has direct access to the bound nodes of the matcher:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;struct&lt;/span&gt; IfStmtHandler : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; MatchFinder::MatchCallback {
  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; MatchFinder::MatchResult &amp;amp;Result) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; VarDecl *lhs = Result.Nodes.getNodeAs&amp;lt;VarDecl&amp;gt;(&lt;span style="color: #7f007f"&gt;&amp;quot;lhs&amp;quot;&lt;/span&gt;);
    lhs-&amp;gt;dump();   &lt;span style="color: #007f00"&gt;// YAY found it!!&lt;/span&gt;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's actually quite a bit of documentation available about AST matchers on the official Clang website. For a complete example that can be built outside of the LLVM tree, I redid the &lt;a class="reference external" href="http://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling/"&gt;tooling sample from the previous article&lt;/a&gt;, now &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src_clang/matchers_rewriter.cpp"&gt;with AST matchers&lt;/a&gt; (all available in the &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/"&gt;llvm-clang-samples repository&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-clang-query-to-test-matchers-and-explore-the-ast"&gt;
&lt;h3&gt;Using clang-query to test matchers and explore the AST&lt;/h3&gt;
&lt;p&gt;An interesting new tool in Clang-land is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-query&lt;/span&gt;&lt;/tt&gt;. It's an interactive evaluator for AST matchers that can be used both to test your matchers and do some programmatic exploration of the AST. Let's say we want to develop an AST matcher for pointer comparisons, similar to the one shown above. Here's a sample input file we're going to work on:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* p, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; v) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (p == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; v + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; v - &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's fire up &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-query&lt;/span&gt;&lt;/tt&gt; and see what it can do:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang-query /tmp/iflhsptr.c --
clang-query&amp;gt; set output diag
clang-query&amp;gt; match functionDecl()

Match #1:

/tmp/iflhsptr.c:1:1: note: &amp;quot;root&amp;quot; binds here
int foo(int* p, int v) {
^~~~~~~~~~~~~~~~~~~~~~~~
1 match.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a basic smoke test to see how it matches the function declaration. The output mode set in the first command could also ask the tool to dump or print the AST, but for our purpose the diagnostic output is convenient.&lt;/p&gt;
&lt;p&gt;Here's how we can match deeper nodes and bind them:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;clang-query&amp;gt; match ifStmt(hasCondition(binaryOperator(hasOperatorName(&amp;quot;==&amp;quot;)).bind(&amp;quot;op&amp;quot;)))

Match #1:

/tmp/iflhsptr.c:2:7: note: &amp;quot;op&amp;quot; binds here
  if (p == 0) {
      ^~~~~~
/tmp/iflhsptr.c:2:3: note: &amp;quot;root&amp;quot; binds here
  if (p == 0) {
  ^~~~~~~~~~~~~
1 match.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we intend to provide our own bindings, the root binding can be turned off:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;clang-query&amp;gt; set bind-root false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's see multiple matches:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;clang-query&amp;gt; match varDecl().bind(&amp;quot;var&amp;quot;)

Match #1:

/tmp/iflhsptr.c:1:9: note: &amp;quot;var&amp;quot; binds here
int foo(int* p, int v) {
        ^~~~~~

Match #2:

/tmp/iflhsptr.c:1:17: note: &amp;quot;var&amp;quot; binds here
int foo(int* p, int v) {
                ^~~~~
2 matches.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point I'll stop because long matchers don't format conveniently in a blog post, but I'm sure you got the idea. It's very obvious how helpful this tool can be with developing matchers. It's still new and has some rough edges, but is already quite useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="refactoring-tools-and-replacements"&gt;
&lt;h3&gt;Refactoring tools and replacements&lt;/h3&gt;
&lt;p&gt;With the growing usage of libTooling, it's hardly surprising that its developers keep coming up with higher levels of abstraction that help writing new tools with less and less effort. The AST matchers framework presented above is one example. Another is &lt;tt class="docutils literal"&gt;RefactoringTool&lt;/tt&gt;, a subclass of &lt;tt class="docutils literal"&gt;ClangTool&lt;/tt&gt; that makes it possible to craft new tools with very little code. I'll show an example soon, but first a word about replacements.&lt;/p&gt;
&lt;p&gt;The tools I was demonstrating so far used a &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; to change the underlying source code in response to finding interesting things in the AST. This is a good approach, but it has a problem scaling for large projects. Imagine running a tool over a large project with many source files and many header files. Some of rewritings may need to happen in the header files, but how to manage that, given that the same headers get included into multiple translation units? Some edits may end up being duplicated or even conflicting, and that's a problem.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Replacement&lt;/tt&gt;s are the solution. The source transformation task is divided into two distinct steps:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Custom tools go through the source base, finding the refactoring patterns to apply, and generating serialized replacements into files. Think of replacements as something like patch files (precise directions of how to modify a source file), but in a somewhat friendlier format.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-apply-replacements&lt;/span&gt;&lt;/tt&gt; can then run with access to all replacements, perform the required de-duplication and conflict resolution and actually apply the changes to the source.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This approach also allows nice parallelization of the refactoring over huge code-bases, though there aren't many projects and companies in the world with source code large enough to make this a real problem.&lt;/p&gt;
&lt;p&gt;Back to an example then. I took the simple sample tool from the previous article (just finding interesting &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; nodes and adding some comments into them) and rewrote it once again, using &lt;tt class="docutils literal"&gt;RefactoringTool&lt;/tt&gt; and replacements. &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src_clang/matchers_replacements.cpp"&gt;The full code is available in the samples project&lt;/a&gt;, but it's so short that I can show most of it here.&lt;/p&gt;
&lt;p&gt;Here's the complete &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; function. For ease of hacking it just dumps the replacements to stdout instead of serializing or applying them:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; main(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; argc, &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt; **argv) {
  CommonOptionsParser op(argc, argv, ToolingSampleCategory);
  RefactoringTool Tool(op.getCompilations(), op.getSourcePathList());

  &lt;span style="color: #007f00"&gt;// Set up AST matcher callbacks.&lt;/span&gt;
  IfStmtHandler HandlerForIf(&amp;amp;Tool.getReplacements());

  MatchFinder Finder;
  Finder.addMatcher(ifStmt().bind(&lt;span style="color: #7f007f"&gt;&amp;quot;ifStmt&amp;quot;&lt;/span&gt;), &amp;amp;HandlerForIf);

  &lt;span style="color: #007f00"&gt;// Run the tool and collect a list of replacements. We could call&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// runAndSave, which would destructively overwrite the files with&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// their new contents. However, for demonstration purposes it&amp;#39;s&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// interesting to show the replacements.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; Result = Tool.run(newFrontendActionFactory(&amp;amp;Finder).get())) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; Result;
  }

  llvm::outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;Replacements collected by the tool:\n&amp;quot;&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;auto&lt;/span&gt; &amp;amp;r : Tool.getReplacements()) {
    llvm::outs() &amp;lt;&amp;lt; r.toString() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IfStmtHandler&lt;/tt&gt; is just a &lt;tt class="docutils literal"&gt;MatchCallback&lt;/tt&gt; that is triggered on &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; statements:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;IfStmtHandler&lt;/span&gt; : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; MatchFinder::MatchCallback {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  IfStmtHandler(Replacements *Replace) : Replace(Replace) {}

  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; MatchFinder::MatchResult &amp;amp;Result) {
    &lt;span style="color: #007f00"&gt;// The matched &amp;#39;if&amp;#39; statement was bound to &amp;#39;ifStmt&amp;#39;.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; IfStmt *IfS =
          Result.Nodes.getNodeAs&amp;lt;clang::IfStmt&amp;gt;(&lt;span style="color: #7f007f"&gt;&amp;quot;ifStmt&amp;quot;&lt;/span&gt;)) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Stmt *Then = IfS-&amp;gt;getThen();
      Replacement Rep(*(Result.SourceManager), Then-&amp;gt;getLocStart(), &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;,
                      &lt;span style="color: #7f007f"&gt;&amp;quot;// the &amp;#39;if&amp;#39; part\n&amp;quot;&lt;/span&gt;);
      Replace-&amp;gt;insert(Rep);

      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Stmt *Else = IfS-&amp;gt;getElse()) {
        Replacement Rep(*(Result.SourceManager), Else-&amp;gt;getLocStart(), &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;,
                        &lt;span style="color: #7f007f"&gt;&amp;quot;// the &amp;#39;else&amp;#39; part\n&amp;quot;&lt;/span&gt;);
        Replace-&amp;gt;insert(Rep);
      }
    }
  }

&lt;span style="color: #00007f; font-weight: bold"&gt;private&lt;/span&gt;:
  Replacements *Replace;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how little boilerplate this code contains. The tool is set up in just a handful of lines of code, and most of my code deals with the actual refactoring at hand. This definitely makes writing tools quicker and easier than ever before.&lt;/p&gt;
&lt;/div&gt;

    </summary><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Payload server in Python 3 for Github webhooks</title><link href="http://eli.thegreenplace.net/2014/07/09/payload-server-in-python-3-for-github-webhooks" rel="alternate"></link><updated>2014-07-09T05:50:49-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-07-09:2014/07/09/payload-server-in-python-3-for-github-webhooks</id><summary type="html">
        &lt;p&gt;The Github &lt;a class="reference external" href="https://developer.github.com/webhooks/"&gt;Webhooks API&lt;/a&gt; is powerful and flexible, making it simple to integrate services with your source repository. Lately I've been tinkering with it a bit, but all the examples Github has are in Ruby. So I put together a simple demo server in Python 3. Though simple (it's completely self contained and only needs Python 3 to run), it's complete, covering even &lt;a class="reference external" href="https://developer.github.com/webhooks/securing/"&gt;webhook security&lt;/a&gt; by verifying the signature created with the API's secret token.&lt;/p&gt;
&lt;p&gt;Here it is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;argparse&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;hashlib&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;hmac&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #00007f"&gt;http.server&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; HTTPServer, BaseHTTPRequestHandler
&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;json&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;pprint&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;os&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;sys&lt;/span&gt;

&lt;span style="color: #007f00"&gt;# It&amp;#39;s not recommended to store the key within the code. Following&lt;/span&gt;
&lt;span style="color: #007f00"&gt;# http://12factor.net/config, we&amp;#39;ll store this in the environment.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;# Note that the key must be a bytes object.&lt;/span&gt;
HOOK_SECRET_KEY = os.environb[b&lt;span style="color: #7f007f"&gt;&amp;#39;HOOK_SECRET_KEY&amp;#39;&lt;/span&gt;]


&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;GithubHookHandler&lt;/span&gt;(BaseHTTPRequestHandler):
    &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot;Base class for webhook handlers.&lt;/span&gt;

&lt;span style="color: #7f007f"&gt;    Subclass it and implement &amp;#39;handle_payload&amp;#39;.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;_validate_signature&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, data):
        sha_name, signature = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.headers[&lt;span style="color: #7f007f"&gt;&amp;#39;X-Hub-Signature&amp;#39;&lt;/span&gt;].split(&lt;span style="color: #7f007f"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;)
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; sha_name != &lt;span style="color: #7f007f"&gt;&amp;#39;sha1&amp;#39;&lt;/span&gt;:
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;False&lt;/span&gt;

        &lt;span style="color: #007f00"&gt;# HMAC requires its key to be bytes, but data is strings.&lt;/span&gt;
        mac = hmac.new(HOOK_SECRET_KEY, msg=data, digestmod=hashlib.sha1)
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; hmac.compare_digest(mac.hexdigest(), signature)

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;do_POST&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        data_length = &lt;span style="color: #00007f"&gt;int&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.headers[&lt;span style="color: #7f007f"&gt;&amp;#39;Content-Length&amp;#39;&lt;/span&gt;])
        post_data = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.rfile.read(data_length)

        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #0000aa"&gt;not&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._validate_signature(post_data):
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.send_response(&lt;span style="color: #007f7f"&gt;401&lt;/span&gt;)
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt;

        payload = json.loads(post_data.decode(&lt;span style="color: #7f007f"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;))
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.handle_payload(payload)
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.send_response(&lt;span style="color: #007f7f"&gt;200&lt;/span&gt;)


&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;MyHandler&lt;/span&gt;(GithubHookHandler):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;handle_payload&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, json_payload):
        &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot;Simple handler that pretty-prints the payload.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;JSON payload&amp;#39;&lt;/span&gt;)
        pprint.pprint(json_payload)


&lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #7f007f"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    argparser = argparse.ArgumentParser(description=&lt;span style="color: #7f007f"&gt;&amp;#39;Github hook handler&amp;#39;&lt;/span&gt;)
    argparser.add_argument(&lt;span style="color: #7f007f"&gt;&amp;#39;port&amp;#39;&lt;/span&gt;, &lt;span style="color: #00007f"&gt;type&lt;/span&gt;=&lt;span style="color: #00007f"&gt;int&lt;/span&gt;, help=&lt;span style="color: #7f007f"&gt;&amp;#39;TCP port to listen on&amp;#39;&lt;/span&gt;)
    args = argparser.parse_args()

    server = HTTPServer((&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;#39;&lt;/span&gt;, args.port), MyHandler)
    server.serve_forever()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Just run it at some port on your server and point the webhook you create to it. Currently it just runs on the server's root path (e.g. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://myserver.com:1234&lt;/span&gt;&lt;/tt&gt;), but should be trivial to modify to any path.&lt;/p&gt;
&lt;p&gt;By the way, I found &lt;a class="reference external" href="https://ngrok.com/"&gt;ngrok&lt;/a&gt; to be invaluable for testing this. It creates a tunnel from your localhost's port to a unique URL you can set as the webhook destination on Github. This makes it possible to quickly iterate and test the server on your local machine.&lt;/p&gt;

    </summary><category term="Python"></category><category term="Version control"></category></entry><entry><title>Summary of reading: April – June 2014</title><link href="http://eli.thegreenplace.net/2014/06/29/summary-of-reading-april-june-2014" rel="alternate"></link><updated>2014-06-29T14:39:57-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-06-29:2014/06/29/summary-of-reading-april-june-2014</id><summary type="html">
        &lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;A Guide to the Good Life: The Ancient Art of Stoic Joy&amp;quot; by William B. Irvine - An overview of Stoicism, one of the ancient Greece's schools of philosophy. It's interesting to draw parallels between it and modern &amp;quot;self help&amp;quot; approaches. Even more interestingly, it's an important lesson to keep in mind that people more than 2000 years ago were concerned about very similar things as today, and came up with very similar solutions. I can't say I liked how the book itself was written, but Stoicism is definitely interesting.&lt;/li&gt;
&lt;li&gt;&amp;quot;Mastery&amp;quot; by Robert Greene - The author explores what it takes to become a master in some profession/craft, and provides mini-biographies of a number of successful historical figures, such as Mozart or Benjamin Franklin. While the biographical parts are pretty interesting, I found the thesis overall not too insightful. Greene tries to demonstrate that mastery comes from practice rather than inborn talent, but his biographical examples mostly show the opposite, it seems to me. That said, the book isn't bad all in all. A particularly positive mention goes to the chapter about social intelligence which is pretty good.&lt;/li&gt;
&lt;li&gt;&amp;quot;The Five Major Pieces to the Life Puzzle&amp;quot; by Jim Rohn - not what I expected :-/ This book is a brief rehash of common self-help slogans, without a lot of substance.&lt;/li&gt;
&lt;li&gt;&amp;quot;Got Fight?&amp;quot; by Forrest Griffin - extremely funny and extremely politically incorrect. Don't expect too much real advice from this book - mainly jokes and anecdotes. I've actually liked the last part of the book, where Griffin shows &amp;quot;tips&amp;quot; for actual MMA moves and techniques the least useful. You can't really learn martial arts from a book... If you're up for a quick read and a good laugh, though, this book will certainly deliver.&lt;/li&gt;
&lt;li&gt;&amp;quot;Dr. Atkins' New Diet Revolution&amp;quot; by Robert Atkins - The new edition of the classic book that launched the low-carb diet revolution. My expectations weren't high here, and I was mainly looking for a more practical complement to Gary Taubes's books, which explain why refined carbs are bad very well, but don't give much in terms of practical advice of how to eat. While Atkins easily hits all the check-points of a sleazy self-help book, in terms of practical advice and todo-s it's not bad. It provides reasonably detailed paths to weight loss and maintenance using a ultra low-carb diet, as well as helpful advice in terms of what foods to use to achieve it. One thing that really bugs me about the book, though, is that its claims of &amp;quot;no caloric restrictions&amp;quot; are disingenuous. On one hand the author says you don't have to count calories at all when limiting carbs; on the other hand, he uses every opportunity to mention that all meals should be small. The &amp;quot;recommended daily menus&amp;quot; at the end of the book are very ascetic indeed. I'd say that it you eat three small meals a day, and your only snack in between is cantaloupe, that's a diet any way you want to call it, because it will be very low calorie too.&lt;/li&gt;
&lt;li&gt;&amp;quot;Two Scoops of Django: Best Practices For Django 1.6&amp;quot; by Daniel Greenfeld and Audrey Roy - with the surging popularity of Python for web development, and Django being its most widely used framework, this book fills a needed niche. The Django documentation is known for its high quality, but after having gone through it and having built a few simple applications, one may wonder about some of the more advanced techniques used by experienced Django developers. &amp;quot;Two Scoops&amp;quot; aims to provide a wide overview of such techniques. It has a lot of useful information, which can only be fully appreciated when you intend to apply it to a real project. An interesting fact about this book is that it's self published - while the efforts of the authors with this aspect are admirable, the quality leaves something to be desired (both proofreading and in general the way the content is laid out graphically). That said, I've seen lower-quality books from established publishers, so this may not mean much.&lt;/li&gt;
&lt;li&gt;&amp;quot;The Invisible Man&amp;quot; by H.G. Wells (Audiobook) - A very light and entertaining read. The audio recording available for free on Librivox is outstanding.&lt;/li&gt;
&lt;li&gt;&amp;quot;Winter of the World&amp;quot; by Ken Follett - Second part of the trilogy, and also very good. The only thing that really bothered me is how involved the main characters are in the key historic events around World War II. I think the author went a bit overboard on this one. I realize it would be difficult to describe these events with the same amount of intimacy, but he did succeed in one of the cases. For example, Greg was a secret service supervisor on the Manhattan project - he didn't have to be one of the scientists in it. A similar role could be carved for the other characters, putting them a bit away from the lime-lights. In general though, it's a very good book.&lt;/li&gt;
&lt;/ul&gt;
    </summary><category term="Book reviews"></category></entry><entry><title>Moving to Github - one year recap</title><link href="http://eli.thegreenplace.net/2014/06/08/moving-to-github-one-year-recap" rel="alternate"></link><updated>2014-06-08T08:50:47-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-06-08:2014/06/08/moving-to-github-one-year-recap</id><summary type="html">
        &lt;p&gt;It's been a year since I &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/06/09/switching-my-open-source-projects-from-bitbucket-to-github/"&gt;switched all my personal projects&lt;/a&gt; from Bitbucket / Mercurial to Github / Git, so I think the time is right for a brief recap.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2014/06/pythocat-e1401975025529.png" /&gt;
&lt;p&gt;As I mentioned back then, the platform (Github vs. Bitbucket) served a larger role in the decision to switch than the source control system (Git vs. Mercurial). Bitbucket lets you use Git now if you want, so the latter difference is actually moot. It's the platform that remains the difference, and if I felt that Github has &amp;quot;won&amp;quot; the platform war a year ago, I feel even more so now. Even so far as being called the new résumé for developers, Github has definitely captured a very prominent place in the jargon and habits of our craft.&lt;/p&gt;
&lt;p&gt;Amazingly, Bitbucket still hasn't caught up in terms of front-page information. On Github it's fairly easy, in a quick glance, to assess how active a developer is, which projects he contributes to, etc. On Bitbucket, all you see is a dull list of project names, not sorted in any useful way. Organizations, another cool Github concept, is also nowhere to be seen. Perhaps Bitbucket gave up on this fight, though, focusing on corporate users.&lt;/p&gt;
&lt;p&gt;My main qualm with Bitbucket was that due to its lack of popularity I didn't get as much contribution to my projects as I hoped for. Had this improved? Certainly! Instead of &amp;quot;why don't you use Github&amp;quot; complaints, I now routinely get pull requests (or at least opened issues) for my projects. Several of &lt;a class="reference external" href="https://github.com/eliben/"&gt;my projects&lt;/a&gt; are starred by dozens of developers, and the most popular one - &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser&lt;/a&gt; - now has over 40 forks!&lt;/p&gt;
&lt;p&gt;Github pull requests are indeed a thing of beauty. Not that there's anything technically complex about them. It's a cultural thing. If you find a problem in a project, just send in a pull request. Most chances are it will be accepted. Pull requests have become a ubiquitous contribution currency, because of one very subtle, yet powerful factor. Github pull requests are part of your online identity. Once your pull request is merged into a project, it's forever retained in the log that you have contributed to that project. &lt;em&gt;You&lt;/em&gt; being the direct link to your Github account / profile. For example, I commited a small fix to Django a few months ago - &lt;a class="reference external" href="https://github.com/django/django/commit/73f51e411372ba3e74ccf5a2c2be88927ac2c6dd"&gt;here it is&lt;/a&gt;, forever recorded and linked to my Github profile. The power of Github as the de-facto social network of developers cannot be ignored. It is way, &lt;em&gt;way&lt;/em&gt; more significant than Linkedin.&lt;/p&gt;
&lt;p&gt;Let's put it this way - &lt;em&gt;actual commits beat empty endorsements, any day&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Github indeed serves the résumé role well, at least for me. I routinely receive job / interview offers or recruiter pitches based on my &amp;quot;impressive Github profile&amp;quot;.&lt;/p&gt;
&lt;p&gt;Even projects that are not formally hosted on Github take care to maintain a mirror there, because Github is such a familiar low-entry way to examine their code and even fork it. It's not uncommon for people to develop their changes in branches vs. the Github mirror, and sending patches to the real source repository when done. I know this happens in the LLVM &amp;amp; Clang world a lot. Maintaining Github mirrors of projects is quite easy - for example, it took me just a few hours to set up &lt;a class="reference external" href="https://github.com/python/cpython"&gt;this semi-official Github mirror for CPython&lt;/a&gt;, and as for maintaining it... well, there's cron for that.&lt;/p&gt;
&lt;p&gt;Github's popularity is also the cause of it being the first target of other projects that aim to make the life of developers easier. &lt;a class="reference external" href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt; is a blessing, and I use its Github integration extensively. All developers know how painful it is to set up and maintain continuous integration builds for their project. Travis &amp;amp; Github make this ridiculously easy, at least for the limited set of platforms Travis currently supports. Automatically run tests for each proposed pull request and tell me if it breaks anything? Shut up and take my money! Oh, it's free for open-source projects...&lt;/p&gt;

    </summary><category term="Programming"></category><category term="Version control"></category></entry><entry><title>Using ASDL to describe ASTs in compilers</title><link href="http://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers" rel="alternate"></link><updated>2014-06-04T06:25:55-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-06-04:2014/06/04/using-asdl-to-describe-asts-in-compilers</id><summary type="html">
        &lt;p&gt;ASTs (Abstract Syntax Trees) are an &lt;a class="reference external" href="http://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/"&gt;important data structure&lt;/a&gt; in compiler front-ends. If you've written a few parsers, you almost definitely ran into the need to describe the result of the parsing in terms of an AST. While the kinds of nodes such ASTs have and their structure is very specific to the source language, many commonalities come up. In other words, coding &amp;quot;yet another AST&amp;quot; gets really old after you've done it a few times.&lt;/p&gt;
&lt;p&gt;Worry not, as you'd expect from the programmer crowd, this problem was &amp;quot;solved&amp;quot; by adding another level of abstraction. Yes, an &lt;strong&gt;abstraction&lt;/strong&gt; over &lt;strong&gt;Abstract&lt;/strong&gt; Syntax Trees, oh my! The abstraction here is some textual format (let's call it a DSL to sound smart) that describes what the AST looks like, along with machinery to auto-generate the code that implements this AST.&lt;/p&gt;
&lt;p&gt;Most solutions in this domain are ad-hoc, but one that I've seen used more than once is &lt;a class="reference external" href="http://asdl.sourceforge.net/"&gt;ASDL&lt;/a&gt; - Abstract Syntax Definition Language. The self-description from the website sounds about right:&lt;/p&gt;
&lt;blockquote&gt;
The Zephyr Abstract Syntax Description Lanuguage (ASDL) is a language designed to describe the tree-like data structures in compilers. Its main goal is to provide a method for compiler components written in different languages to interoperate. ASDL makes it easier for applications written in a variety of programming languages to communicate complex recursive data structures.&lt;/blockquote&gt;
&lt;p&gt;To given an example, here's a short snippet from an ASDL definition of a simple programming language:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;program = Program(class* classes)

class = Class(identifier name, identifier? parent, feature* features)

[...]

expression = Assign(identifier name, expression expr)
           | StaticDispatch(expression expr, identifier type_name,
                            identifier name, expression* actual)
           | Dispatch(expression expr, identifier name, expression* actual)

[...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The way to read this is: a &lt;em&gt;program&lt;/em&gt; node consists of one or more &lt;em&gt;classes&lt;/em&gt;. Each &lt;em&gt;class&lt;/em&gt; has these children: a &lt;em&gt;name&lt;/em&gt; which is an identifier, an optional &lt;em&gt;parent&lt;/em&gt; which is also an identifier, and a (potentially empty) list of &lt;em&gt;features&lt;/em&gt;, each of which is a feature node. And so on.&lt;/p&gt;
&lt;p&gt;The full details are available in the paper &amp;quot;The Zephyr Abstract Syntax Definition Language&amp;quot; by Wang et.al. Unfortunately, a link to this paper isn't always trivial to find, so I have a PDF copy in the &lt;tt class="docutils literal"&gt;docs&lt;/tt&gt; directory of my &lt;a class="reference external" href="https://github.com/eliben/asdl_parser"&gt;asdl_parser project&lt;/a&gt;, which I'm going to discuss soon.&lt;/p&gt;
&lt;div class="section" id="type-safety-in-asdl"&gt;
&lt;h3&gt;Type safety in ASDL&lt;/h3&gt;
&lt;p&gt;In addition to providing a concise description of nodes from which code (in many languages) can be generated automatically, I like ASDL for another reason. It provides some type safety when constructing the AST in the parser.&lt;/p&gt;
&lt;p&gt;Take the snippet above, for example. A &lt;em&gt;program&lt;/em&gt; has the &lt;em&gt;classes&lt;/em&gt; attribute, which is a (potentially empty) sequence of &lt;em&gt;class&lt;/em&gt; nodes. Each such class has to be a &lt;em&gt;Class&lt;/em&gt;, which is precisely defined. It can be nothing else. The &lt;em&gt;expression&lt;/em&gt; below that shows that differently - an expression can be either a &lt;em&gt;Assign&lt;/em&gt;, &lt;em&gt;StaticDispatch&lt;/em&gt;, etc.&lt;/p&gt;
&lt;p&gt;The set of possibilities is statically defined. This makes it possible to insert some degree of static checking into the (auto-generated) AST construction code. So the constructed AST can't be completely bogus even before semantic analysis is applied. Even though I love Python, I do appreciate a bit of static type checking in the right places. Key data structures like ASTs are, I believe, one of the places when such type checking makes sense.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="asdl-in-upstream-cpython"&gt;
&lt;h3&gt;ASDL in upstream CPython&lt;/h3&gt;
&lt;p&gt;Starting with Python 2.5, the CPython compiler (the part responsible for emitting bytecode from Python source) uses an ASDL description to create an AST for Python source. The AST is created by the parser (from the parse tree - more details in &lt;a class="reference external" href="http://legacy.python.org/dev/peps/pep-0339/"&gt;PEP 339&lt;/a&gt;), and is then used to create the control-flow graph, from which bytecode is emitted.&lt;/p&gt;
&lt;p&gt;The ASDL description lives in &lt;tt class="docutils literal"&gt;Parser/Python.asdl&lt;/tt&gt; in the CPython source tree. &lt;tt class="docutils literal"&gt;Parser/asdl_c.py&lt;/tt&gt; is a script that runs whenever someone modifies this ASDL description. It uses the &lt;tt class="docutils literal"&gt;Parser/asdl.py&lt;/tt&gt; module to parse the ASDL file into an internal form and then emits C code that describes the ASTs. This C code lives in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Include/Python-ast.h&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Python/Python-ast.c&lt;/span&gt;&lt;/tt&gt; &lt;a class="footnote-reference" href="#id2" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This may be more details than you wanted to hear :-) The gist of it, however, is - CPython's ASTs are described in ASDL, and if you want a quick glance of how these ASTs look, &lt;tt class="docutils literal"&gt;Parser/Python.asdl&lt;/tt&gt; is the file to look at.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="my-rewrite-of-the-asdl-parser"&gt;
&lt;h3&gt;My rewrite of the ASDL parser&lt;/h3&gt;
&lt;p&gt;Up until very recently, the ASDL description of the CPython AST was parsed by a tool that relied on the &lt;a class="reference external" href="http://pages.cpsc.ucalgary.ca/~aycock/spark/"&gt;SPARK parsing toolkit&lt;/a&gt;. In fact, &lt;tt class="docutils literal"&gt;Parser/spark.py&lt;/tt&gt; was carried around in the distribution just for this purpose.&lt;/p&gt;
&lt;p&gt;A few months ago I was looking for something to conveniently implement the AST for a toy compiler I was hacking on. Being a CPython developer, ASDL immediately sprang to mind, but I was reluctant to carry the SPARK dependency and/or learn how to use it. The ASDL language seemed simple enough to not require such machinery. Surely a simple recursive-descent parser would do. So I implemented my own stand-alone parser for ASDL, using modern Python 3.x - and it's available in a &lt;a class="reference external" href="https://github.com/eliben/asdl_parser"&gt;public Github repository right here&lt;/a&gt;. Feel free to use it, and let me know how it goes!&lt;/p&gt;
&lt;p&gt;Since my parser turned out to be much simpler and easier to grok than upstream CPython's SPARK-based parser, I proposed to replace it in &lt;a class="reference external" href="http://bugs.python.org/issue19655"&gt;Issue 19655&lt;/a&gt;. After some delays (caused mainly by waiting for 3.4 release and then getting distracted by other stuff), the change &lt;a class="reference external" href="http://hg.python.org/cpython/rev/b769352e2922"&gt;landed in the default branch&lt;/a&gt; (on its way to 3.5) about a month ago. The result is pleasing - the new parser is shorter, doesn't require the SPARK dependency (which was now dropped), has tests and is much more maintainable.&lt;/p&gt;
&lt;p&gt;In the interest of not changing too much at once, I left the interface to the C code generator (&lt;tt class="docutils literal"&gt;Parser/asdl_c.py&lt;/tt&gt;) the same, so there is absolutely no difference in the produced C code. Some time in the future it may make sense to revise this decision. The C generator is also fairly old code that could use some modernization and tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="historical-note-ast-description-in-pycparser"&gt;
&lt;h3&gt;Historical note - AST description in pycparser&lt;/h3&gt;
&lt;p&gt;I first ran into this problem (high-level description of ASTs) when I was working on &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser&lt;/a&gt; (which is &lt;a class="reference external" href="http://eli.thegreenplace.net/2008/11/15/pycparser-v10-is-out/"&gt;quite an old project&lt;/a&gt; by now).&lt;/p&gt;
&lt;p&gt;Back at the time, I looked at the &lt;tt class="docutils literal"&gt;compiler&lt;/tt&gt; module of Python 2.x and liked its approach of simple textual description of the AST which is then parsed and from which the code for AST nodes is emitted. The &lt;tt class="docutils literal"&gt;compiler&lt;/tt&gt; module was a maintenance headache (because it duplicated a lot of the AST logic from the actual compiler) and is gone in Python 3.x, replaced by the &lt;tt class="docutils literal"&gt;ast&lt;/tt&gt; module which provides access to the same C-based AST generated by &lt;tt class="docutils literal"&gt;Parser/asdl_c.py&lt;/tt&gt; as is used by the CPython compiler.&lt;/p&gt;
&lt;p&gt;pycparser's AST description is a simple textual file that's very similar in spirit to ASDL. If I were to do this today, I'd probably also pick ASDL since it's more &amp;quot;standard&amp;quot;, as well as for the extra type safety guarantees it provides.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Even though these files are auto-generated, they are also checked into the CPython Mercurial repository. This is because we don't want people building Python from source to depend on the tools required to generate such files. Only core CPython developers who want to play with the internals need them.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </summary><category term="Compilation"></category><category term="Python"></category><category term="Python internals"></category></entry><entry><title>Compilation databases for Clang-based tools</title><link href="http://eli.thegreenplace.net/2014/05/21/compilation-databases-for-clang-based-tools" rel="alternate"></link><updated>2014-05-21T22:09:14-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-05-21:2014/05/21/compilation-databases-for-clang-based-tools</id><summary type="html">
        &lt;p&gt;If you're interested in writing analysis and source-rewriting tools with Clang's libTooling, you may have run into the following ominous error while trying to invoke a tool on some code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang-check -analyze div0.c
LLVM ERROR: Could not auto-detect compilation database for file &amp;quot;div0.c&amp;quot;
No compilation database found in /tmp or any parent directory
json-compilation-database: Error while opening JSON database:
     No such file or directory
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what's a &lt;em&gt;compilation database&lt;/em&gt;, why do Clang tools need it, and how do you go about creating one?&lt;/p&gt;
&lt;div class="section" id="motivation-faithfully-reproducing-a-compilation"&gt;
&lt;h3&gt;Motivation - faithfully reproducing a compilation&lt;/h3&gt;
&lt;p&gt;Unlike many other source analysis tools (for example - syntax coloring in editors) which only provide approximate parsing of C++ source, Clang tools are the real thing. The same compiler frontend that's used to actually parse and compile source is used to build the AST for analysis. This is great because it means you never get false positives; but it also means the analysis tools need the complete information available to the compiler when looking at source files.&lt;/p&gt;
&lt;p&gt;When we compile code we pass all kinds of flags to the compiler. Warning flags, language-version flags, etc. But most importantly - macro definitions (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-D&lt;/span&gt;&lt;/tt&gt;)) and include directories (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-I&lt;/span&gt;&lt;/tt&gt;). Without the latter, &lt;a class="reference external" href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;it's not even possible to parse the source code properly&lt;/a&gt;. Historically, a &amp;quot;classical&amp;quot; C compiler pipeline used to run the preprocessor (&lt;tt class="docutils literal"&gt;cpp&lt;/tt&gt;) to take care of these before the compiler would even see the file. These days modern compilers like Clang combine preprocessing with parsing, but the fundamentals remain in place.&lt;/p&gt;
&lt;p&gt;OK then, we need to know which flags the code was compiled with. How do we pass this information to tools?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fixed-compilation-database"&gt;
&lt;h3&gt;Fixed compilation database&lt;/h3&gt;
&lt;p&gt;This is where the concept of &amp;quot;compilation database&amp;quot; comes in. In simple terms, it's a collection of exact compilation commands for a set of files. I'll discuss it in more detail shortly, but first a brief detour into specifying the commands in a simple way that doesn't require a special file.&lt;/p&gt;
&lt;p&gt;A &amp;quot;fixed&amp;quot; compilation database allows us to pass the compilation flags to a tool on the command-line, following a special token &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt;. Here's a complete example that will demonstrate what I mean. Consider this code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;#define DODIV(a, b) ((a) / (b))&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;test&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; z) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (z == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
&lt;span style="color: #007f00"&gt;#ifdef FOO&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; DODIV(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, z);
&lt;span style="color: #007f00"&gt;#else&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; - z;
&lt;span style="color: #007f00"&gt;#endif&lt;/span&gt;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt; + z;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-check&lt;/span&gt;&lt;/tt&gt; simply as shown in the beginning of the post results in an error message. If we tack a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; to the end of the command-line, however, it works:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang-check -analyze div0.c --
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By &amp;quot;works&amp;quot; here I mean &amp;quot;does not die with an error&amp;quot;. But it doesn't report anything either, while I'd expect it to detect a division by zero in the &lt;tt class="docutils literal"&gt;if (z == 0)&lt;/tt&gt; case &lt;a class="footnote-reference" href="#id6" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is because we didn't provide any compiler flags. So the analysis assumed the file is compiled like so:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ clang -c div0.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Indeed, note that the &amp;quot;divide by 0&amp;quot; error happens only if the &lt;tt class="docutils literal"&gt;FOO&lt;/tt&gt; macro is defined. It's not defined here, so the analyzer is quiet &lt;a class="footnote-reference" href="#id7" id="id2"&gt;[2]&lt;/a&gt;. Let's define it then:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ $clang-check -analyze div0.c -- -DFOO
/tmp/div0.c:6:12: warning: Division by zero
    return DODIV(1, z);
           ^~~~~~~~~~~
/tmp/div0.c:1:26: note: expanded from macro &amp;#39;DODIV&amp;#39;
#define DODIV(a, b) ((a) / (b))
                     ~~~~^~~~~
1 warning generated.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So providing compilation commands to tools on the command-line is easy. However, if you want to run analyses/transformations over larger projects for which some sort of build system already exists, you'll probably find a real compilation database more useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="json-compilation-database"&gt;
&lt;h3&gt;JSON compilation database&lt;/h3&gt;
&lt;p&gt;When Clang tools complain they can't find a compilation database, what they actually mean is a specially named JSON file in either the same directory as the file being processed or in one of its parent directories. The &lt;a class="reference external" href="http://clang.llvm.org/docs/JSONCompilationDatabase.html"&gt;JSON compilation database&lt;/a&gt; is very simple. Here's an example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;[
{
  &lt;span style="color: #7f007f"&gt;&amp;quot;directory&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;command&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;gcc div0.c&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;file&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp/div0.c&amp;quot;&lt;/span&gt;
},
{
  &lt;span style="color: #7f007f"&gt;&amp;quot;directory&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;command&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;gcc -DFOO div0.c&amp;quot;&lt;/span&gt;,
  &lt;span style="color: #7f007f"&gt;&amp;quot;file&amp;quot;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;quot;/tmp/div0.c&amp;quot;&lt;/span&gt;
}
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's just a list of entries, each of which consists of these fields:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;File: the file to which the compilation applies&lt;/li&gt;
&lt;li&gt;Command: the exact compilation command used&lt;/li&gt;
&lt;li&gt;Directory: the directory from which the compilation is executed &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see above, there may be multiple entries for the same file. This is not a mistake - it's entirely plausible that the same file gets compiled multiple times inside a project, each time with different options.&lt;/p&gt;
&lt;p&gt;If you paste this into a file name &lt;tt class="docutils literal"&gt;compile_commands.json&lt;/tt&gt; and place it in the same directory (or any of its parents) with the file you want to run the analysis on, the tool will work without requiring the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; part, because it can find the file in the compilation database and infer the compilation command on its own. If the tool finds more than one entry for a file, it just runs multiple times, once per entry. As far as the tool is concerned, two compilations of the same file can be entirely different due to differences in flags.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="compilation-database-for-transformation-tools"&gt;
&lt;h3&gt;Compilation database for transformation tools&lt;/h3&gt;
&lt;p&gt;Source transformation tools use a compilation database similarly to analysis tools. Consider this contrived example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* foo() {
&lt;span style="color: #007f00"&gt;#ifdef FOO&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
&lt;span style="color: #007f00"&gt;#else&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
&lt;span style="color: #007f00"&gt;#endif&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's save this file as &lt;tt class="docutils literal"&gt;nullptr.cpp&lt;/tt&gt; and run &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-modernize&lt;/span&gt; &lt;span class="pre"&gt;-use-nullptr&lt;/span&gt;&lt;/tt&gt; on it to transform all &amp;quot;NULL-pointer like&amp;quot; constants to an actual &lt;tt class="docutils literal"&gt;nullptr&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ $LLVMGH/clang-modernize -use-nullptr -summary nullptr.cpp --
Transform: UseNullptr - Accepted: 1
$ cat nullptr.cpp
#include &amp;lt;stdlib.h&amp;gt;

int* foo() {
#ifdef FOO
  return 0;
#else
  return nullptr;
#endif
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As expected, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-modernize&lt;/span&gt;&lt;/tt&gt; only replaced within the &lt;tt class="docutils literal"&gt;#else&lt;/tt&gt; clause because &lt;tt class="docutils literal"&gt;FOO&lt;/tt&gt; is not defined. We already know how to define it on the command line. We also know that a hypothetical compilation database could provide two entries for &lt;tt class="docutils literal"&gt;nullptr.cpp&lt;/tt&gt; - one with and one without &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-DFOO&lt;/span&gt;&lt;/tt&gt;. In this case, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-modernize&lt;/span&gt;&lt;/tt&gt; would actually run twice over the same file and replace both the &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; and the &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-a-compilation-database-for-your-project"&gt;
&lt;h3&gt;Creating a compilation database for your project&lt;/h3&gt;
&lt;p&gt;By now we have a good understanding of how to provide Clang tools with  compilation flags for simple files. What about whole projects, however? Assume you have a large existing project and you want to run tools on its source code. You already have a build system of some sort that compiles all the files. How do you tell Clang tools which flags are suitable for any file in the project?&lt;/p&gt;
&lt;p&gt;There are a few good options. A reasonably recent version of the CMake build tool supports emitting compilation databases &lt;a class="footnote-reference" href="#id9" id="id5"&gt;[4]&lt;/a&gt;. All you need is to run the &lt;tt class="docutils literal"&gt;cmake&lt;/tt&gt; step with the  &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-DCMAKE_EXPORT_COMPILE_COMMANDS&lt;/span&gt;&lt;/tt&gt; flag, and CMake will take it from there, emitting a &lt;tt class="docutils literal"&gt;compile_commands.json&lt;/tt&gt; file into your build directory.&lt;/p&gt;
&lt;p&gt;If you're not using CMake, there are other options. The Ninja build tool can also emit a compilation database since version 1.2, so a Gyp/Ninja combination should be good too.&lt;/p&gt;
&lt;p&gt;If your project doesn't use either, you should be able to roll your own without too much difficulty. Tools like &lt;a class="reference external" href="https://github.com/rizsotto/Bear"&gt;Build EAR&lt;/a&gt; may be helpful here.&lt;/p&gt;
&lt;p&gt;By the way, it should be clear that large projects is precisely the raison d'être of compilation databases. A single &amp;quot;database&amp;quot; file contains complete information about all the source files in the project, providing Clang tools with the compilation commands required to do their tasks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-custom-compilation-database"&gt;
&lt;h3&gt;A custom compilation database&lt;/h3&gt;
&lt;p&gt;It may be the case that you have a very specialized build system that already keeps some sort of record of the flags used to build each file. This is sometimes the case in large companies with monolithic code bases. For such scenarios, you'll be happy to find out that this aspect of Clang tools is fully customizable, because compilation database readers are based on a plugin system. The &lt;tt class="docutils literal"&gt;CompilationDatabase&lt;/tt&gt; interface (&lt;tt class="docutils literal"&gt;clang/include/clang/Tooling/CompilationDatabase.h&lt;/tt&gt;) is something you can implement on your own. The same header file that defines the interface also defines &lt;tt class="docutils literal"&gt;CompilationDatabasePlugin&lt;/tt&gt;, which can be used to link your own compilation database readers to Clang tools.&lt;/p&gt;
&lt;p&gt;The existing JSON compilation database implementation (&lt;tt class="docutils literal"&gt;clang/lib/Tooling/JSONCompilationDatabase.cpp&lt;/tt&gt;) is implemented as such a plugin, so there's a handy in-tree example for rolling your own.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="final-words"&gt;
&lt;h3&gt;Final words&lt;/h3&gt;
&lt;p&gt;For most users of Clang tools and people interested in writing custom tools, this post contains way too much information. Most chances are you won't need all of this. But I felt it's important, for the sake of completeness, to describe in full detail what compilation databases are, and how they tie into the large picture.&lt;/p&gt;
&lt;p&gt;This will help me focus on more internals and examples of Clang tooling in future posts without worrying about compilation databases again.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;clang-check&lt;/span&gt;&lt;/tt&gt; is the Clang static analysis tool; it performs control-flow based analysis that can detect cases like this.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;To motivate this - you wouldn't want the analyzer to bug you about &amp;quot;errors&amp;quot; in code that's &lt;tt class="docutils literal"&gt;#if 0&lt;/tt&gt;-ed out, or hidden behind an &lt;tt class="docutils literal"&gt;#ifdef&lt;/tt&gt; for a different compiler/platform, would you?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that this is critical for things like relative paths to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-I&lt;/span&gt;&lt;/tt&gt; - the tool needs to know where the compiler was actually invoked from to find the directories.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is what the upstream LLVM project uses for its own needs.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </summary><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Modern source-to-source transformation with Clang and libTooling</title><link href="http://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling" rel="alternate"></link><updated>2014-05-01T19:08:14-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-05-01:2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling</id><summary type="html">
        &lt;p&gt;I couple of years ago I published a blog post named &lt;a class="reference external" href="http://eli.thegreenplace.net/2012/06/08/basic-source-to-source-transformation-with-clang/"&gt;Basic source-to-source transformation with Clang&lt;/a&gt;, in which I presented a small but complete sample of a tool that performs C++ source-to-source rewriting using Clang. That post was (and still is) quite popular, but also severely out of date;  it's time to fix that.&lt;/p&gt;
&lt;p&gt;Clang is moving forward very fast. Today, to develop tools similar to the one presented in that post one should use the &amp;quot;tooling&amp;quot; library (libTooling). I hinted at its existence even in that post, but it was still at its infancy then. Now libTooling is a fairly mature layer through which it's possible to interact with Clang. Moreover, there are reasons to be optimistic about its stability, since tools using it pop up all the time, both in and outside the LLVM/Clang source tree &lt;a class="footnote-reference" href="#id4" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So I rewrote the tool presented in the &lt;a class="reference external" href="http://eli.thegreenplace.net/2012/06/08/basic-source-to-source-transformation-with-clang/"&gt;previous post&lt;/a&gt; using libTooling. The tool is very basic, but it demonstrates a lot of the machinery. It takes C++ code like:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* a, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; *b) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (a[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] &amp;gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) {
    b[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] = &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And adds some descriptive comments:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Begin function foo returning void&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;* a, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; *b) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (a[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] &amp;gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) &lt;span style="color: #007f00"&gt;// the &amp;#39;if&amp;#39; part&lt;/span&gt;
  {
    b[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] = &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;
  }
}
&lt;span style="color: #007f00"&gt;// End function foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Non-trivial code samples pasted into blog posts tend to go stale, so this time I'll just directly link to my &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;Github repository for LLVM and Clang samples&lt;/a&gt;, which I'm keeping functional fairly close to the LLVM trunk (as well as with released versions of LLVM, in branches). The direct path to the sample described here is &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src_clang/tooling_sample.cpp"&gt;src_clang/tooling_sample.cpp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The good thing about this repository is that it comes complete with a makefile which builds the tools &amp;amp; samples &lt;em&gt;out of tree&lt;/em&gt;, meaning that they can reside anywhere as long as the paths to LLVM &amp;amp; Clang headers and libraries are set up correctly. If you've ever tried to build an out-of-tree tool using LLVM or Clang as a library, you will not underestimate the utility of having this makefile available and continuously updated ;-)&lt;/p&gt;
&lt;p&gt;Anyway, it's time to explain the code.&lt;/p&gt;
&lt;div class="section" id="implementing-the-transformation-itself"&gt;
&lt;h3&gt;Implementing the transformation itself&lt;/h3&gt;
&lt;p&gt;The low-level details of the sample haven't changed much. An implementation of the &lt;tt class="docutils literal"&gt;ASTConsumer&lt;/tt&gt; interface chooses which AST parsing events to handle. &lt;tt class="docutils literal"&gt;MyASTConsumer&lt;/tt&gt; implements &lt;tt class="docutils literal"&gt;HandleTopLevelDecl&lt;/tt&gt;, so it will be invoked on each top-level declaration in the AST. It uses an implementation of &lt;tt class="docutils literal"&gt;RecursiveASTVisitor&lt;/tt&gt; to do the actual traversal over declaration AST nodes. &lt;tt class="docutils literal"&gt;MyASTVisitor&lt;/tt&gt; implements &lt;tt class="docutils literal"&gt;VisitFunctionDecl&lt;/tt&gt; to be able to emit comments before and after function definitions, and &lt;tt class="docutils literal"&gt;VisitStmt&lt;/tt&gt; to detect &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; statements and analyze them.&lt;/p&gt;
&lt;p&gt;Finally, a &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; is used to manage the textual changes to the source code. This is how Clang-based source to source transformations work - analysis of the AST lets us find out where to apply changes, and a &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; is used to actually apply those changes &lt;a class="footnote-reference" href="#id5" id="id2"&gt;[2]&lt;/a&gt;. The link between the two is the very accurate source location information managed by the AST for each node.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="becoming-a-tool-via-libtooling"&gt;
&lt;h3&gt;Becoming a tool via libTooling&lt;/h3&gt;
&lt;p&gt;What's really new about this sample is how it turns this low-level transformation logic into an actual tool. With libTooling, we no longer need to laboriously set up an instance of the compiler front-end manually. The &lt;tt class="docutils literal"&gt;ClangTool&lt;/tt&gt; class does it all for us, while &lt;tt class="docutils literal"&gt;CommonOptionsParser&lt;/tt&gt; simplifies the command-line interface of the tool. All we need is to implement a &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; - a very central abstraction within Clang for entities that produce stuff from the parsed AST &lt;a class="footnote-reference" href="#id6" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;MyFrontendAction&lt;/tt&gt; is very simple. All it does is provide our custom AST consumer in &lt;tt class="docutils literal"&gt;CreateASTConsumer&lt;/tt&gt; and sets up the &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt;. Note that &lt;tt class="docutils literal"&gt;ClangTool&lt;/tt&gt; will create a new &lt;tt class="docutils literal"&gt;MyFrontendAction&lt;/tt&gt; instance per file, so it's correct to have a new &lt;tt class="docutils literal"&gt;Rewriter&lt;/tt&gt; in each instance. This is enabled by adding another layer of abstraction - the &lt;tt class="docutils literal"&gt;FrontendActionFactory&lt;/tt&gt;. The factory pattern here is used to decouple the process of creating objects implementing &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; from the concrete &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; subclasses used by our tool. It also lets us customize the creation process to a greater extent - for example passing additional information into each &lt;tt class="docutils literal"&gt;MyFrontendAction&lt;/tt&gt; object. In our sample, advanced features aren't really needed so we use the convenience &lt;tt class="docutils literal"&gt;newFrontendActionFactory&lt;/tt&gt; template which creates a basic factory behind the scenes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="invoking-the-tool"&gt;
&lt;h3&gt;Invoking the tool&lt;/h3&gt;
&lt;p&gt;It's important to spend a few minutes to discuss how to invoke the tool. libTooling has the concept of a &lt;em&gt;compilation database&lt;/em&gt;, which tells tools about the compiler options used to build the sources under consideration. Describing compilation databases in detail is out of scope here, and I may devote a separate post to it in the future, but in the meantime it helps knowing that a compilation database isn't strictly required to run tools.&lt;/p&gt;
&lt;p&gt;The libTooling command-line parser (&lt;tt class="docutils literal"&gt;CommonOptionsParser&lt;/tt&gt;) supports providing compiler flags on the command line, following the special flag &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt;. Think of it as a simplified, ad-hoc version of a compilation database.&lt;/p&gt;
&lt;p&gt;If you clone and build the &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples"&gt;llvm-clang-samples&lt;/a&gt; repository, you can invoke the sample discussed here as follows:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ build/tooling_sample inputs/cfunc_with_if.c --
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; at the end: this invocation means there are no special flags the tool needs to know about while analyzing the file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-next"&gt;
&lt;h3&gt;What next&lt;/h3&gt;
&lt;p&gt;This post provides an introduction into building a source-to-source transformation tool based on Clang's libTooling. It should provide a foundation for building custom tools, and nicely complements the existing Clang libTooling documentation and examples. Check them out, by the way. Clang actually has &lt;a class="reference external" href="http://clang.llvm.org/docs/index.html"&gt;decent documentation&lt;/a&gt; on using libTooling these days.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The &lt;a class="reference external" href="http://llvm.org/devmtg/2014-04/"&gt;Euro LLVM 2014 conference&lt;/a&gt;, held just a couple of weeks ago, has a talk and a tutorial about writing Clang tools based on libTooling.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that the code presented here uses low-level APIs. libTooling has some more convenient higher-level APIs which I hope to talk about in future posts.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A &lt;tt class="docutils literal"&gt;FrontendAction&lt;/tt&gt; is used throughout the main Clang compiler as well. For example, the Clang code generator - the component responsible for emitting LLVM IR from the AST - defines a subclass named &lt;tt class="docutils literal"&gt;CodeGenAction&lt;/tt&gt; which is its main entry point.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </summary><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Dynamically generating Python test cases</title><link href="http://eli.thegreenplace.net/2014/04/02/dynamically-generating-python-test-cases" rel="alternate"></link><updated>2014-04-02T06:44:15-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-04-02:2014/04/02/dynamically-generating-python-test-cases</id><summary type="html">
        &lt;p&gt;Testing is crucial. While many different kinds and levels of testing exist, there's good library support only for unit tests (the Python &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt; package and its moral equivalents in other languages). However, unit testing does not cover all kinds of testing we may want to do - for example, all kinds of whole program tests and integration tests. This is where we usually end up with a custom &amp;quot;test runner&amp;quot; script.&lt;/p&gt;
&lt;p&gt;Having written my share of such custom test runners, I've recently gravitated towards a very convenient approach which I want to share here. In short, I'm actually using Python's &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt;, combined with the dynamic nature of the language, to run all kinds of tests.&lt;/p&gt;
&lt;p&gt;Let's assume my tests are some sort of data files which have to be fed to a program. The output of the program is compared to some &amp;quot;expected results&amp;quot; file, or maybe is encoded in the data file itself in some way. The details of this are immaterial, but seasoned programmers usually encounter such testing rigs very frequently. It commonly comes up when the program under test is a data-transformation mechanism of some sort (compiler, encryptor, encoder, compressor, translator etc.)&lt;/p&gt;
&lt;p&gt;So you write a &amp;quot;test runner&amp;quot;. A script that looks at some directory tree, finds all the &amp;quot;test files&amp;quot; there, runs each through the transformation, compares, reports, etc. I'm sure all these test runners share a lot of common infrastructure - I know that mine do.&lt;/p&gt;
&lt;p&gt;Why not employ Python's existing &amp;quot;test runner&amp;quot; capabilities to do the same?&lt;/p&gt;
&lt;p&gt;Here's a very short code snippet that can serve as a template to achieve this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;unittest&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;TestsContainer&lt;/span&gt;(unittest.TestCase):
    longMessage = &lt;span style="color: #00007f"&gt;True&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;make_test_function&lt;/span&gt;(description, a, b):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;test&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.assertEqual(a, b, description)
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; test

&lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #7f007f"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    testsmap = {
        &lt;span style="color: #7f007f"&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;: [&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;],
        &lt;span style="color: #7f007f"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;: [&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;],
        &lt;span style="color: #7f007f"&gt;&amp;#39;baz&amp;#39;&lt;/span&gt;: [&lt;span style="color: #007f7f"&gt;5&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;5&lt;/span&gt;]}

    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; name, params &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; testsmap.iteritems():
        test_func = make_test_function(name, params[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;], params[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;])
        &lt;span style="color: #00007f"&gt;setattr&lt;/span&gt;(TestsContainer, &lt;span style="color: #7f007f"&gt;&amp;#39;test_{0}&amp;#39;&lt;/span&gt;.format(name), test_func)

    unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happens here:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The test class &lt;tt class="docutils literal"&gt;TestsContainer&lt;/tt&gt; will contain dynamically generated test methods.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;make_test_function&lt;/tt&gt; creates a test function (a method, to be precise) that compares its inputs. This is just a trivial template - it could do anything, or there can be multiple such &amp;quot;makers&amp;quot; fur multiple purposes.&lt;/li&gt;
&lt;li&gt;The loop creates test functions from the data description in &lt;tt class="docutils literal"&gt;testmap&lt;/tt&gt; and attaches them to the test class.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Keep in mind that this is a very basic example. I hope it's obvious that &lt;tt class="docutils literal"&gt;testmap&lt;/tt&gt; could really be test files found on disk, or whatever else. The main idea here is the dynamic test method creation.&lt;/p&gt;
&lt;p&gt;So what do we gain from this, you may ask? Quite a lot. &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt; is powerful - armed to its teeth with useful tools for testing. You can now invoke tests from the command line, control verbosity, control &amp;quot;fast fail&amp;quot; behavior, easily filter which tests to run and which not to run, use all kinds of assertion methods for readability and reporting (why write your own smart list comparison assertions?). Moreover, you can build on top of any number of third-party tools for working with &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt; results - HTML/XML reporting, logging, automatic CI integration, and so on. The possibilities are endless.&lt;/p&gt;
&lt;p&gt;One interesting variation on this theme is aiming the dynamic generation at a different testing &amp;quot;layer&amp;quot;. &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt; defines any number of &amp;quot;test cases&amp;quot; (classes), each with any number of &amp;quot;tests&amp;quot; (methods). In the code above, we generate a bunch of tests into a single test case. Here's a sample invocation to see this in action:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python dynamic_test_methods.py -v
test_bar (__main__.TestsContainer) ... FAIL
test_baz (__main__.TestsContainer) ... ok
test_foo (__main__.TestsContainer) ... ok

======================================================================
FAIL: test_bar (__main__.TestsContainer)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;dynamic_test_methods.py&amp;quot;, line 8, in test
    self.assertEqual(a, b, description)
AssertionError: 1 != 2 : bar

----------------------------------------------------------------------
Ran 3 tests in 0.001s

FAILED (failures=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, all data pairs in &lt;tt class="docutils literal"&gt;testmap&lt;/tt&gt; are translated into distinctly named test methods within the single test case &lt;tt class="docutils literal"&gt;TestsContainer&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Very easily, we can cut this a different way, by generating a whole test case for each data item:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #00007f"&gt;unittest&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;DynamicClassBase&lt;/span&gt;(unittest.TestCase):
    longMessage = &lt;span style="color: #00007f"&gt;True&lt;/span&gt;

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;make_test_function&lt;/span&gt;(description, a, b):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;test&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.assertEqual(a, b, description)
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; test

&lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #7f007f"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    testsmap = {
        &lt;span style="color: #7f007f"&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;: [&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;],
        &lt;span style="color: #7f007f"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;: [&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;],
        &lt;span style="color: #7f007f"&gt;&amp;#39;baz&amp;#39;&lt;/span&gt;: [&lt;span style="color: #007f7f"&gt;5&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;5&lt;/span&gt;]}

    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; name, params &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; testsmap.iteritems():
        test_func = make_test_function(name, params[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;], params[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;])
        klassname = &lt;span style="color: #7f007f"&gt;&amp;#39;Test_{0}&amp;#39;&lt;/span&gt;.format(name)
        &lt;span style="color: #00007f"&gt;globals&lt;/span&gt;()[klassname] = &lt;span style="color: #00007f"&gt;type&lt;/span&gt;(klassname,
                                   (DynamicClassBase,),
                                   {&lt;span style="color: #7f007f"&gt;&amp;#39;test_gen_{0}&amp;#39;&lt;/span&gt;.format(name): test_func})

    unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Most of the code here remains the same. The difference is in the lines within the loop: now instead of dynamically creating test methods and attaching them to the test case, we create whole test cases - one per data item, with a single test method. All test cases derive from &lt;tt class="docutils literal"&gt;DynamicClassBase&lt;/tt&gt; and hence from &lt;tt class="docutils literal"&gt;unittest.TestCase&lt;/tt&gt;, so they will be auto-discovered by the &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt; machinery. Now an execution will look like this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python dynamic_test_classes.py -v
test_gen_bar (__main__.Test_bar) ... FAIL
test_gen_baz (__main__.Test_baz) ... ok
test_gen_foo (__main__.Test_foo) ... ok

======================================================================
FAIL: test_gen_bar (__main__.Test_bar)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;dynamic_test_classes.py&amp;quot;, line 8, in test
    self.assertEqual(a, b, description)
AssertionError: 1 != 2 : bar

----------------------------------------------------------------------
Ran 3 tests in 0.000s

FAILED (failures=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why would you want to generate whole test cases dynamically rather than just single tests? It all depends on your specific needs, really. In general, test cases are better isolated and share less, than tests within one test case. Moreover, you may have a huge amount of tests and want to use tools that shard your tests for parallel execution - in this case you almost certainly need separate test cases.&lt;/p&gt;
&lt;p&gt;I've used this technique in a number of projects over the past couple of years and found it very useful; more than once, I replaced a whole complex test runner program with about 20-30 lines of code using this technique, and gained access to many more capabilities for free.&lt;/p&gt;
&lt;p&gt;Python's built-in test discovery, reporting and running facilities are very powerful. Coupled with third-party tools they can be even more powerful. Leveraging all this power for &lt;em&gt;any&lt;/em&gt; kind of testing, and not just unit testing, is possible with very little code, due to Python's dynamism. I hope you find it useful too.&lt;/p&gt;

    </summary><category term="Python"></category></entry><entry><title>Summary of reading: January - March 2014</title><link href="http://eli.thegreenplace.net/2014/03/30/summary-of-reading-january-march-2014" rel="alternate"></link><updated>2014-03-30T16:03:35-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-03-30:2014/03/30/summary-of-reading-january-march-2014</id><summary type="html">
        &lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;Why We Get Fat, And What to Do About it&amp;quot; by Gary Taubes - Since I've been recently interested in nutrition again, Taubes naturally came up on the radar due to the huge popularity and high ratings of his books (at least on Amazon). I decided to start with this one as an introduction, and read the much longer and more comprehensive &amp;quot;Good Calories, Bad Calories&amp;quot; later if I this one went well. Yeah, it did. The book starts kind-of slow and repetitive and by the end of the first third I wished he would get to the point. But the middle third or so of the book is awesome. What's most awesome about it is the no-nonsense science. At some point after reading a particularly interesting explanation (of how insulin affects fat intake and processing), I flipped open my copy of &amp;quot;Life: The Science of Biology&amp;quot; and read the relevant few pages. It matched exactly, and from that moment I was hooked. I'm not very easily convinced, but this book definitely made me reconsider some notions I wasn't questioning before. The author's points in favor of low-carb diets are definitely convincing, and his attempts to actually unravel and understand relevant research and trials is very commendable. I definitely plan to read &amp;quot;Good Calories, Bad Calories&amp;quot; now to learn more on the hypothesis Taubes presents.&lt;/li&gt;
&lt;li&gt;&amp;quot;Juvenilia&amp;quot; by Miguel Cané (read in Spanish) - an autobiographic account of the author's years in the prestigious Colegio Nacional de Buenos Aires. Occasionally amusing, I presume this account is much more interesting to persons familiar with the school in question, or at least the situation in Argentina in the 1860s.&lt;/li&gt;
&lt;li&gt;&amp;quot;Everything I Know&amp;quot; by Paul Jarvis - your typical motivational book, on how one should stop being afraid and JFDI. Can't say I related to it too much. Maybe I should try reading it again some time.&lt;/li&gt;
&lt;li&gt;&amp;quot;Good Calories, Bad Calories: Fats, Carbs, and the Controversial Science of Diet and Health&amp;quot; by Gary Taubes - The earlier, much more comprehensive and encyclopedic precursor to &amp;quot;Why We Get Fat&amp;quot; by the same author. This book provides the same conclusions, but spends significantly more ink on dissecting the published nutritional research of the past century. The author methodically addresses all the common &amp;quot;best practices&amp;quot; of high-carb, low-fat diet for healthy living. This deeper definitely look makes Taubes's position appear even stronger. I really wish someone would be running the experiments suggested by the author in the epilogue - this definitely seems like an area that needs some proper, peer-reviewed scientific method-backed research.&lt;/li&gt;
&lt;li&gt;&amp;quot;The Power of Habit&amp;quot; by Charles Duhigg - while the core ideas presented in the first third of the book are interesting, the rest of it felt like an empty filler full with anecdotes that, while well written, have little to do with the main theme of the book. Still, it's an intriguing and enjoyable book to read; just don't expect too much from it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Re-reads:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;Masters of Doom&amp;quot; by David Kushner&lt;/li&gt;
&lt;/ul&gt;
    </summary><category term="Book reviews"></category></entry><entry><title>pyelftools 0.22 released</title><link href="http://eli.thegreenplace.net/2014/03/30/pyelftools-0-22-released" rel="alternate"></link><updated>2014-03-30T06:57:45-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-03-30:2014/03/30/pyelftools-0-22-released</id><summary type="html">
        Version 0.22 of &lt;a href="https://github.com/eliben/pyelftools"&gt;pyelftools&lt;/a&gt; was released today (on PyPI too). Some nice new features in this release - most notably initial support for DWARF v4, as well as better support for ARM objects (including 64-bit ARM).

By the way, I recently noticed that pyelftools appears in the open source credits page of Chrome (&lt;code&gt;chrome://credits&lt;/code&gt;). I knew the Chrome and Chrome OS teams are using it for some of their tools &amp; testing, but hadn't bothered to check the credits page until recently. This is probably the most high-profile (at least publicly visible) user of pyelftools.

    </summary><category term="Linux"></category><category term="Python"></category></entry><entry><title>Rewriting the lexer benchmark in Go</title><link href="http://eli.thegreenplace.net/2014/03/27/rewriting-the-lexer-benchmark-in-go" rel="alternate"></link><updated>2014-03-27T05:58:29-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-03-27:2014/03/27/rewriting-the-lexer-benchmark-in-go</id><summary type="html">
        &lt;p&gt;Last year I was toying with a simple lexer (for the &lt;a class="reference external" href="http://llvm.org/docs/TableGen/LangRef.html"&gt;TableGen language&lt;/a&gt;, because why not), implementing it using &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/07/16/hand-written-lexer-in-javascript-compared-to-the-regex-based-ones/"&gt;multiple approaches&lt;/a&gt; in both &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/06/25/regex-based-lexical-analysis-in-python-and-javascript/"&gt;Python and Javascript&lt;/a&gt;. Redoing the same task using multiple approaches and using more than one language is a very interesting code kata and a great way to learn.&lt;/p&gt;
&lt;p&gt;Since I've been recently looking at Go, I continued the exercise by reimplementing the lexer (the hand-written one, not a regex-based) in Go. The full code is &lt;a class="reference external" href="https://gist.github.com/eliben/9740414#file-lexer-go"&gt;available here&lt;/a&gt; (along with a large input file used for benchmarking).&lt;/p&gt;
&lt;p&gt;Naturally, since my previous posts did performance comparisons between Python and Javascript, I wanted to add Go to the graph. I also had to rerun all the benchmarks because from the time of writing those posts I got a &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/11/23/a-new-ubuntu-machine-for-home/"&gt;new, much faster, machine&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Anyway, here it is:&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2014/03/comparison-py-js-go.png" /&gt;
&lt;p&gt;Since Python is so slow here, it's hard to see the difference between the fastest versions, but the handwritten Go lexer is roughly on par with the Javascript one (33 vs. 31 msec). The benchmarks were run on my i7-4771 machine (amd64); go1.2.1, Node.js v0.10.26.&lt;/p&gt;
&lt;p&gt;Now, this is quite literally the first non-trivial Go program I've written and I'm a neophyte by all measures, so any tips on the code would be very welcome. I tried to stay faithful to the Javascript implementation in terms of the algorithm, so the comparison would be fair.&lt;/p&gt;
&lt;p&gt;That said, shortly after completing the code I started wondering if it could be made faster. There's something about Go that makes you think about performance on a low level, not unlike when programming in C. Maybe it's because so many things are explicit - pointers, slices, etc.&lt;/p&gt;
&lt;p&gt;Anyhow, the code that uses a lexer to fill in a slice of tokens caught my eyes:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;toks := []Token{}

startTime := time.Now()
&lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; {
        nt := nl.NextToken()
        toks = append(toks, nt)
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; nt.Name == EOF {
                &lt;span style="color: #00007f; font-weight: bold"&gt;break&lt;/span&gt;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That &lt;tt class="docutils literal"&gt;toks = append(toks, nt)&lt;/tt&gt; in particular. As the size grows, &lt;tt class="docutils literal"&gt;toks&lt;/tt&gt; will have to be reallocated and all its contents copied over. Since the input in my case had close to 200000 tokens and reallocation doubles the slice size, this means that in the order of 16 reallocations have to happen here, each time copying all the elements over. If that sounds like a lot of wasted work to you, that's because it is.&lt;/p&gt;
&lt;p&gt;So I tried replacing the first line with:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;toks := &lt;span style="color: #00007f"&gt;make&lt;/span&gt;([]Token, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;200000&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And wow, the runtime dropped from 33 to 20 ms, making it 33% faster than the JS version. To be fair to JS I tried to perform the same optimization there (instead of pushing onto an array, create a large one in advance), but this has actually made things &lt;em&gt;slower&lt;/em&gt;. &lt;a class="reference external" href="https://thewayofcode.wordpress.com/tag/array-pre-allocation/"&gt;Some sources online&lt;/a&gt; claim that V8 (which is what I'm running underneath, since my local code runs on Node.js) doesn't like preallocating large arrays.&lt;/p&gt;
&lt;p&gt;So as is often the case with benchmarks, it's difficult to do an apples-to-apples comparison here. A hunch tells me that in a fully optimized (by a programmer skilled in the language) version of this benchmark, Go would still win, because its nature (typed, compiled to native code, and exposing a lot of low-level details) make it easier to reason about in terms of performance. But performance was not really the point here - I just wanted to see how easy it is to reimplement the same lexer in Go.&lt;/p&gt;
&lt;p&gt;Hopefully the code would be useful/interesting to someone; please let me know what I could've done better.&lt;/p&gt;

    </summary><category term="Go"></category><category term="Javascript"></category><category term="Programming"></category></entry><entry><title>Clearing the database with Django commands</title><link href="http://eli.thegreenplace.net/2014/02/20/clearing-the-database-with-django-commands" rel="alternate"></link><updated>2014-02-20T06:01:07-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-02-20:2014/02/20/clearing-the-database-with-django-commands</id><summary type="html">
        &lt;p&gt;In a &lt;a class="reference external" href="http://eli.thegreenplace.net/2014/02/15/programmatically-populating-a-django-database/"&gt;previous post&lt;/a&gt;, I presented a method of loading initial data into a Django database by using a custom management command. An accompanying task is cleaning the database up. Here I want to discuss a few options of doing that.&lt;/p&gt;
&lt;p&gt;First, some general design notes on Django management commands. If you run &lt;tt class="docutils literal"&gt;manage.py help&lt;/tt&gt; you'll see a whole bunch of commands starting with &lt;tt class="docutils literal"&gt;sql&lt;/tt&gt;. These all share a common idiom - print SQL statements to the standard output. Almost all DB engines have means to pipe commands from the standard input, so this plays great with the Unix philosophy of building pipes of single-task programs.&lt;/p&gt;
&lt;p&gt;Django even provides a convenient shortcut for us to access the actual DB that's being used with a given project - the &lt;tt class="docutils literal"&gt;dbshell&lt;/tt&gt; command.&lt;/p&gt;
&lt;p&gt;As an example, we have the &lt;tt class="docutils literal"&gt;sqlflush&lt;/tt&gt; command, which returns a list of the SQL statements required to return all tables in the database to the state they were in just after they were installed. In a simple blog-like application with &amp;quot;post&amp;quot; and &amp;quot;tag&amp;quot; models, it may return something like:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python manage.py sqlflush
BEGIN;
DELETE FROM &amp;quot;auth_permission&amp;quot;;
DELETE FROM &amp;quot;auth_group&amp;quot;;
DELETE FROM &amp;quot;django_content_type&amp;quot;;
DELETE FROM &amp;quot;django_session&amp;quot;;
DELETE FROM &amp;quot;blogapp_tag&amp;quot;;
DELETE FROM &amp;quot;auth_user_groups&amp;quot;;
DELETE FROM &amp;quot;auth_group_permissions&amp;quot;;
DELETE FROM &amp;quot;auth_user_user_permissions&amp;quot;;
DELETE FROM &amp;quot;blogapp_post&amp;quot;;
DELETE FROM &amp;quot;blogapp_post_tags&amp;quot;;
DELETE FROM &amp;quot;auth_user&amp;quot;;
DELETE FROM &amp;quot;django_admin_log&amp;quot;;

COMMIT;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note there's a lot of tables here, because the project also installed the &lt;tt class="docutils literal"&gt;admin&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;auth&lt;/tt&gt; applications from &lt;tt class="docutils literal"&gt;django.contrib&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;We can actually execute these SQL statements, and thus wipe out all the DB tables in our database, by running:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python manage.py sqlflush | python manage.py dbshell
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For this particular sequence, since it's so useful, Django has a special built-in command named &lt;tt class="docutils literal"&gt;flush&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;But there's a problem with running &lt;tt class="docutils literal"&gt;flush&lt;/tt&gt; that may or may not bother you, depending on what your goals are. It wipes out &lt;em&gt;all&lt;/em&gt; tables, and this means authentication data as well. So if you've created a default admin user when jump-starting the application, you'll have to re-create it now.&lt;/p&gt;
&lt;p&gt;Perhaps there's a more gentle way to delete just your app's data, without messing with the other apps? Yes. In fact, I'm going to show a number of ways.&lt;/p&gt;
&lt;p&gt;First, let's see what other existing management commands have to offer. &lt;tt class="docutils literal"&gt;sqlclear&lt;/tt&gt; will emit the commands needed to drop all tables in a given app. For example:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python manage.py sqlclear blogapp
BEGIN;
DROP TABLE &amp;quot;blogapp_tag&amp;quot;;
DROP TABLE &amp;quot;blogapp_post&amp;quot;;
DROP TABLE &amp;quot;blogapp_post_tags&amp;quot;;

COMMIT;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we can use it to target a specific app, rather than using the kill-all approach of flush. There's a catch, though. While &lt;tt class="docutils literal"&gt;flush&lt;/tt&gt; runs &lt;tt class="docutils literal"&gt;delete&lt;/tt&gt; to wipe all data from the tables, &lt;tt class="docutils literal"&gt;sqlclear&lt;/tt&gt; removes the actual tables. So in order to be able to work with the database, these tables have to be re-created. Worry not, there's a command for that:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python manage.py sql blogapp
BEGIN;
CREATE TABLE &amp;quot;blogapp_post_tags&amp;quot; (
    &amp;quot;id&amp;quot; integer NOT NULL PRIMARY KEY AUTOINCREMENT,
    &amp;quot;post_id&amp;quot; integer NOT NULL REFERENCES &amp;quot;blogapp_post&amp;quot; (&amp;quot;id&amp;quot;),
    &amp;quot;tag_id&amp;quot; varchar(50) NOT NULL REFERENCES &amp;quot;blogapp_tag&amp;quot; (&amp;quot;name&amp;quot;),
    UNIQUE (&amp;quot;post_id&amp;quot;, &amp;quot;tag_id&amp;quot;)
)
;
CREATE TABLE &amp;quot;blogapp_post&amp;quot; (
    &amp;quot;id&amp;quot; integer NOT NULL PRIMARY KEY AUTOINCREMENT,
 &amp;lt;.......&amp;gt;
)
;
CREATE TABLE &amp;quot;blogapp_tag&amp;quot; (
 &amp;lt;.......&amp;gt;
)
;

COMMIT;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So here's a first way to do a DB cleanup: pipe &lt;tt class="docutils literal"&gt;sqlclear appname&lt;/tt&gt; into &lt;tt class="docutils literal"&gt;dbshell&lt;/tt&gt;. Then pipe &lt;tt class="docutils literal"&gt;sql appname&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;dbshell&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;An alternative way, which I like less, is to take the subset of &lt;tt class="docutils literal"&gt;DELETE&lt;/tt&gt; statements generated by &lt;tt class="docutils literal"&gt;sqlflush&lt;/tt&gt;, save them in a text file, and pipe it through to &lt;tt class="docutils literal"&gt;dbshell&lt;/tt&gt; when needed. For example, for the blog app discussed above, these statements should do it:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;BEGIN;
DELETE FROM &amp;quot;blogapp_tag&amp;quot;;
DELETE FROM &amp;quot;blogapp_post&amp;quot;;
DELETE FROM &amp;quot;blogapp_post_tags&amp;quot;;
DELETE
COMMIT;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The reason I don't like it is that it forces you to have explicit table names stored somewhere, which is a duplication of the existing models. If you happen to change some of your foreign keys, for example, tables will need changing so this file will have to be regenerated.&lt;/p&gt;
&lt;p&gt;The approach I like best is more programmatic. Django's model API is flexible and convenient, and we can just use it in a custom management command:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #00007f"&gt;django.core.management.base&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; BaseCommand
&lt;span style="color: #00007f; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #00007f"&gt;blogapp.models&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; Post, Tag

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Command&lt;/span&gt;(BaseCommand):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;handle&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, *args, **options):
        Tag.objects.all().delete()
        Post.objects.all().delete()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Save this code as &lt;tt class="docutils literal"&gt;blogapp/management/commands/clear_models.py&lt;/tt&gt;, and now it can be invoked with:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python manage.py clear_models
&lt;/pre&gt;&lt;/div&gt;

    </summary><category term="Django"></category></entry><entry><title>Squashing Github pull requests into a single commit</title><link href="http://eli.thegreenplace.net/2014/02/19/squashing-github-pull-requests-into-a-single-commit" rel="alternate"></link><updated>2014-02-19T05:55:04-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-02-19:2014/02/19/squashing-github-pull-requests-into-a-single-commit</id><summary type="html">
        &lt;p&gt;Github's pull requests are a terrific tool for collaborating on open-source projects. I get one or two a week on average for &lt;a class="reference external" href="https://github.com/eliben/"&gt;my projects&lt;/a&gt;, and I love it. The UI is very clean - you get to see exactly the changes, the full branch if you'd like, even the Travis CI integration is working checking that the branch still passes your tests.&lt;/p&gt;
&lt;p&gt;But one thing occasionally bothers me, and that's pull requests that come loaded with several temporary commits. I often find myself asking contributors to squash those into a single descriptive commit. Not everyone knows how to do this effectively, hence this quick writeup.&lt;/p&gt;
&lt;p&gt;I like my Git just like the next guy, and often my own project history is full of small, temporary-stage commits with names like &amp;quot;more features of FOO implemented&amp;quot;. But this isn't acceptable when taking outside contributions. Merging two different thought streams is difficult, and it makes much more sense for each pull request to be a self-contained single commit. If there's more than one feature coming in, separate pull requests is the way to go.&lt;/p&gt;
&lt;p&gt;So I won't start from the basics - &lt;a class="reference external" href="https://help.github.com/articles/using-pull-requests"&gt;the Github docs are great&lt;/a&gt;. I want to explain what to do when faced with a plea to &amp;quot;modify the pull request to have a single commit&amp;quot;.&lt;/p&gt;
&lt;p&gt;Some folks do it by hastily creating a new branch, porting all changes to it with a patch file and creating a separate pull request. But this is headache both for the contributor and project maintainer. There's an easier way.&lt;/p&gt;
&lt;p&gt;Let's say you have two commits in your branch:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ git log --oneline origin/master..new-feature
73bbc09 Hack some more
f33b240 Hack hack
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What the project maintainer wants is a single commit in the diff between your &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;new-feature&lt;/span&gt;&lt;/tt&gt; branch and the project's &lt;tt class="docutils literal"&gt;master&lt;/tt&gt; branch. What we need here is the &lt;em&gt;interactive rebase&lt;/em&gt; feature of Git:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ git rebase -i origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will open your editor with these contents:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;pick f33b240 Hack hack
pick 73bbc09 Hack some more

# Rebase e54a9a9..73bbc09 onto e54a9a9
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like &amp;quot;squash&amp;quot;, but discard this commit&amp;#39;s log message
#  x, exec = run command (the rest of the line) using shell
# ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Change the &lt;tt class="docutils literal"&gt;pick&lt;/tt&gt; on the second like to &lt;tt class="docutils literal"&gt;squash&lt;/tt&gt; (or just &lt;tt class="docutils literal"&gt;s&lt;/tt&gt;), save the file and exit. You'll then get another editor with a commit message to edit:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;# This is a combination of 2 commits.
# The first commit&amp;#39;s message is:

Hack hack

# This is the 2nd commit message:

Hack some more

# Please enter the commit message for your changes. Lines starting
# with &amp;#39;#&amp;#39; will be ignored, and an empty message aborts the commit.
# ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the time to create a single descriptive commit message for your pull request. Save and exit. The log will now show:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ git log --oneline origin/master..new-feature
e020524 &amp;lt;the first line of your modified commit message&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Single commit - great. All you have to do now is push this branch to your fork. You'll have to use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--force&lt;/span&gt;&lt;/tt&gt; flag to &lt;tt class="docutils literal"&gt;push&lt;/tt&gt; here, since the rebase messed the ancestry relationship between what's currently in the remote and your local branch.&lt;/p&gt;
&lt;p&gt;Once you push, the Github pull request will auto-update and will only contain a single commit. Hopefully the target project has some sort of CI integration like Travis, so wait a bit more to see that everything still passes, and you're good to go.&lt;/p&gt;

    </summary><category term="Version control"></category></entry><entry><title>Programmatically populating a Django database</title><link href="http://eli.thegreenplace.net/2014/02/15/programmatically-populating-a-django-database" rel="alternate"></link><updated>2014-02-15T05:43:52-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-02-15:2014/02/15/programmatically-populating-a-django-database</id><summary type="html">
        &lt;p&gt;This is a quick post to demonstrate a very useful was of programmatically populating the models (i.e. database) of a Django application.&lt;/p&gt;
&lt;p&gt;The canonical way to accomplish this is fixtures - the &lt;tt class="docutils literal"&gt;loaddata&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;dumpdata&lt;/tt&gt; commands, but these seem to be more useful when you already have some data in the DB. Alternatively, you could generate the JSON information loadable by &lt;tt class="docutils literal"&gt;loaddata&lt;/tt&gt; programmatically, but this would require following its format exactly (which means observing how real dumps are structured). One could, for the very first entries, just laboriously hammer them in through the admin interface. As programmers, however, we have a natural resentment for such methods.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2014/02/cGhJp6B-e1392433920338.jpg" /&gt;
&lt;p&gt;Since Django apps are just Python modules, there's a much easier way. The &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/intro/tutorial01/"&gt;very first chapter of the Django tutorial&lt;/a&gt; hints at the approach by test-driving the &lt;tt class="docutils literal"&gt;shell&lt;/tt&gt; management command, which opens a Python shell in which the application is accessible, so the model classes can be imported and through them data can be both examined and created.&lt;/p&gt;
&lt;p&gt;The same tutorial also mentions that you can bypass &lt;tt class="docutils literal"&gt;manage.py&lt;/tt&gt; by pointing &lt;tt class="docutils literal"&gt;DJANGO_SETTINGS_MODULE&lt;/tt&gt; to your project's settings and then calling &lt;tt class="docutils literal"&gt;django.setup()&lt;/tt&gt;. This provides a clue on how the same steps can be done from a script, but in fact there's an even easier way.&lt;/p&gt;
&lt;p&gt;There's no need to bypass &lt;tt class="docutils literal"&gt;manage.py&lt;/tt&gt;, since it's a wonderful convenience wrapper &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/ref/django-admin/"&gt;around the Django project administration tools&lt;/a&gt;. It can be used to create custom management commands - e.g. your own commands parallel to &lt;tt class="docutils literal"&gt;shell&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;dumpdata&lt;/tt&gt;, and so on. Not only that creating such commands gives you a very succinct, boilterplate-free way of writing custom management scripts, it also gives you a natural location to house them, per application.&lt;/p&gt;
&lt;p&gt;Here's some simple code that adds a couple of tags into a blog-like model. Let's say the application is named &lt;tt class="docutils literal"&gt;blogapp&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #00007f"&gt;django.core.management.base&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; BaseCommand
&lt;span style="color: #00007f; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #00007f"&gt;blogapp.models&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;import&lt;/span&gt; Post, Tag

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Command&lt;/span&gt;(BaseCommand):
    args = &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;foo bar ...&amp;gt;&amp;#39;&lt;/span&gt;
    help = &lt;span style="color: #7f007f"&gt;&amp;#39;our help string comes here&amp;#39;&lt;/span&gt;

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;_create_tags&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        tlisp = Tag(name=&lt;span style="color: #7f007f"&gt;&amp;#39;Lisp&amp;#39;&lt;/span&gt;)
        tlisp.save()

        tjava = Tag(name=&lt;span style="color: #7f007f"&gt;&amp;#39;Java&amp;#39;&lt;/span&gt;)
        tjava.save()

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;handle&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, *args, **options):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;._create_tags()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code has to be placed in a file within the &lt;tt class="docutils literal"&gt;blogapp/management/commands&lt;/tt&gt; directory in your project. If that directory doesn't exist, create it. The name of the script is the name of the custom command, so let's call it &lt;tt class="docutils literal"&gt;populate_db.py&lt;/tt&gt;. Another thing that has to be done is creating &lt;tt class="docutils literal"&gt;__init__.py&lt;/tt&gt; files in both the &lt;tt class="docutils literal"&gt;management&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;commands&lt;/tt&gt; directories, because these have to be Python packages. The directory tree will look like this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;blogapp
├── admin.py
├── __init__.py
├── management
│   ├── commands
│   │   ├── __init__.py
│   │   └── populate_db.py
│   └── __init__.py
├── models.py
... other files
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's it. Now you should be able to invoke this command with:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python manage.py populate_db
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the facilities of &lt;tt class="docutils literal"&gt;manage.py&lt;/tt&gt; are available, such as help:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ python manage.py help populate_db
Usage: manage.py populate_db [options] &amp;lt;foo bar ...&amp;gt;

our help string comes here

Options:
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note how &lt;tt class="docutils literal"&gt;help&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; are taken from the &lt;tt class="docutils literal"&gt;Command&lt;/tt&gt; class we defined. &lt;tt class="docutils literal"&gt;manage.py&lt;/tt&gt; will also pass custom positional arguments and keyword options to our command, if needed. More details on writing custom management commands are available in &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/howto/custom-management-commands/"&gt;this Django howto&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once you start playing with such a custom data entry script, some of the existing Django management commands may come in very useful. You can see the full list by running &lt;tt class="docutils literal"&gt;manage.py help&lt;/tt&gt;, but here's a list of those I found handy in the context of this post.&lt;/p&gt;
&lt;p&gt;For dumping, &lt;tt class="docutils literal"&gt;dumpdata&lt;/tt&gt; is great. Once your data grows a bit, you may find it useful only to dump specific models, or even specific rows by specifying primary keys with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pks&lt;/span&gt;&lt;/tt&gt;. I also find the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--indent=2&lt;/span&gt;&lt;/tt&gt; option to be essential when doing the default JSON dumps.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;flush&lt;/tt&gt; command will clear the DB for you. A handy &amp;quot;undo&amp;quot; for those very first forays into entering data. Be careful with this command once you have real data in the DB.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;tt class="docutils literal"&gt;sqlall&lt;/tt&gt; command is very useful when you're trying to figure out the structure of your models and the connections between them. IMHO model problems are important to detect early in the development of an application.&lt;/p&gt;
&lt;p&gt;To conclude, I just want to mention that while custom management commands live within applications, nothing ties them to a specific app. It is customary for Django management commands to accept app and model names as arguments. While a data entry command is naturally tied to some application and model, this doesn't necessarily have to be the case in general. You can even envision an &amp;quot;app&amp;quot; named &lt;tt class="docutils literal"&gt;my_custom_commands&lt;/tt&gt; which you can add to projects and reuse its functionality between them.&lt;/p&gt;

    </summary><category term="Django"></category></entry><entry><title>Building gcc 4.8 from source on Ubunu 12.04</title><link href="http://eli.thegreenplace.net/2014/01/16/building-gcc-4-8-from-source-on-ubunu-12-04" rel="alternate"></link><updated>2014-01-16T06:08:15-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-01-16:2014/01/16/building-gcc-4-8-from-source-on-ubunu-12-04</id><summary type="html">
        &lt;p&gt;The default gcc (4.6.x) on Ubuntu 12.04 is quite old, especially given the quick advance in C++11 capabilities in gcc 4.7 and 4.8 (and, importantly, their respective &lt;tt class="docutils literal"&gt;libstdc++&lt;/tt&gt; libraries).&lt;/p&gt;
&lt;p&gt;The LLVM project has recently decided (and implemented, earlier this week) to set gcc 4.7 and Clang 3.1 as the minimal versions LLVM &amp;amp; Clang themselves would build with, in order to be able to use C++11 capabilities in the implementation. Therefore, if you want to build trunk LLVM &amp;amp; Clang on Ubuntu 12.04, you need a newer gcc (even if you use Clang to self-build, still &lt;tt class="docutils literal"&gt;libstdc++&lt;/tt&gt; version 4.7 or later is required).&lt;/p&gt;
&lt;p&gt;Luckily, building a new gcc and installing it locally (to not mess with the system installation) is fairly easy. Here's a short sequences of steps.&lt;/p&gt;
&lt;p&gt;First, create a place to hold the installation, like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/install/gcc-4.8.2&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Install some dependencies needed to build gcc:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ sudo apt-get install libmpfr-dev libgmp3-dev libmpc-dev flex bison
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, get a gcc 4.8 tarball and unpack it:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.2/gcc-4.8.2.tar.bz2
$ bunzip2  gcc-4.8.2.tar.bz2
$ tar xvf gcc-4.8.2.tar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Enter the untarred gcc directory:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ cd gcc-4.8.2/
$ mkdir build
$ cd build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, configure and build:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ ../configure --disable-checking --enable-languages=c,c++ \
  --enable-multiarch --enable-shared --enable-threads=posix \
  --program-suffix=4.8 --with-gmp=/usr/local/lib --with-mpc=/usr/lib \
  --with-mpfr=/usr/lib --without-included-gettext --with-system-zlib \
  --with-tune=generic \
  --prefix=$HOME/install/gcc-4.8.2
$ make -j8
$ make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This places an installation of gcc 4.8.2 in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/install/gcc-4.8.2&lt;/span&gt;&lt;/tt&gt;. For example, you should be able to see this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ cd $HOME/install/gcc-4.8.2
$ find . -name gcc4.8
./bin/gcc4.8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's it. You can try it:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ cd /tmp
$ cat &amp;gt; test.c
int main() { return 42; }
$ $HOME/install/gcc-4.8.2/bin/gcc4.8 test.c
$ ./a.out; echo $?
42
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can also run &lt;tt class="docutils literal"&gt;gcc4.8&lt;/tt&gt; with the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-###&lt;/span&gt;&lt;/tt&gt; flag to see the exact compilation steps and notice which libraries get picked up, etc. (note that to see &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-lstdc++&lt;/span&gt;&lt;/tt&gt; a C++ source compiled with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;g++4.8&lt;/span&gt;&lt;/tt&gt; is needed instead).&lt;/p&gt;
&lt;p&gt;As a bonus, trunk LLVM &amp;amp; Clang can be now build by passing this gcc to the &lt;tt class="docutils literal"&gt;configure&lt;/tt&gt; script (the exact same idea works with the CMake-based configuration flow too):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ CC=$HOME/install/gcc-4.8.2/bin/gcc4.8 \
  CXX=$HOME/install/gcc-4.8.2/bin/g++4.8 \
  ../../llvm-src/configure
&lt;/pre&gt;&lt;/div&gt;

    </summary><category term="Linux"></category><category term="Software &amp; Tools"></category></entry><entry><title>Some thoughts on LLVM vs. libjit</title><link href="http://eli.thegreenplace.net/2014/01/15/some-thoughts-on-llvm-vs-libjit" rel="alternate"></link><updated>2014-01-15T05:49:56-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-01-15:2014/01/15/some-thoughts-on-llvm-vs-libjit</id><summary type="html">
        &lt;p&gt;Having recently completed a &lt;a class="reference external" href="http://eli.thegreenplace.net/2014/01/07/getting-started-with-libjit-part-3/"&gt;series of articles&lt;/a&gt; on using libjit and understanding how it works, I couldn't stop comparing it to LLVM inside my head. This is hardly surprising, since LLVM has been a significant part of my professional life for the past 3.5 years, and will remain in this position in the foreseeable future.&lt;/p&gt;
&lt;p&gt;So this post is some unfiltered thoughts on libjit and LLVM - what's similar, what's different, and which one is more suitable for new projects.&lt;/p&gt;
&lt;p&gt;First, a tiny bit of background. LLVM hardly needs introduction for the readers of my blog, but just for completeness - it was &lt;a class="reference external" href="http://llvm.org/releases/"&gt;first released&lt;/a&gt; in late 2003. However, according to Chris Lattner's (one of the creators of LLVM and its main developer for many years) recent presentation, the first ideas for it came together in 2000 and the first prototype was hacked together in early 2001.&lt;/p&gt;
&lt;p&gt;Today, LLVM is one of the most significant infrastructural backbones of modern computing, no less. It's the default compiler for the OS X and iOS platforms (FreeBSD is deprecating gcc in favor of LLVM &amp;amp; Clang too), and is heavily used in production by almost all major software companies. New things pop up all the time, like the (Windows-based, mind you) toolchain of the new Sony PS4 being completely built on top of LLVM.&lt;/p&gt;
&lt;p&gt;libjit's first release was &lt;a class="reference external" href="http://www.dotgnu.org/"&gt;in April 2004&lt;/a&gt;, as part of the now-defunct DotGNU project. This was a much less complete release than LLVM 1.0, though (version 0.0.0f - doesn't sound very reassuring for running your nuclear reactor, does it?). Its goals, from the beginning, were quite similar to LLVM's, if somewhat more modest. It also aimed to provide the backend of a compiler from a target-independent IR.&lt;/p&gt;
&lt;p&gt;Some internet archaeology brought up &lt;a class="reference external" href="http://lists.gnu.org/archive/html/dotgnu-libjit/2004-05/msg00012.html"&gt;this fascinating mailing list thread&lt;/a&gt; from May 2004, in which Chris Lattner asks Rhys Weatherley (the creator of libjit) whether the two projects can &amp;quot;join forces&amp;quot;, since their goals are similar. If you have any interest in open-source, you can't miss this discussion - go read it now. After a few weak justification attempts, Chris and Rhys got to the real issue. In open-source, people often start new projects &lt;em&gt;just because it's fun&lt;/em&gt;, as well as &lt;em&gt;to retain complete control&lt;/em&gt;. There may be an existing project that does something similar. The effort to use this existing project is, in all likeness, smaller than the effort to roll your own. But what would you prefer - spending time adapting a large body of existing code you didn't write (and whose brace style you hate!) to your needs and quibbling over methodology on mailing lists, or gloriously hacking into the night - your fingers burning holes in the keyboard producing new code? Especially when this isn't a &amp;quot;day job&amp;quot;, but something you do for fun... Yeah, I thought so. Joel's &lt;a class="reference external" href="http://www.joelonsoftware.com/articles/fog0000000007.html"&gt;In Defense of the NIH syndrome&lt;/a&gt; is a classic now (it's 13 years old, oh my) but it rings as true, and possibly truer, for open-source as for the corporate setting Joel first aimed it at.&lt;/p&gt;
&lt;p&gt;But I digress... The short version of the paragraph above is that libjit and LLVM really do have similar goals, and if the mood of their overlords had been different on a few pleasant spring nights of 2004, we could've had just a single project today; that would, in all likeness, be LLVM. Could this also help the DotGNU project on the whole, which lost more and more steam over the years until its official abandonment in 2012? Who knows... If you have a time machine, let me know please.&lt;/p&gt;
&lt;p&gt;But lo and behold - libjit is still alive today. It seems to live in a state of life support because there's not too much active development going on, but it's definitely not dead. Its current maintainer is fairly responsive and seems keen to fix things, including documentation.&lt;/p&gt;
&lt;p&gt;As I mentioned, libjit's initial goals were much less ambitious than LLVM's, and it remained so. LLVM's philosophy of &amp;quot;everything is a pluggable library&amp;quot; kept driving its development, and if you look at LLVM today - everything is indeed quite pluggable, including newer parts like MC. LLVM supports pluggability in its very core. The so called mid-level IR infrastructure (arguably LLVM's best-designed part) is pluggability executed to perfection. You write generic passes that analyze and transform IR, and hook them together in any way you see fit (along with dozens of industrial-strength compilation passes already provided by LLVM). But the backend parts too: you can choose from more than one instruction selector (or write your own), multiple register allocators, schedulers, code emitters, assemblers, and so on.&lt;/p&gt;
&lt;p&gt;libjit is not like that. While it was designed to be able to emit code for multiple architectures (it has both flavors of x86, some experimental ARM support as well as old &amp;quot;attic&amp;quot; code for Alpha), its internals are not modular; sure, you can add more optimizations (or a different register allocator) to libjit, but you'll have to hack it into libjit itself - the requisite APIs and data structures are not really exposed on the library level, the way they are with LLVM.&lt;/p&gt;
&lt;p&gt;The libjit IR is also somewhat more limited, having been designed with a single front-end in mind (DotGNU). True, the designer aimed to make it fairly abstract, but some things are definitely missing compared to LLVM, which has been shape by years of use in multiple different front-ends. For example, the type system of libjit is far less flexible, supporting only a subset of integer and floating-point types (like &lt;tt class="docutils literal"&gt;int32&lt;/tt&gt;, not the arbitrary LLVM jungle of &lt;tt class="docutils literal"&gt;int73&lt;/tt&gt; if you want it).&lt;/p&gt;
&lt;p&gt;But generality comes at a cost: LLVM is both relatively slow and its code is relatively difficult to grok. It's not slow for a regular (AOT - Ahead of Time) compiler, but it &lt;em&gt;is&lt;/em&gt; slow for a JIT compiler, a common source of pain for some LLVM users.&lt;/p&gt;
&lt;p&gt;Now, a disclaimer: I did not benchmark libjit's compilation speed vs. LLVM; I was simply too lazy to generate equivalent and large-enough inputs for both. I'm also not saying that libjit is faster than LLVM, perhaps it isn't. After all, the amount of engineering power expended on LLVM has been orders of magnitude larger than for libjit, which may very well have led to much more optimized code. All I want to imply here is that libjit &lt;em&gt;could&lt;/em&gt; be faster than LLVM. Generality is almost always at odds with performance in software, a sad fact we all wish wasn't true but, oh, it is. Is this very important? Not for most uses of LLVM today, but since libjit's main goal is JIT, then perhaps. But without real measurements and profiling, I don't have anything intelligent to contribute here.&lt;/p&gt;
&lt;p&gt;libjit is also much simpler to understand. I've spent enough time with LLVM to appreciate its complexity, as well as see &lt;a class="reference external" href="http://stackoverflow.com/questions/tagged/llvm"&gt;how confused many programmers are about it&lt;/a&gt;. libjit was dramatically easier to grok for me. This may have two reasons: one is definitely its significantly smaller size and simpler internal structure. There is simply much less code to read, and much less abstraction levels to keep in the head. The other reason is my (sometimes controversial) opinion about the choice of programming language. libjit is written in C, which IMHO is easier to understand than C++. But that's a whole other issue, unrelated to this post (you know where to find me for your hatemail).&lt;/p&gt;
&lt;p&gt;There's another significant difference between LLVM and libjit. LLVM, despite the historical meaning of its acronym and the numerous attempts that have been made over the years to make it work for dynamic languages, is still in its core a backend for compiling static languages like C, C++ and Objective C. By this, I mean languages that don't really have a significant runtime, like Java or C#. libjit, on the other hand, was designed to serve as a backend for a .NET implementation. That said, like the rest of libjit, these parts are not really battle-proven, so it's hard to attest to their completeness and stability.&lt;/p&gt;
&lt;p&gt;So, which one should you use or learn? As for use, there's no question; LLVM is an industrial strength, heavily tested and verified system. It's being used daily on millions (maybe billions) of devices; it's being hacked on by hundreds of programmers from dozens of companies. If it fits your needs, LLVM is the way to go. And these days it fits most needs. Not all of them, mind you. For example, as I've already mentioned above, LLVM is not great for fast JIT-ing. And to be honest, I don't think it's possible to create a really fast JIT within the framework of LLVM, &lt;em&gt;because&lt;/em&gt; of its modularity. The faster the JIT, the more you'll have to deviate from the framework of LLVM. This is a serious problem for &lt;a class="reference external" href="http://blog.chromium.org/2013/11/portable-native-client-pinnacle-of.html"&gt;Portable Native Client&lt;/a&gt;, for instance.&lt;/p&gt;
&lt;p&gt;libjit, on the other hand, is much more limited, aimed at dynamic runtimes and can (potentially) JIT-compile faster. It's also not being used too much, and lacks credibility w.r.t. features and stability. libjit itself only comes with toy examples - not very reassuring if you want to bet your future project on it.&lt;/p&gt;
&lt;p&gt;In terms of educational value, libjit is great. If you want to learn about compiler backends, I would definitely start with libjit and only move to LLVM later. I hope my &lt;a class="reference external" href="http://eli.thegreenplace.net/2014/01/07/getting-started-with-libjit-part-3/"&gt;series of articles&lt;/a&gt; will be useful here.&lt;/p&gt;

    </summary><category term="Code generation"></category><category term="Compilation"></category></entry><entry><title>Website stats for 2013</title><link href="http://eli.thegreenplace.net/2014/01/11/website-stats-for-2013" rel="alternate"></link><updated>2014-01-11T05:54:56-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-01-11:2014/01/11/website-stats-for-2013</id><summary type="html">
        &lt;p&gt;Two years ago &lt;a class="reference external" href="http://eli.thegreenplace.net/2012/01/02/website-stats-for-2011/"&gt;I wrote a short summary&lt;/a&gt; of the visitor stats for this website during 2011. I skipped this in 2012, but here is a similar summary for 2013.&lt;/p&gt;
&lt;p&gt;TL;DR: 2013 was the busiest year ever with 77K unique visitors per month on overage (compared to 66K in 2012 and 56K in 2011).&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2014/01/stats20131.png" /&gt;
&lt;p&gt;Monthly averages: 178,900 visits a month by 77,800 unique visitors, who viewed 628,400 pages. Once again the USA accounted for a large chunk of the traffic, with Germany, China and France lagging behind.&lt;/p&gt;
&lt;p&gt;In addition to search engines (mostly Google), most visitors came through Reddit, StackOverflow, and pygame.org. The most popular search keyphrases were &amp;quot;python multiprocessing&amp;quot;, &amp;quot;python destructor&amp;quot;, and &amp;quot;book review of around the world in 80 days&amp;quot;, though these are fairly widely distributed (the highest occupies only 0.7% of the overall pie).&lt;/p&gt;
&lt;p&gt;The five most viewed pages this year (counting only direct hits, not through the main page) were:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://eli.thegreenplace.net/2013/12/03/intel-i7-loop-performance-anomaly/"&gt;Intel i7 loop performance anomaly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://eli.thegreenplace.net/2011/05/18/code-sample-socket-client-thread-in-python/"&gt;Code sample - socket client thread in Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/"&gt;How statically linked programs run on Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://eli.thegreenplace.net/2013/01/05/understanding-your-own-code/"&gt;Understanding your own code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://eli.thegreenplace.net/2012/01/16/python-parallelizing-cpu-bound-tasks-with-multiprocessing/"&gt;Python - parallelizing CPU-bound tasks with multiprocessing&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally, OS &amp;amp; browser distribution: 46% visitors were on Windows, with Linux lagging behind with 22%, followed by Mac with 18%. In browsers, Chrome is the big winner with 37%, followed by Firefox with 28%.&lt;/p&gt;
&lt;p&gt;Thanks once again to all the dedicated readers of my blog :-)&lt;/p&gt;

    </summary><category term="Blogging"></category></entry><entry><title>Getting started with libjit - part 3</title><link href="http://eli.thegreenplace.net/2014/01/07/getting-started-with-libjit-part-3" rel="alternate"></link><updated>2014-01-07T06:00:59-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2014-01-07:2014/01/07/getting-started-with-libjit-part-3</id><summary type="html">
        &lt;p&gt;This is part 3 in a series of articles on libjit. &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;Part 1&lt;/a&gt; served as a basic introduction to the library and showed how to get started, along with some simple performance measurements. &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/11/12/getting-started-with-libjit-part-2/"&gt;Part 2&lt;/a&gt; peered deeper into the capabilities of libjit, focusing on interface between native and JITed code. In this part, I'm switching gears and looking at the internals of libjit. I'll follow through the compilation of a simple function with libjit, highlighting some interesting aspects of libjit's design on the way.&lt;/p&gt;
&lt;div class="section" id="input-code"&gt;
&lt;h3&gt;Input code&lt;/h3&gt;
&lt;p&gt;I'll reuse the iterative GCD example from part 1. The equivalent C code is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;gcd_iter&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; u, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; v) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; t;
  &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; (v) {
    t = u;
    u = v;
    v = t % v;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; u &amp;lt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; ? -u : u; &lt;span style="color: #007f00"&gt;/* abs(u) */&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Take a look at &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;part 1&lt;/a&gt; (or the &lt;tt class="docutils literal"&gt;gcd_iter.c&lt;/tt&gt; sample in &lt;a class="reference external" href="https://github.com/eliben/libjit-samples"&gt;the repository&lt;/a&gt;) for details on the libjit calls required to emulate this function.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="libjit-ir"&gt;
&lt;h3&gt;libjit IR&lt;/h3&gt;
&lt;p&gt;The libjit API includes &lt;tt class="docutils literal"&gt;jit_dump_function&lt;/tt&gt;, which can dump the contents of a &lt;tt class="docutils literal"&gt;jit_function_t&lt;/tt&gt; for us. It has two modes of operation. Before the function is compiled to native code, the libjit IR will be dumped. If the function has already been compiled (with &lt;tt class="docutils literal"&gt;jit_function_compile&lt;/tt&gt;), the produced machine code is disassembled &lt;a class="footnote-reference" href="#id7" id="id2"&gt;[1]&lt;/a&gt; and the assembly is dumped. In this article we'll be looking at both dumps, starting with the &amp;quot;uncompiled&amp;quot; libjit IR.&lt;/p&gt;
&lt;p&gt;Before I show the IR dump, a short introduction to how libjit does things. Internally, the IR is divided into &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Basic_block"&gt;basic blocks&lt;/a&gt;, which is a convenient abstraction often used by compilers to represent intermediate code. Basic blocks may serve as targets of braches (&lt;tt class="docutils literal"&gt;goto&lt;/tt&gt; instructions in libjit IR); therefore, each may have one or more labels referring to it. The libjit API has functions that explicitly create basic blocks, but the functions I used do so implicitly. This is more convenient. For example, &lt;tt class="docutils literal"&gt;jit_insn_branch_if&lt;/tt&gt; both ends the current basic block (because it's an exit point) and may create an additional basic block at its destination (unless it already exists).&lt;/p&gt;
&lt;p&gt;Another thing to note is that while C code that uses the libjit API has named variables for values and labels, libjit is oblivious to it. Unlike LLVM, libjit does not have a way to give meaningful names to values and labels, so it just generates numbered names. However, even so the correspondence between libjit API calls and the IR is very obvious and easy to follow, as the following annotated dump shows. I'm using some of the nomenclature (such as label names) from the API calls in the comments to help pinpoint the correspondence between them.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt; gcd [uncompiled](i1 : &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;, i2 : &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;) : &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// Note that some ABI details are exposed here. This is built on&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// a x64 Linux machine, where the first two integer arguments to&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// a function are passed in rdi and rsi&lt;/span&gt;
      incoming_reg(i1, rdi)
      incoming_reg(i2, rsi)
      &lt;span style="color: #007f00"&gt;// label_while:&lt;/span&gt;
.L0:
      &lt;span style="color: #007f00"&gt;// if (v == 0) goto label_after_while&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// libjit folds a comparison instruction into a branch - hence it&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// seems that i7 is not necessary and can be optimized away as&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// dead code&lt;/span&gt;
      i7 = i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L1
.L:
      &lt;span style="color: #007f00"&gt;// t &amp;lt;- u&lt;/span&gt;
      i5 = i1
      &lt;span style="color: #007f00"&gt;// u &amp;lt;- v&lt;/span&gt;
      i1 = i2
      &lt;span style="color: #007f00"&gt;// v &amp;lt;- t % v via a temporary&lt;/span&gt;
      i8 = i5 % i2
      i2 = i8 i7 = i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L2

      &lt;span style="color: #007f00"&gt;// goto label_while&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L0
      &lt;span style="color: #007f00"&gt;// ends_in_dead is a marker libjit places on blocks that don&amp;#39;t&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// have a fall-through edge. These are blocks that end with&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// unconditional branches, returns, etc.&lt;/span&gt;
      ends_in_dead
.L1:
      i9 = i1 &amp;gt;= &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// if (u &amp;gt;= 0) then goto label_pos&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i1 &amp;gt;= &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L2
.L:
      &lt;span style="color: #007f00"&gt;// return -u&lt;/span&gt;
      i10 = -i1
      return_int(i10)
      ends_in_dead
.L2:
      &lt;span style="color: #007f00"&gt;// label_pos: return u&lt;/span&gt;
      return_int(i1)
      ends_in_dead
.L:
.L:
end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most important thing to remember about this IR dump is that it's very closely parallel to the libjit API calls used to create it. In this respect, libjit is very much like LLVM: the IR is directly created by the builder API. An important difference is that unlike LLVM, where a textual representation of the IR is a language that can be used for full serialization (and even directly programmed in), in the case of libjit no such representation exists. The above is just a dump for debugging purposes.&lt;/p&gt;
&lt;p&gt;I still think it's pretty useful for verifying that the code created by the API calls makes sense. While less important when the API calls are made manually, as they were here, it becomes crucial when the calls are generated programmatically - such as by a front-end that compiles some language to libjit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="from-libjit-ir-to-machine-code"&gt;
&lt;h3&gt;From libjit IR to machine code&lt;/h3&gt;
&lt;p&gt;Now it's time to examine the machine code produced by libjit for &lt;tt class="docutils literal"&gt;gcd_iter&lt;/tt&gt; on my x64 machine. The following is an annotated disassembly dump, which I'll then use as a springboard to dive into some of the internal workings of libjit.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;                  &lt;span style="color: #007f00"&gt;// Prologue&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058713f:     push   %rbp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587140:     mov    %rsp,%rbp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587143:     sub    $0x20,%rsp
                  &lt;span style="color: #007f00"&gt;// r14 and r15 are callee-saved; save them since&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// we&amp;#39;ll use them&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587147:     mov    %r14,(%rsp)
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058714b:     mov    %r15,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rsp)
                  &lt;span style="color: #007f00"&gt;// rdi holds u, rsi holds v. Put them in r15 and r14&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// respectively&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587150:     mov    %rdi,%r15
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587153:     mov    %rsi,%r14

                  &lt;span style="color: #007f00"&gt;// label_while:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (v == 0) goto after_while&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587156:     test   %r14d,%r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587159:     je     &lt;span style="color: #007f7f"&gt;0x7f94005871ab&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// t &amp;lt;- u&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058715f:     mov    %r15d,%eax
                  &lt;span style="color: #007f00"&gt;// u &amp;lt;- v&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587162:     mov    %r14d,%r15d
                  &lt;span style="color: #007f00"&gt;// save t on the stack&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587165:     mov    %eax,-&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rbp)
                  &lt;span style="color: #007f00"&gt;// if (v != 0) goto v_nonzero&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587168:     test   %r14d,%r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058716b:     jne    &lt;span style="color: #007f7f"&gt;0x7f9400587181&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise call&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// jit_exception_builtin(JIT_RESULT_DIVISION_BY_ZERO)&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058716d:     mov    $0xfffffffe,%edi
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587172:     mov    $0x8,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587177:     mov    $0x4060ea,%r11
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058717e:     callq  *%r11

                  &lt;span style="color: #007f00"&gt;// v_nonzero:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (v != -1) godo ready_for_rem&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587181:     cmp    $0xffffffff,%r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587185:     jne    &lt;span style="color: #007f7f"&gt;0x7f94005871a2&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (t != -2**32) goto ready_for_rem&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587187:     cmp    $0x80000000,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058718c:     jne    &lt;span style="color: #007f7f"&gt;0x7f94005871a2&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// .. otherwise call&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// jit_exception_builtin(JIT_RESULT_ARITHMETIC)&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// Because a minimum signed number is divided by -1;&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// the quotient is then an arithmetic overflow.&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// [-2^32 is representable in 2s complement 32-bit, but&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;//  not 2^32]&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058718e:     mov    $0xffffffff,%edi
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587193:     mov    $0x8,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f9400587198:     mov    $0x4060ea,%r11
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f940058719f:     callq  *%r11

                  &lt;span style="color: #007f00"&gt;// ready_for_rem:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// sign-extend t (eax) into (edx) for division and&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// perform signed division. Remainder is in rdx,&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// which is moved to r14, so v &amp;lt;- t % u&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// then goto label_while&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a2:     cltd
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a3:     idiv   %r14d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a6:     mov    %rdx,%r14
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871a9:     jmp    &lt;span style="color: #007f7f"&gt;0x7f9400587156&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// after_while:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// if (u &amp;gt;= 0) goto u_nonnegative&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ab:     test   %r15d,%r15d
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ae:     jge    &lt;span style="color: #007f7f"&gt;0x7f94005871be&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// ... otherwise place u into the return register&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// and negate it, then goto epilogue&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871b4:     mov    %r15d,%eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871b7:     neg    %eax
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871b9:     jmpq   &lt;span style="color: #007f7f"&gt;0x7f94005871c1&lt;/span&gt;

                  &lt;span style="color: #007f00"&gt;// u_nonnegative:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// Place u into the return register rax&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871be:     mov    %r15d,%eax

                  &lt;span style="color: #007f00"&gt;// epilogue:&lt;/span&gt;
                  &lt;span style="color: #007f00"&gt;// Restore saved regs &amp;amp; epilogue&lt;/span&gt;
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871c1:     mov    (%rsp),%r14
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871c5:     mov    &lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rsp),%r15
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ca:     mov    %rbp,%rsp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871cd:     pop    %rbp
&lt;span style="color: #007f7f"&gt;7&lt;/span&gt;f94005871ce:     retq
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While in general the control flow here is very similar to the IR version and hence easy to understand, there's a bunch of error checking going on before the remainder operation is performed, and this complicates matters. libjit turns out to be very meticulous about arithmetic errors and implants runtime checks against two situations that are undefined by the C standard.&lt;/p&gt;
&lt;p&gt;The easier one is division by zero. When &lt;tt class="docutils literal"&gt;v&lt;/tt&gt; is zero, the operation &lt;tt class="docutils literal"&gt;t % v&lt;/tt&gt; has undefined behavior. libjit inserts a runtime check comparing the divisor to zero and calling an exception function &lt;a class="footnote-reference" href="#id8" id="id3"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The more complex error case arises in division by -1. Since integers are represented in 2s complement, there is a single negative number (-2^32 for 32-bit &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;s) that does not have a positive mirror. If this negative number is divided by -1, the result is arithmetic overflow, which is also undefined behavior. Here again, libjit inserts the requisite runtime checks that ensure this case gets caught and properly reported &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="instruction-selection"&gt;
&lt;h3&gt;Instruction selection&lt;/h3&gt;
&lt;p&gt;The code generated for the remainder operation is a great opportunity to peer into the innards of libjit. What defines such complex behavior - generating a whole code sequence with multiple checks and calls, for a single operation? After all, on the libjit IR level, the remainder is just the &lt;tt class="docutils literal"&gt;%&lt;/tt&gt; operator.&lt;/p&gt;
&lt;p&gt;The following is a fast paced quest through the source code of libjit. Code references are typically made to function names and files relative to the root directory of a libjit source snapshot.&lt;/p&gt;
&lt;p&gt;We'll start by looking into &lt;tt class="docutils literal"&gt;jit_insn_rem&lt;/tt&gt;, which creates the remainder operation. Together with the other instruction creation APIs of libjit, this function lives in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-insn.c&lt;/span&gt;&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;jit_insn_rem&lt;/tt&gt; adds an &lt;em&gt;instruction description entry&lt;/em&gt; to the function - an instance of the &lt;tt class="docutils literal"&gt;jit_opcode_descr&lt;/tt&gt; structure.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;jit_value_t &lt;span style="color: #00007f"&gt;jit_insn_rem&lt;/span&gt;
              (jit_function_t func, jit_value_t value1, jit_value_t value2)
{
      &lt;span style="color: #00007f; font-weight: bold"&gt;static&lt;/span&gt; jit_opcode_descr &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; rem_descr = {
              JIT_OP_IREM,
              JIT_OP_IREM_UN,
              JIT_OP_LREM,
              JIT_OP_LREM_UN,
              JIT_OP_FREM,
              JIT_OP_DREM,
              JIT_OP_NFREM,
              jit_intrinsic(jit_int_rem, descr_e_pi_ii),
              jit_intrinsic(jit_uint_rem, descr_e_pI_II),
              jit_intrinsic(jit_long_rem, descr_e_pl_ll),
              jit_intrinsic(jit_ulong_rem, descr_e_pL_LL),
              jit_intrinsic(jit_float32_rem, descr_f_ff),
              jit_intrinsic(jit_float64_rem, descr_d_dd),
              jit_intrinsic(jit_nfloat_rem, descr_D_DD)
      };
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; apply_arith(func, &amp;amp;rem_descr, value1, value2, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most interesting part of this entry for us at this point is the opcode; &lt;tt class="docutils literal"&gt;JIT_OP_IREM&lt;/tt&gt; is the signed integer remainder opcode.&lt;/p&gt;
&lt;p&gt;There are many entries in the &lt;tt class="docutils literal"&gt;jit_opcode_descr&lt;/tt&gt; structure - per type of operands. Some of the entries are filled with intrinsics rather than opcodes, because libjit needs an intrinsic for architectures on which the opcode is not supported natively.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;jit_function_compile&lt;/tt&gt; initiates the IR -&amp;gt; native compilation sequence in libjit. You can trace it through in the libjit code - the code is quite easy to follow. Eventually &lt;tt class="docutils literal"&gt;compile_block&lt;/tt&gt;, which is responsible for generating code for a single basic block, calls &lt;tt class="docutils literal"&gt;_jit_gen_insn&lt;/tt&gt; per instruction. This is the point when libjit switches from a target-independent code generation algorithm to a target-specific backend, that knows how to lower libjit IR instructions to actual native instructions. This part has to be implemented per backend (target architecture). I'll follow through the flow of the x86-64 backend. The meat of &lt;tt class="docutils literal"&gt;_jit_gen_insn&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-rules-x86-64.c&lt;/span&gt;&lt;/tt&gt; is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;switch&lt;/span&gt;(insn-&amp;gt;opcode)
{
&lt;span style="color: #007f00"&gt;#define JIT_INCLUDE_RULES&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#include &amp;quot;jit-rules-x86-64.inc&amp;quot;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#undef JIT_INCLUDE_RULES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;.inc&lt;/tt&gt; file being included into the &lt;tt class="docutils literal"&gt;switch&lt;/tt&gt; statement is auto-generated in libjit from a corresponding &lt;tt class="docutils literal"&gt;.ins&lt;/tt&gt; file &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[4]&lt;/a&gt;. The &lt;tt class="docutils literal"&gt;.ins&lt;/tt&gt; file is an instruction selector, written in a libjit-specific DSL. It contains &amp;quot;rules&amp;quot; for generating code per IR opcode. Before we look at the complex remainder opcode, let's start with something simpler to get a feel for how the thing works:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;JIT_OP_PUSH_INT: note
      [imm] -&amp;gt; {
        x86_64_push_imm(inst, $1);
        gen-&amp;gt;stack_changed = 1;
      }
      [local] -&amp;gt; {
        x86_64_push_membase_size(inst, X86_64_RBP, $1, 4);
        gen-&amp;gt;stack_changed = 1;
      }
      [reg] -&amp;gt; {
        x86_64_push_reg_size(inst, $1, 4);
        gen-&amp;gt;stack_changed = 1;
      }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This rule tells the code generator how to handle the &lt;tt class="docutils literal"&gt;JIT_OP_PUSH_INT&lt;/tt&gt; (push an integer onto the stack) opcode for x86-64. Notice that there are separate rules based on whether the argument of the opcode is an immediate, a reference to a label or a register. For example, when it's a register, the rule says to call &lt;tt class="docutils literal"&gt;x86_64_push_reg_size&lt;/tt&gt;. This is a macro defined thus:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;#define x86_64_push_reg_size(inst, reg, size) \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;      do { \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              if((size) == 2) \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              { \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;                      *(inst)++ = (unsigned char)0x66; \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              } \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              x86_64_rex_emit64((inst), (size), 0, 0, (reg)); \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;              *(inst)++ = (unsigned char)0x50 + ((reg) &amp;amp; 0x7); \&lt;/span&gt;
&lt;span style="color: #007f00"&gt;      } while(0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, if you really want to verify this, it's time to look into the Intel Architecture Manual, volume 2 (the instruction set reference). Enjoy :-)&lt;/p&gt;
&lt;p&gt;Now, back to our remainder. &lt;tt class="docutils literal"&gt;JIT_OP_IREM&lt;/tt&gt; has the following entry:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;JIT_OP_IREM: more_space
      [any, immzero] -&amp;gt; {
        inst = throw_builtin(inst, func, JIT_RESULT_DIVISION_BY_ZERO);
      }
      [reg, imm, if(&amp;quot;$2 == 1&amp;quot;)] -&amp;gt; {
        x86_64_clear_reg(inst, $1);
      }
      [reg, imm, if(&amp;quot;$2 == -1&amp;quot;)] -&amp;gt; {
        /* Dividing by -1 gives an exception if the argument
           is minint, or simply gives a remainder of zero */
        jit_int min_int = jit_min_int;
        unsigned char *patch;
        x86_64_cmp_reg_imm_size(inst, $1, min_int, 4);
        patch = inst;
        x86_branch8(inst, X86_CC_NE, 0, 0);
        inst = throw_builtin(inst, func, JIT_RESULT_ARITHMETIC);
        x86_patch(patch, inst);
        x86_64_clear_reg(inst, $1);
      }
      [=reg(&amp;quot;rdx&amp;quot;), *reg(&amp;quot;rax&amp;quot;), imm, scratch dreg, scratch reg(&amp;quot;rdx&amp;quot;)] -&amp;gt; {
        x86_64_mov_reg_imm_size(inst, $4, $3, 4);
        x86_64_cdq(inst);
        x86_64_idiv_reg_size(inst, $4, 4);
      }
      [=reg(&amp;quot;rdx&amp;quot;), *reg(&amp;quot;rax&amp;quot;), dreg, scratch reg(&amp;quot;rdx&amp;quot;)] -&amp;gt; {
        jit_int min_int = jit_min_int;
        unsigned char *patch, *patch2;
#ifndef JIT_USE_SIGNALS
        x86_64_test_reg_reg_size(inst, $3, $3, 4);
        patch = inst;
        x86_branch8(inst, X86_CC_NE, 0, 0);
        inst = throw_builtin(inst, func, JIT_RESULT_DIVISION_BY_ZERO);
        x86_patch(patch, in have ast);
#endif
        x86_64_cmp_reg_imm_size(inst, $3, -1, 4); part 2
        patch = inst;
        x86_branch8(inst, X86_CC_NE, 0, 0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's kind-of long, but most of it describes some special cases when one of the operands is constant. For example, the second code block describes the case where the divisor is a constant 1. In this case, the remainder is always 0 so the target register is just cleared. The most interesting case is the most general one - the last, where division is done between two registers. In this case, you'll see that the rule is just a template for generate code - it's very similar to the machine code we've seen in the disassembly above. It checks for a zero divisor, and then for arithmetic error. Macros are used to actually generate the machine code, as demonstrated above with &lt;tt class="docutils literal"&gt;x86_64_push_reg_size&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="liveness-analysis-and-register-allocation"&gt;
&lt;h3&gt;Liveness analysis and register allocation&lt;/h3&gt;
&lt;p&gt;Another important mechanism in libjit I want to take a look at is liveness analysis (together with related target-independent optimizations) and register allocation. Since covering these topics in detail would require a book or two, I'll only skim through them on a high level, trusting the reader has some knowledge of compiler backends (or at least the will to dive deeper wherever necessary).&lt;/p&gt;
&lt;p&gt;libjit's rule-based code generation machinery already knows which registers values live in. A brief look at the machine code it generates immediately suggests that some sort of register allocation happened - there are almost no unnecessary stack spills. This happens in the &lt;tt class="docutils literal"&gt;codegen_prepare&lt;/tt&gt; function, which runs liveness analysis followed by register allocation.&lt;/p&gt;
&lt;p&gt;The liveness analysis done by libjit seems pretty standard. It places its results in the &lt;tt class="docutils literal"&gt;flags&lt;/tt&gt; field of each instruction. It also runs some simple optimizations - forward and backward copy propagations. For example, recall that in the IR we had:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;.L0:
      &lt;span style="color: #007f00"&gt;// if (v == 0) goto label_after_while&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// libjit folds a comparison instruction into a branch - hence it&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// seems that i7 is not necessary and can be optimized away as&lt;/span&gt;
      &lt;span style="color: #007f00"&gt;// dead code&lt;/span&gt;
    i7 = i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; i2 == &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; then &lt;span style="color: #00007f; font-weight: bold"&gt;goto&lt;/span&gt; .L1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now it's time to explain how the &amp;quot;optimized away as dead code&amp;quot; part happened. When liveness analysis gets to the &lt;tt class="docutils literal"&gt;i7 = i2 == 0&lt;/tt&gt; instruction, it notices that he destination value is not live - nothing uses it. The instruction is then replaced with a &lt;tt class="docutils literal"&gt;JIT_OP_NOP&lt;/tt&gt;, which is simply ignored during code generation.&lt;/p&gt;
&lt;p&gt;A more sophisticated analysis enables libjit to replace the second instruction in the pair &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[5]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;i8 = i5 % i2
i2 = i8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since &lt;tt class="docutils literal"&gt;i8&lt;/tt&gt; is not used anywhere else, backward copy propagation simply replaces the first assignment by &lt;tt class="docutils literal"&gt;i2 = i5 % i2&lt;/tt&gt; and the second becomes dead code, which is replaced with a &lt;tt class="docutils literal"&gt;JIT_OP_NOP&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Register allocation happens in two stages. First, a simplistic global register allocation is done right after liveness analysis. All the values in the function are ordered from most to least used, and registers are allocated to the most used values. While not as optimal as graph coloring, this is a relatively cheap and simple heuristic that ensures, in most cases, that the hottest values remain in registers across basic blocks and not too many spills are generated.&lt;/p&gt;
&lt;p&gt;The second stage happens as each instruction gets generated - this is local register allocation within a block. &lt;tt class="docutils literal"&gt;_jit_regs_assign&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-reg-alloc.c&lt;/span&gt;&lt;/tt&gt; is the function to look out for. Calls to it are automatically created in the &lt;tt class="docutils literal"&gt;.inc&lt;/tt&gt; file. This stage is tasked with the detailed allocation of registers to instructions that require registers, spilling of existing values from registers (if the required registers are occupied), and so on.&lt;/p&gt;
&lt;p&gt;On a high level, this code is a classical low-level register allocator with a lot of careful bookkeeping (such as ABI constraints and instructions that force special registers). It keeps track of the values contained in each register and uses liveness analysis to try to spill registers with the minimal cost, when spilling is required. It also uses the global register information computed during global allocation, so it's not completely blind to what's going on outside the basic block.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="optimization"&gt;
&lt;h3&gt;Optimization&lt;/h3&gt;
&lt;p&gt;Apart from the copy propagations and dead code elimination mentioned above, libjit doesn't come with a lot of optimizations built in. It has the scaffolding ready to set custom optimization levels on each function, but these don't do much today. Perhaps it was added for future needs or for custom backends that may do more optimization during instruction selection, etc.&lt;/p&gt;
&lt;p&gt;The only other target-independent optimization (which runs by default, unless you explicitly set the optimization level to 0) is an attempt to simplify the control-flow graph of functions. This happens in the &lt;tt class="docutils literal"&gt;optimize&lt;/tt&gt; function, which first builds the CFG with &lt;tt class="docutils literal"&gt;_jit_block_build_cfg&lt;/tt&gt; and then optimizes it with &lt;tt class="docutils literal"&gt;_jit_block_clean_cfg&lt;/tt&gt;. According to comments in the code, it's based on the &amp;quot;Clean&amp;quot; algorithm from &lt;a class="reference external" href="http://www.cs.princeton.edu/~ras/clean.ps"&gt;this paper&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;While the first two parts in this series concentrated on how to use libjit, this part focuses on how libjit works under the hood. It's an audacious goal to try to cover such an intricate piece of software in a single article, so my attempt should be considered at most a high-level overview with a bit of in-depth focus here and there. I hope people who find libjit interesting and wonder how it works will find it useful; it can also be useful just to students of compilers that look for additional real-world examples to study. Software projects rarely have their internals documented, and being presented with a large lump of code is daunting. Perhaps this article can soften the learning curve.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There's no magic here - libjit doesn't carry a disassembler of its own. It simply dumps the raw binary code into a temporary files and runs it through &lt;tt class="docutils literal"&gt;objdump&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;jit_exception_builtin&lt;/tt&gt; lives in host code, and the host-JIT interface was explained in detail in &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/11/12/getting-started-with-libjit-part-2/"&gt;part 2&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;By the way, this behavior is documented in the libjit API for &lt;tt class="docutils literal"&gt;jit_insn_div&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;jit_insn_rem&lt;/tt&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I'll leave the details of this auto-generated instruction selection out of this article, but it's pretty standard in compilers. LLVM has an elaborate auto-generation framework based on TableGen. libjit has a simpler home-cooked solution. It's pretty easy to find out how it works by tracing the flow in the Makefile and looking at the &lt;tt class="docutils literal"&gt;tools/&lt;/tt&gt; directory.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I found the &lt;tt class="docutils literal"&gt;_JIT_COMPILE_DEBUG&lt;/tt&gt; flag very useful when looking at this. Turn it on in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jit/jit-config.h&lt;/span&gt;&lt;/tt&gt;. Similarly, &lt;tt class="docutils literal"&gt;JIT_REG_DEBUG&lt;/tt&gt; helps observe the inner workings of the register allocator.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </summary><category term="Articles"></category><category term="Assembly"></category><category term="C &amp; C++"></category><category term="Code generation"></category></entry><entry><title>Summary of reading: October – December 2013</title><link href="http://eli.thegreenplace.net/2013/12/30/summary-of-reading-october-december-2013" rel="alternate"></link><updated>2013-12-30T06:00:26-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-12-30:2013/12/30/summary-of-reading-october-december-2013</id><summary type="html">
        &lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;Javascript, The definitive guide. 6th edition&amp;quot; by David Flanagan - while obviously I didn't read this 1000+ page tome cover to cover (a large part of it is a reference section), I spent enough time with it to write a review. It's a well-written, thorough book with a lot of useful code samples. What I like most about it, though, is its coverage of ECMAScript 5. Many existing JS books were not upgraded since ES5 has become the norm in modern browsers, which makes them less relevant today. With the vast amounts of horrible JS code out there, it's great to have a book that contains good code to learn idiomatic JS from. The book also covers a lot of ground on client-side JS programming: DOM manipulation, CSS manipulation, and so on. Overall, I think it's a good idea to have a copy by your side if one's writing non-trivial amounts of JS code on a daily basis.&lt;/li&gt;
&lt;li&gt;&amp;quot;Crypto&amp;quot; by Steven Levy - Technically this is a re-read; but the first time I read this book was before I began posting reviews to the blog, so I think a short review is due. This book is 12 years old now and thus very much dated, given that the subject it covers - modern cryptography in the age of the internet - has evolved a lot since then. However, most of the topics it describes are still very relevant and historically interesting. Specifically in 2013 with the whole Snowden business - reading &amp;quot;Crypto&amp;quot; clarifies how nothing has really changed. The public outrage now is charming, but whatever Snowden revealed has existed for decades and was known to the public to some extent. My major gripe with the book is that it shuns away from most technical details, focusing instead on politics and inter-personal struggles.&lt;/li&gt;
&lt;li&gt;&amp;quot;A brief history of mankind&amp;quot; by Yuval Noah Harari (read in Hebrew) - Just as the title suggests, this book is the author's attempt of an overview of human history (since the early pre-Homo Sapiens days), focusing on some historical, economical and political topics he finds most interesting. While the book is not bad overall and has some interesting opinions (specifically w.r.t. religion), I was somewhat disappointed by its being relatively shallow. The author is a researcher and lecturer, so I'd expect a deeper coverage. In reality, the book is more opinionated than factual - resembling a popular non-fiction book a journalist would write.&lt;/li&gt;
&lt;li&gt;&amp;quot;Innocents Abroad&amp;quot; by Mark Twain - A travel log summarizing the author's several months-long cruise to the Mediterranean and Middle East in 1867. Written in Mark Twain's typical humorous and (tiresomely) high-tale style, it covers a huge range of countries visited and a lot of cultural overviews. While generally interesting, IMHO the book digs too much into inconsequential details the author found appealing and thus is somewhat difficult to read for long stretches of time. It is however, very curious to read about this &amp;quot;snapshot&amp;quot; of Europe and the middle east (and especially for me, the Holy Land) taken more than 150 years ago and consider how much things have changed since then.&lt;/li&gt;
&lt;li&gt;&amp;quot;The annotated Turing&amp;quot; by Charles Petzold - a very unusual book. Petzold took one of the most celebrated papers in the history of computer science (Alan Turing's &amp;quot;On Computable Numbers, with an Application to the Entscheidungsproblem&amp;quot;) and dedicated a whole book to carefully dissecting it. Not an easy task, given that Turing's paper is extremely dense, presents multiple new ideas, uses very confusing terminology and contains a bunch of errors. Petzold presents untouched sections from the book, interspersed with explanations of varying length (from a few lines to whole chapters). Alas, I just couldn't bring myself to focus well enough while reading the book so I didn't dive deep into the explanations. I wish I had more time to read it more thoroughly - maybe in the future.&lt;/li&gt;
&lt;/ul&gt;

    </summary><category term="Book reviews"></category></entry><entry><title>Adding bash completion for your own tools - an example for pss</title><link href="http://eli.thegreenplace.net/2013/12/26/adding-bash-completion-for-your-own-tools-an-example-for-pss" rel="alternate"></link><updated>2013-12-26T15:49:18-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-12-26:2013/12/26/adding-bash-completion-for-your-own-tools-an-example-for-pss</id><summary type="html">
        &lt;p&gt;Modern Bash has a very useful programmatic tab-completion feature. This feature is one of the main reasons that the terminal is still the most convenient interface to interact with a computer, IMHO.&lt;/p&gt;
&lt;p&gt;&amp;quot;Programmatic&amp;quot; means that it's easy to add completion features for your own command-line tools. Yesterday I figured it will be a good exercise to add this for &lt;a class="reference external" href="https://github.com/eliben/pss"&gt;pss&lt;/a&gt; to complete the names of file types it can recognize; the list is growing longer with every release, and it would be nice to be able to quickly come up with the right type name without looking in the help all the time (is it &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--js&lt;/span&gt;&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--javascript&lt;/span&gt;&lt;/tt&gt;? etc).&lt;/p&gt;
&lt;p&gt;So, simple completion is now live in the master branch of pss on Github. It consists of two parts. The first is this bash script (in the &lt;tt class="docutils literal"&gt;tools/&lt;/tt&gt; directory):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;_pss_complete()
{
    local cur_word prev_word type_list

    # COMP_WORDS is an array of words in the current command line.
    # COMP_CWORD is the index of the current word (the one the cursor is
    # in). So COMP_WORDS[COMP_CWORD] is the current word; we also record
    # the previous word here, although this specific script doesn&amp;#39;t
    # use it yet.
    cur_word=&amp;quot;${COMP_WORDS[COMP_CWORD]}&amp;quot;
    prev_word=&amp;quot;${COMP_WORDS[COMP_CWORD-1]}&amp;quot;

    # Ask pss to generate a list of types it supports
    type_list=&amp;#96;pss --show-type-list&amp;#96;

    # Only perform completion if the current word starts with a dash (&amp;#39;-&amp;#39;),
    # meaning that the user is trying to complete an option.
    if [[ ${cur_word} == -* ]] ; then
        # COMPREPLY is the array of possible completions, generated with
        # the compgen builtin.
        COMPREPLY=( $(compgen -W &amp;quot;${type_list}&amp;quot; -- ${cur_word}) )
    else
        COMPREPLY=()
    fi
    return 0
}

# Register _pss_complete to provide completion for the following commands
complete -F _pss_complete pss pssc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's commented enough to be self-documenting, I hope. The most useful resource I found online that explains everything in detail is &lt;a class="reference external" href="http://www.debian-administration.org/article/317/An_introduction_to_bash_completion_part_2"&gt;this page from Debian&lt;/a&gt;. For a bunch of sample completion scripts in the Debian repository, see &lt;a class="reference external" href="http://bash-completion.alioth.debian.org"&gt;this page&lt;/a&gt;. And, of course there's &lt;tt class="docutils literal"&gt;man bash&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;You'll note that above I call &lt;tt class="docutils literal"&gt;pss &lt;span class="pre"&gt;--show-type-list&lt;/span&gt;&lt;/tt&gt; to produce a list of whitespace-separated words which is then used by Bash's &lt;tt class="docutils literal"&gt;compgen&lt;/tt&gt; command to generate completions. This is a new hidden option I added to pss just for this purpose. It's actually a common pattern in Bash completions: the tool itself knows best, so tools usually have special options the completion script can use to query things before it presents a list to the user.&lt;/p&gt;
&lt;p&gt;Lastly, this needs to be integrated into your system. All we really have to do is source this bash script somewhere so it's part of your shell. There's already a place for such completion scripts on Ubuntu systems, in &lt;tt class="docutils literal"&gt;/etc/bash_completion.d&lt;/tt&gt;; all files in that directory are sourced by the main bash completion script. I added a soft link to my script there, and things work great.&lt;/p&gt;

    </summary><category term="Linux"></category><category term="Software &amp; Tools"></category></entry><entry><title>Makefile functions and color output</title><link href="http://eli.thegreenplace.net/2013/12/18/makefile-functions-and-color-output" rel="alternate"></link><updated>2013-12-18T05:54:14-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-12-18:2013/12/18/makefile-functions-and-color-output</id><summary type="html">
        &lt;p&gt;When writing non-trivial makefiles, two needs occur occasionally. One is some way to collect common commands together without duplicating too much code. Another is adding color to some output, making it stand out (for example, this is done by makefiles generated by CMake).&lt;/p&gt;
&lt;p&gt;Here's a short makefile snippet that shows how to achieve this on modern Linux terminals:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;define colorecho&lt;/span&gt;
      @tput setaf 6
      @echo $1
      @tput sgr0
&lt;span style="color: #007f00"&gt;endef&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Defines a makefile &lt;em&gt;function&lt;/em&gt; named &lt;tt class="docutils literal"&gt;colorecho&lt;/tt&gt;, with a single argument which is exposed via &lt;tt class="docutils literal"&gt;$1&lt;/tt&gt;. This function sets the terminal color to cyan &lt;a class="reference external" href="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html"&gt;with tput&lt;/a&gt;, echoes its argument and resets the terminal settings to default.&lt;/p&gt;
&lt;p&gt;Here's how this function can be called:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;call colorecho,&lt;span style="color: #7f007f"&gt;&amp;quot;Linking with&amp;quot;&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LD&lt;span style="color: #00007f; font-weight: bold"&gt;))&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LD&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt; $^ -o $@
&lt;/pre&gt;&lt;/div&gt;

    </summary><category term="Linux"></category><category term="Software &amp; Tools"></category></entry><entry><title>The cost of dynamic (virtual calls) vs. static (CRTP) dispatch in C++</title><link href="http://eli.thegreenplace.net/2013/12/05/the-cost-of-dynamic-virtual-calls-vs-static-crtp-dispatch-in-c" rel="alternate"></link><updated>2013-12-05T06:13:30-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-12-05:2013/12/05/the-cost-of-dynamic-virtual-calls-vs-static-crtp-dispatch-in-c</id><summary type="html">
        &lt;p&gt;A couple of years ago I wrote &lt;a class="reference external" href="http://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/"&gt;an article about the Curiously Recurring Template Pattern in C++&lt;/a&gt;, focusing on the motivation behind it and how to implement it.&lt;/p&gt;
&lt;p&gt;That article mentioned runtime performance as the main reason for employing CRTP instead of the more traditional runtime polymorphism (dispatch via virtual functions). While some rationale for the cost of virtual calls was given, I didn't go too deep into it. Today I want to fix that by carefully analyzing the performance of virtual calls as opposed to the static calls made possible by CRTP.&lt;/p&gt;
&lt;div class="section" id="mandatory-precaution-about-benchmarks"&gt;
&lt;h3&gt;Mandatory precaution about benchmarks&lt;/h3&gt;
&lt;p&gt;Benchmarking in 2013 is really hard. Today's CPUs are super-pipelined, branch-predicting out-of-order executing beasts. The memory hierarchy is very deep and the caches have complex behavior. All of this makes detailed performance analysis devilishly complex, and the &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/12/03/intel-i7-loop-performance-anomaly/"&gt;results are sometimes baffling&lt;/a&gt;. We're clearly long past counting MIPS. Add to that overly-clever optimizing compilers that occasionally produce not quite the code you expected, and it's apparent why so many online resources and articles provide bad benchmarks.&lt;/p&gt;
&lt;p&gt;So any benchmarks need to be taken with a large grain of salt, including the one posted here. Personally, I'm trying to validate the benchmarks I'm running by attacking them with the scientific method:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;First, create a &lt;em&gt;hypothesis&lt;/em&gt; about the relative speed of two approaches.&lt;/li&gt;
&lt;li&gt;Take a detailed look at the code generated by the compiler to verify the hypothesis w.r.t. code generation - is this the machine code you expected to see?&lt;/li&gt;
&lt;li&gt;Run the benchmark and compare the runtime to the initial hypothesis, as well as to (2) - while not perfect, performance is easier to correlate to machine code than to original source code.&lt;/li&gt;
&lt;li&gt;If anything doesn't feel right, or just to make (3) more careful, use low-level counters to make sure that the amount of instructions executed and other such details makes sense given (2).&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="hypothesis-what-makes-virtual-calls-slower"&gt;
&lt;h3&gt;Hypothesis - what makes virtual calls slower&lt;/h3&gt;
&lt;p&gt;The &lt;a class="reference external" href="http://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/"&gt;previous article&lt;/a&gt; listed the following components in the runtime cost of virtual calls:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Extra indirection (pointer dereference) for each call to a virtual method.&lt;/li&gt;
&lt;li&gt;Virtual methods usually can’t be inlined, which may be a significant cost hit for some small methods.&lt;/li&gt;
&lt;li&gt;Additional pointer per object. On 64-bit systems which are prevalent these days, this is 8 bytes per object. For small objects that carry little data this may be a serious overhead.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While the third component can definitely play a role in some scenarios (i.e. a lot of small objects where the additional memory means less of them fit into L1 data cache), I'll focus on the first two in this article, because they are easier to expose in a simple synthetic benchmark.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-source-code-what-are-we-comparing"&gt;
&lt;h3&gt;The source code - what are we comparing?&lt;/h3&gt;
&lt;p&gt;There's a plethora of uses for polymorphism in C++. Here I'll focus on a basic one that will let me expose the performance characteristics of virtual calls. I'll define a simple interface with a couple of methods and one implementation of it:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;DynamicInterface&lt;/span&gt; {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; uint64_t getvalue() = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
};

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;DynamicImplementation&lt;/span&gt; : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; DynamicInterface {
  uint64_t counter;

&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  DynamicImplementation()
    : counter(&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) {
    counter += n;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;virtual&lt;/span&gt; uint64_t getvalue() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; counter;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The following code runs the actual benchmark:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; N = &lt;span style="color: #007f7f"&gt;40000&lt;/span&gt;;

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run_dynamic(DynamicInterface* obj) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; j = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; j &amp;lt; i; ++j) {
      obj-&amp;gt;tick(j);
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What this does is simply invoke the virtual method &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; on the base pointer &lt;tt class="docutils literal"&gt;obj&lt;/tt&gt; in the order of &lt;tt class="docutils literal"&gt;O(N^2)&lt;/tt&gt; times.&lt;/p&gt;
&lt;p&gt;The alternative statically-polymorphic implementation is this &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;template&lt;/span&gt; &amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;typename&lt;/span&gt; Implementation&amp;gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;CRTPInterface&lt;/span&gt; {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) {
    impl().tick(n);
  }

  uint64_t getvalue() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; impl().getvalue();
  }
&lt;span style="color: #00007f; font-weight: bold"&gt;private&lt;/span&gt;:
  Implementation&amp;amp; impl() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; *&lt;span style="color: #00007f; font-weight: bold"&gt;static_cast&lt;/span&gt;&amp;lt;Implementation*&amp;gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;);
  }
};

&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;CRTPImplementation&lt;/span&gt; : &lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt; CRTPInterface&amp;lt;CRTPImplementation&amp;gt; {
  uint64_t counter;
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  CRTPImplementation()
    : counter(&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;) {
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; tick(uint64_t n) {
    counter += n;
  }

  uint64_t getvalue() {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; counter;
  }
};

&lt;span style="color: #00007f; font-weight: bold"&gt;template&lt;/span&gt; &amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;typename&lt;/span&gt; Implementation&amp;gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; run_crtp(CRTPInterface&amp;lt;Implementation&amp;gt;* obj) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; j = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; j &amp;lt; i; ++j) {
      obj-&amp;gt;tick(j);
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="generated-code-how-virtual-calls-look-under-the-hood"&gt;
&lt;h3&gt;Generated code - how virtual calls look under the hood&lt;/h3&gt;
&lt;p&gt;Now let's spend some time studying the machine code generated by gcc -O2 (version 4.8) from the code above. The code for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;DynamicImplementation::tick&lt;/span&gt;&lt;/tt&gt; is very compact:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;0000000000400&lt;/span&gt;cf0 &amp;lt;_ZN21DynamicImplementation4tickEm&amp;gt;:
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;cf0:       add    %rsi,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rdi)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;cf4:       retq
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To understand what this means, some familiarity with the &lt;a class="reference external" href="http://mentorembedded.github.io/cxx-abi/abi.html"&gt;Itanium C++ ABI&lt;/a&gt; is required. The ABI in this case mandates both the name mangling that produces the weird symbol name, and the layout of the object in memory, which mandates how its fields are accessed. Here's a short description for the code above:&lt;/p&gt;
&lt;p&gt;Since &lt;tt class="docutils literal"&gt;DynamicInterface&lt;/tt&gt; has virtual methods, the class hierarchy it begets comes with a virtual method table, a pointer to which resides in each object. This is the way the compiler arranges for the runtime code to call the correct method when an actual object is used. The address of the virtual method table (&lt;tt class="docutils literal"&gt;vptr&lt;/tt&gt;) is in the beginning of the object, and the actual class members come afterwards. So &lt;tt class="docutils literal"&gt;counter&lt;/tt&gt; lives at offset 8 in &lt;tt class="docutils literal"&gt;DynamicImplementation&lt;/tt&gt; objects.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;add    %rsi,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rdi)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;%rdi&lt;/tt&gt; is the first argument to &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt;, which is the hidden &lt;tt class="docutils literal"&gt;this&lt;/tt&gt; pointer - the address of the object. Hence &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;0x8(%rdi)&lt;/span&gt;&lt;/tt&gt; is the address of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;this-&amp;gt;counter&lt;/span&gt;&lt;/tt&gt;. The instruction, then, adds &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; (passed in &lt;tt class="docutils literal"&gt;%rsi&lt;/tt&gt; according to the calling convention) to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;this-&amp;gt;counter&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;By the way, whenever you're curious about object layouts and want to verify your understanding of the ABI, I find &lt;a class="reference external" href="http://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/"&gt;Clang's ability to dump the class record layouts&lt;/a&gt; very helpful. In this case:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;*** Dumping AST Record Layout
   0 | class DynamicImplementation
   0 |   class DynamicInterface (primary base)
   0 |     (DynamicInterface vtable pointer)
   8 |   uint64_t counter
     | [sizeof=16, dsize=16, align=8
     |  nvsize=16, nvalign=8]

*** Dumping AST Record Layout
   0 | class CRTPImplementation
   0 |   class CRTPInterface&amp;lt;class CRTPImplementation&amp;gt; (base) (empty)
   0 |   uint64_t counter
     | [sizeof=8, dsize=8, align=8
     |  nvsize=8, nvalign=8]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On to the invocation of &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; now. This is the disassembly for &lt;tt class="docutils literal"&gt;run_dynamic&lt;/tt&gt;, annotated with comments:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;0000000000400&lt;/span&gt;c10 &amp;lt;_Z11run_dynamicP16DynamicInterface&amp;gt;:
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c10:       push   %r13
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c12:       mov    $0x1,%r13d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c18:       push   %r12
        &lt;span style="color: #007f00"&gt;// r12d holds i, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c1a:       xor    %r12d,%r12d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c1d:       push   %rbp
        &lt;span style="color: #007f00"&gt;// Place obj in %rbp&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c1e:       mov    %rdi,%rbp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c21:       push   %rbx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c22:       sub    $0x8,%rsp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c26:       nopw   %cs:&lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c30:       test   %r12d,%r12d
        &lt;span style="color: #007f00"&gt;// when i is 0, the body of the loop won&amp;#39;t run, so increment&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;// both i and j and try again.&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c33:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c5e
        &lt;span style="color: #007f00"&gt;// rbx holds j, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c35:       xor    %ebx,%ebx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c37:       nopw   &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
        &lt;span style="color: #007f00"&gt;// Place the address of obj&amp;#39;s vtable in rax&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40:       mov    &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rbp),%rax
        &lt;span style="color: #007f00"&gt;// j is the second argument of tick&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c44:       mov    %rbx,%rsi
        &lt;span style="color: #007f00"&gt;// j++&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c47:       add    $0x1,%rbx
        &lt;span style="color: #007f00"&gt;// obj is the first argument of tick (&amp;#39;this&amp;#39; pointer)&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4b:       mov    %rbp,%rdi
        &lt;span style="color: #007f00"&gt;// tick is the first entry in the vtable.&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;// This calls obj-&amp;gt;tick(obj, j)&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4e:       callq  *(%rax)
        &lt;span style="color: #007f00"&gt;// Compare j &amp;lt; i and perform inner loop&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c50:       cmp    %ebx,%r12d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c53:       ja     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40
        &lt;span style="color: #007f00"&gt;// Compare i == 40000 and perform outer loop&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c55:       cmp    $0x9c40,%r13d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c5c:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c68
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c5e:       add    $0x1,%r13d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c62:       add    $0x1,%r12d
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c66:       jmp    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c30
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c68:       add    $0x8,%rsp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c6c:       pop    %rbx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c6d:       pop    %rbp
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c6e:       pop    %r12
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c70:       pop    %r13
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c72:       retq
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c73:       data32 data32 data32 nopw %cs:&lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The interesting parts here are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;How &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;obj-&amp;gt;tick&lt;/span&gt;&lt;/tt&gt; is actually invoked. Since &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; is the first method in &lt;tt class="docutils literal"&gt;DynamicInterface&lt;/tt&gt;, it sits in the first slot in the vtable. So to actually call it, we have a double indirection from &lt;tt class="docutils literal"&gt;obj&lt;/tt&gt; - one to get to the vtable, the other to get to the method in the vtable.&lt;/li&gt;
&lt;li&gt;The constituents of the inner loop - the part that the program spends the vast majority of its time executing. We'll get back to it for a more careful analysis later.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="how-crtp-calls-look-under-the-hood"&gt;
&lt;h3&gt;How CRTP calls look under the hood&lt;/h3&gt;
&lt;p&gt;Now it's time to disassemble the equivalent code that uses CRTP for static polymorphism. Again, we'll want to start with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPImplementation::tick&lt;/span&gt;&lt;/tt&gt;, but we won't find it in the disassembly because it was fully inlined into &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;. The compiler was able to inline it because it could know statically (at compile time) which method is called. Such inlining is an important tenet of the &amp;quot;zero-cost abstractions&amp;quot; philosophy of modern C++.&lt;/p&gt;
&lt;p&gt;Let's go straight to &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;, then:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;0000000000400&lt;/span&gt;d00 &amp;lt;_Z8run_crtpI18CRTPImplementationEvP13CRTPInterfaceIT_E&amp;gt;:
        &lt;span style="color: #007f00"&gt;// Place obj-&amp;gt;counter into rdx&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d00:       mov    (%rdi),%rdx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d03:       mov    $0x1,%esi
        &lt;span style="color: #007f00"&gt;// rcx holds i, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d08:       xor    %ecx,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d0a:       nopw   &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d10:       test   %ecx,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d12:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d36
        &lt;span style="color: #007f00"&gt;// rax holds j, initialized to 0&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d14:       xor    %eax,%eax
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d16:       nopw   %cs:&lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rax,%rax,&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
        &lt;span style="color: #007f00"&gt;// counter += j&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d20:       add    %rax,%rdx
        &lt;span style="color: #007f00"&gt;// j++ and perform inner loop&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d23:       add    $0x1,%rax
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d27:       cmp    %eax,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d29:       ja     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d20
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d2b:       cmp    $0x9c40,%esi
        &lt;span style="color: #007f00"&gt;// when we&amp;#39;re done, put the final value back into obj-&amp;gt;counter&lt;/span&gt;
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d31:       mov    %rdx,(%rdi)
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d34:       je     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d3e
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d36:       add    $0x1,%esi
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d39:       add    $0x1,%ecx
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d3c:       jmp    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d10
  &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;d3e:       repz retq
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's not hard to see we'd expect this code to run much faster, for two main reasons:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Since the &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt; dispatch was inlined, the compiler was free to see that all it does is a simple member increment. The member is then saved in &lt;tt class="docutils literal"&gt;rdx&lt;/tt&gt; and the loop can then simply bump a register, instead of having a &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; on each iteration.&lt;/li&gt;
&lt;li&gt;As there's no call involved, the inner loop is shorter.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="performance-numbers"&gt;
&lt;h3&gt;Performance numbers&lt;/h3&gt;
&lt;p&gt;As expected, the CRTP approach is much faster. The benchmark above takes 1.25 seconds on my i7-4771 CPU for &lt;tt class="docutils literal"&gt;run_dynamic&lt;/tt&gt; and 0.21 seconds for &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt; This is a huge difference, and it's much larger than I expected. I was looking for a 2x boost, not 6x &lt;a class="footnote-reference" href="#id5" id="id2"&gt;[2]&lt;/a&gt;. So here comes the 4th bullet of the benchmarking methodology I outlined above. Let's look more carefully at the numbers.&lt;/p&gt;
&lt;p&gt;I'll start with producing a trace of the inner loop for both cases, to see the sequence of instructions executed. Since the loop is short, this can be easily done with basic disassembly reading, and also verifying with &lt;tt class="docutils literal"&gt;gdb&lt;/tt&gt; by stepping through the execution for a few iterations.&lt;/p&gt;
&lt;p&gt;Here is the inner loop for &lt;tt class="docutils literal"&gt;run_dynamic&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40:     mov    &lt;span style="color: #007f7f"&gt;0x0&lt;/span&gt;(%rbp),%rax
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c44:     mov    %rbx,%rsi
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c47:     add    $0x1,%rbx
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4b:     mov    %rbp,%rdi
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c4e:     callq  *(%rax) ... calls tick
    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;ce0: add    %rsi,&lt;span style="color: #007f7f"&gt;0x8&lt;/span&gt;(%rdi)
    &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;ce4: retq
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c50:     cmp    %ebx,%r12d
&lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c53:     ja     &lt;span style="color: #007f7f"&gt;400&lt;/span&gt;c40
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How many times we'd expect it to run? The double loop has a simple summing pattern so we can compute it's in the vicinity of &lt;tt class="docutils literal"&gt;N/2 * N&lt;/tt&gt;, which in our case means 800e6 (800 million times).&lt;/p&gt;
&lt;p&gt;Since the loop above is 9 instructions long, it means 7.2e9 instructions total. Let's look at detailed &lt;tt class="docutils literal"&gt;perf stat&lt;/tt&gt; numbers for this run:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Performance counter stats for &amp;#39;build/vcall-benchmark d&amp;#39;:

      1253.807247 task-clock                #    0.999 CPUs utilized
              107 context-switches          #    0.085 K/sec
                0 cpu-migrations            #    0.000 K/sec
              318 page-faults               #    0.254 K/sec
    4,807,848,980 cycles                    #    3.835 GHz
  &amp;lt;not supported&amp;gt; stalled-cycles-frontend
  &amp;lt;not supported&amp;gt; stalled-cycles-backend
    7,203,771,146 instructions              #    1.50  insns per cycle
    2,400,716,784 branches                  # 1914.742 M/sec
           58,358 branch-misses             #    0.00% of all branches

      1.255560284 seconds time elapsed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Indeed, the amount of instructions fits our expectation.&lt;/p&gt;
&lt;p&gt;Now, let's turn to &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;. Its inner loop is this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;400d20:     add    %rax,%rdx
400d23:     add    $0x1,%rax
400d27:     cmp    %eax,%ecx
400d29:     ja     400d20
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So only 4 instructions. In other words, we'd expect the total amount of instructions executed to be in the area of 3.2e9. Let's see:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Performance counter stats for &amp;#39;build/vcall-benchmark c&amp;#39;:

       215.919352 task-clock                #    0.997 CPUs utilized
               18 context-switches          #    0.083 K/sec
                0 cpu-migrations            #    0.000 K/sec
              318 page-faults               #    0.001 M/sec
      809,355,502 cycles                    #    3.748 GHz
  &amp;lt;not supported&amp;gt; stalled-cycles-frontend
  &amp;lt;not supported&amp;gt; stalled-cycles-backend
    3,202,645,106 instructions              #    3.96  insns per cycle
      800,522,521 branches                  # 3707.507 M/sec
           53,684 branch-misses             #    0.01% of all branches

      0.216596060 seconds time elapsed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bingo!&lt;/p&gt;
&lt;p&gt;But wait, a 2.25x difference in the amount of instructions should not have translated to a 6x difference in runtime, right? Note the amount of branches, though. While the CRTP run has one branch per inner loop, the numbers for the dynamic run show 3 branches per inner loop (for a total of 2.4e9). What gives?&lt;/p&gt;
&lt;p&gt;The CPU considers indirect calls and returns as branches for this purpose, and if you think about it, this makes sense. An indirect branch or return transfer control to a location the CPU cannot determine statically (unlike a direct call, for instance) - it depends on the contents of registers &amp;amp; stack. So the CPU doesn't know where to fetch instructions ahead-of-time in order to satisfy its eternally hungry super-pipeline. True, the branch predictor alleviates most of that cost, but such instructions are still more expensive for the CPU than, say, simple adds, because they cannot pump through the pipeline as quickly.&lt;/p&gt;
&lt;p&gt;Moreover, the &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;ret&lt;/tt&gt; instructions push and pop data to the stack, which resides in memory. It's almost certainly in L1 cache, but that's still more expensive to access than registers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="variation-o3-compilation"&gt;
&lt;h3&gt;Variation: -O3 compilation&lt;/h3&gt;
&lt;p&gt;Vigilant readers might have noticed that I did not set the highest optimization level of gcc for this benchmark. This was done on purpose, to make the results simpler to explain.&lt;/p&gt;
&lt;p&gt;When compiled with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt;, the dynamic version runs as before (and the code produced for it is the same), but the CRTP version runs even faster and finishes within 0.17 seconds, which is 7.2x faster than the dynamic version.&lt;/p&gt;
&lt;p&gt;The extra boost comes from auto-vectorization. When one looks at the code produced by the compiler for &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;, one can see SIMD instructions in there. The inner loop was unrolled 4x and the operations are performed on whole quad-words, combining several inner loop iterations at a time.&lt;/p&gt;
&lt;p&gt;So this is an example where previous optimizations (inlining) enabled the compiler to apply even more advanced optimizations such as vectorization to make the code faster yet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="variation-disabling-inlining"&gt;
&lt;h3&gt;Variation: disabling inlining&lt;/h3&gt;
&lt;p&gt;It's also interesting to build the benchmark with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fno-inline&lt;/span&gt;&lt;/tt&gt; and compare the results. Curiously, in this case the CRTP approach runs 1.5x &lt;em&gt;slower&lt;/em&gt; than virtual calls. Before you read on, can you guess why?&lt;/p&gt;
&lt;p&gt;The reason is quite simple. Note that for proper CRTP, the interface class implements the interface methods and calls through to the implementation. So to actually invoke &lt;tt class="docutils literal"&gt;tick&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt; calls:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPInterface&amp;lt;CRTPImplementation&amp;gt;::tick&lt;/span&gt;&lt;/tt&gt;, which calls&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPInterface&amp;lt;CRTPImplementation&amp;gt;::impl&lt;/span&gt;&lt;/tt&gt;, and then calls&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;CRTPImplementation::tick&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is a lot of calls, which all have to be executed when the inliner is turned off. When it's turned on, &lt;em&gt;all&lt;/em&gt; of these calls get inlined and the actual instructions of the leaf call are embedded into &lt;tt class="docutils literal"&gt;run_crtp&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;There are two lessons here:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Be careful with benchmarking, but you already knew that ;-)&lt;/li&gt;
&lt;li&gt;When implementing inlining in a compiler, it's super important to make the inliner iterative - doing multiple passes on the code and discovering new inlining opportunities in each iteration.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="devirtualization"&gt;
&lt;h3&gt;Devirtualization&lt;/h3&gt;
&lt;p&gt;A brand new optimization that I recently heard about is &lt;em&gt;devirtualization&lt;/em&gt;. The idea is to find cases of dynamic dispatch where the actual type at a given call site can always to proven to be known at compile time, and specialize those call sites to dispatch statically. This carries the promise of making virtual calls as fast as static dispatch in some special cases.&lt;/p&gt;
&lt;p&gt;While this definitely sound interesting, at the time of writing this article devirtualization is still experimental (support in gcc started trickling in version 4.7). In any case, the example examined in this article is probably simple enough to trigger the optimization, but as you can see it didn't happen, even though the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fdevirtualize&lt;/span&gt;&lt;/tt&gt; flag should be on in gcc with optimization levels &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O2&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt;. It will be interesting to follow the development of this optimization and see what cases of virtual calls it can detect and optimize in the future.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusions"&gt;
&lt;h3&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;There are a lot of lessons to be learned here, so I'll just list them in an arbitrary order:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Benchmarking is an art - if everything is too easy, you're either doing something trivial or wrong. Always cross-verify your assumptions and results with hard data like disassembly listings and detailed performance numbers.&lt;/li&gt;
&lt;li&gt;Beware of different compilers and different targets. The above discusses gcc 4.8 for x86-64. Elsewhere, you may expect slightly or considerably different results. Ah, if only programming was easy. But then I guess programmers wouldn't get paid a lot for clicking in front of computers all day.&lt;/li&gt;
&lt;li&gt;Compiler optimizations are, by definition, a multi-layered affair. Each is simple but they enable each other. Inlining enables some additional optimizations (such as moving hot code out of inner loops). Other optimizations may enable inlining (by making the leaf methods smaller).&lt;/li&gt;
&lt;li&gt;CRTP, when implemented correctly, is recognized by the compiler as static dispatch and optimized accordingly.&lt;/li&gt;
&lt;li&gt;CRTP can thus be significantly more efficient than virtual calls, mostly due to inlining. This also means that inlining is &lt;em&gt;crucial&lt;/em&gt; to its performance (as it is to many performance features of C++).&lt;/li&gt;
&lt;/ul&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is a degenerate use of CRTP, for sure. It's not here to be realistic - just to demonstrate the same mechanism used in a simple scenario. See the &lt;a class="reference external" href="http://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/"&gt;previous article&lt;/a&gt; for a more use-focused discussion of CRTP.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;These numbers depend on the CPU, of course. When I tried the same benchmark on a Xeon E5-2690 (Sandy Bridge) with gcc 4.6.3 (same code generated) the speed difference is just 3x (0.46 vs 1.39 sec).&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </summary><category term="Articles"></category><category term="Assembly"></category><category term="C &amp; C++"></category></entry><entry><title>Intel i7 loop performance anomaly</title><link href="http://eli.thegreenplace.net/2013/12/03/intel-i7-loop-performance-anomaly" rel="alternate"></link><updated>2013-12-03T07:18:48-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-12-03:2013/12/03/intel-i7-loop-performance-anomaly</id><summary type="html">
        &lt;p&gt;Recently I've been doing some benchmarking and came upon a very surprising behavior from a number of different Intel i7 CPUs (it manifests on Sandy Bridge and Haswell desktop-class CPUs as well as Sandy Bridge-EP Xeon CPUs).&lt;/p&gt;
&lt;p&gt;The benchmark is very simple and the result is... bizarre. Perhaps one of the readers of my blog knows what's going on here. Here's the C code for the benchmark (full code with a makefile is available in &lt;a class="reference external" href="https://gist.github.com/eliben/7770377"&gt;this Gist&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; N = &lt;span style="color: #007f7f"&gt;400&lt;/span&gt; * &lt;span style="color: #007f7f"&gt;1000&lt;/span&gt; * &lt;span style="color: #007f7f"&gt;1000&lt;/span&gt;;

&lt;span style="color: #00007f; font-weight: bold"&gt;volatile&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;long&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;long&lt;/span&gt; counter = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;

&lt;span style="color: #007f00"&gt;// Don&amp;#39;t inline the benchmarking code into main&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; __attribute__((noinline)) tightloop();
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; __attribute__((noinline)) loop_with_extra_call();

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;tightloop&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; j;
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (j = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; j &amp;lt; N; ++j) {
    counter += j;
  }
}

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;() {
}

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;loop_with_extra_call&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; j;
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (j = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; j &amp;lt; N; ++j) {
    __asm__(&lt;span style="color: #7f007f"&gt;&amp;quot;call foo&amp;quot;&lt;/span&gt;);
    counter += j;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We're benchmarking &lt;tt class="docutils literal"&gt;tightloop&lt;/tt&gt; vs. &lt;tt class="docutils literal"&gt;loop_with_extra_call&lt;/tt&gt;, which does exactly the same thing (increment a &lt;tt class="docutils literal"&gt;volatile&lt;/tt&gt; counter) but has a dummy call to a do-nothing function in the middle. I don't think anyone has doubts about how this should behave, right? How much slower do you think the extra call will make this loop? Twice as slow? 10% slower?&lt;/p&gt;
&lt;p&gt;Here's the driving &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; function:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;main&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; argc, &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt;** argv) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (argc &amp;lt;= &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (argv[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;][&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] == &lt;span style="color: #7f007f"&gt;&amp;#39;t&amp;#39;&lt;/span&gt;) {
    tightloop();
  } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (argv[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;][&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;] == &lt;span style="color: #7f007f"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;) {
    loop_with_extra_call();
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Building the code with gcc version 4.8 (same output code is produced by 4.6, as well as when replacing &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O2&lt;/span&gt;&lt;/tt&gt; by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt;):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc -O2 loop-call-weirdness.c -o build/loop-call-weirdness
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now I'll run it on my Intel i7-4771 (Haswell) CPU. First run the version with &lt;tt class="docutils literal"&gt;tightloop&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ perf stat -r 10 -e cycles,instructions  build/loop-call-weirdness t

 Performance counter stats for &amp;#39;build/loop-call-weirdness t&amp;#39; (10 runs):

     2,659,506,002 cycles       #    0.000 GHz              ( +-  0.19% )
     2,401,144,539 instructions #    0.90  insns per cycle  ( +-  0.00% )

       0.685642994 seconds time elapsed                     ( +-  0.24% )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;... and with the extra call:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ perf stat -r 10 -e cycles,instructions  build/loop-call-weirdness c

 Performance counter stats for &amp;#39;build/loop-call-weirdness c&amp;#39; (10 runs):

     2,336,765,798 cycles       #    0.000 GHz              ( +-  0.34% )
     3,201,055,823 instructions #    1.37  insns per cycle  ( +-  0.00% )

       0.602387097 seconds time elapsed                     ( +-  0.39% )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yes, the extra call makes the code &lt;strong&gt;faster&lt;/strong&gt;! You didn't expect that, did you.&lt;/p&gt;
&lt;p&gt;Looking at the disassembly, the compiler is doing fine here, producing quite expected code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;0000000000400530 &amp;lt;tightloop&amp;gt;:
  400530:     xor    %eax,%eax
  400532:     nopw   0x0(%rax,%rax,1)
  400538:     mov    0x200b01(%rip),%rdx        # 601040 &amp;lt;counter&amp;gt;
  40053f:     add    %rax,%rdx
  400542:     add    $0x1,%rax
  400546:     cmp    $0x17d78400,%rax
  40054c:     mov    %rdx,0x200aed(%rip)        # 601040 &amp;lt;counter&amp;gt;
  400553:     jne    400538 &amp;lt;tightloop+0x8&amp;gt;
  400555:     repz retq
  400557:     nopw   0x0(%rax,%rax,1)

0000000000400560 &amp;lt;foo&amp;gt;:
  400560:     repz retq

0000000000400570 &amp;lt;loop_with_extra_call&amp;gt;:
  400570:     xor    %eax,%eax
  400572:     nopw   0x0(%rax,%rax,1)
  400578:     callq  400560 &amp;lt;foo&amp;gt;
  40057d:     mov    0x200abc(%rip),%rdx        # 601040 &amp;lt;counter&amp;gt;
  400584:     add    %rax,%rdx
  400587:     add    $0x1,%rax
  40058b:     cmp    $0x17d78400,%rax
  400591:     mov    %rdx,0x200aa8(%rip)        # 601040 &amp;lt;counter&amp;gt;
  400598:     jne    400578 &amp;lt;loop_with_extra_call+0x8&amp;gt;
  40059a:     repz retq
  40059c:     nopl   0x0(%rax)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the &lt;tt class="docutils literal"&gt;volatile&lt;/tt&gt; is key here, since it forces the compiler to produce a load and store from the global on each iteration. Without &lt;tt class="docutils literal"&gt;volatile&lt;/tt&gt;, the benchmark behaves normally (the extra call makes it significantly slower).&lt;/p&gt;
&lt;p&gt;It's easy to see that &lt;tt class="docutils literal"&gt;tightloop&lt;/tt&gt; runs 6 instructions per iteration, which computes with the numbers reported by &lt;tt class="docutils literal"&gt;perf&lt;/tt&gt; (400 million iterations, times 6 instructions, is 2.4 billion instructions). &lt;tt class="docutils literal"&gt;loop_with_extra_call&lt;/tt&gt; adds two more instructions per iteration (the &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; and the &lt;tt class="docutils literal"&gt;ret&lt;/tt&gt; from it), and that also corresponds to the performance numbers.&lt;/p&gt;
&lt;p&gt;That's right, even though the version with the extra call executes 33% more instructions, it manages to do it quicker.&lt;/p&gt;
&lt;p&gt;Unfortunately, my fast Haswell CPU (or the Linux kernel coming with Ubuntu 13.10) doesn't support the whole range of &lt;tt class="docutils literal"&gt;perf stat&lt;/tt&gt; counters, but running on an older CPU (where the anomaly also exists though the performance difference in smaller), I see that the &lt;tt class="docutils literal"&gt;tightloop&lt;/tt&gt; benchmark has a lot of frontend and backend stalls (mostly frontend), for a total of 0.92 stalled cycles per instruction. The version with the extra call has just 0.25 stalled cycles per instruction.&lt;/p&gt;
&lt;p&gt;So would it be right to assume that the tight loop stalls on loading from &lt;tt class="docutils literal"&gt;counter&lt;/tt&gt; because the rest of the instructions in the loop depend on its value? So how does the &lt;tt class="docutils literal"&gt;call&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;ret&lt;/tt&gt; help here? By providing non-data-dependent instructions that can be run in parallel while the others are stalled? Still, whatever that is, I find this result astonishing.&lt;/p&gt;
&lt;p&gt;Let me know if you have any insights.&lt;/p&gt;

    </summary><category term="Assembly"></category><category term="C &amp; C++"></category><category term="Hardware &amp; Gadgets"></category><category term="Linux"></category></entry><entry><title>A new Ubuntu machine for home</title><link href="http://eli.thegreenplace.net/2013/11/23/a-new-ubuntu-machine-for-home" rel="alternate"></link><updated>2013-11-23T14:29:13-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-11-23:2013/11/23/a-new-ubuntu-machine-for-home</id><summary type="html">
        &lt;p&gt;This week I got a new machine for my home workstation. My previous machine was a 3.5-year old Asus laptop running Ubuntu 12.04; while the laptop is relatively powerful (Sandy Bridge i7 2820QM CPU), there were a couple of problems that prompted me to upgrade:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;I really wanted to use a high-resolution (WQHD - 2560x1440) screen at home, and the laptop's graphics card (integrated Intel Sandy Bridge graphics) isn't up to the task (its maximal resolution support is 2048x1152).&lt;/li&gt;
&lt;li&gt;It was starting to become sluggish for large tasks mainly due to having just 4 GB of memory. For example, I couldn't really run a full LLVM &amp;amp; Clang build with parallelism because linking would take the whole physical memory and the machine would start thrashing. Building LLVM &amp;amp; Clang in a single thread is unbearably slow (above an hour), and splitting the compilation &amp;amp; linkage is cumbersome &lt;em&gt;and&lt;/em&gt; slow.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So after some online research I settled on the following setup. Since I really only use this machine at home when sitting behind my desk, I got a desktop because these are cheaper to upgrade, can house more powerful hardware and I didn't really need any laptop features in it.&lt;/p&gt;
&lt;div class="section" id="screen"&gt;
&lt;h3&gt;Screen&lt;/h3&gt;
&lt;p&gt;Starting with the crown jewel - a Viewsonic VP2770-LED screen. A stunning 27&amp;quot; with 2560x1440 resolution. I got this one before the new hardware, so I could verify that indeed my old laptop can't push the full resolution to it.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/11/monitor-cropped.png" /&gt;
&lt;p&gt;This monitor can run in full resolution only from a DP (Display Port) connector or DVI. This was an important consideration in choosing a motherboard.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cpu-memory-motherboard"&gt;
&lt;h3&gt;CPU, memory, motherboard&lt;/h3&gt;
&lt;p&gt;Relatively high-end Haswell i7-4771 CPU, with 4 cores / 8 threads at 3.5GHz and 8MB of cache. Crucially, it comes with the Intel HD Graphics 4600 on board, which can support WQHD resolution. There's a catch, though. It only supports such resolution with DP or HDMI. Note - not DVI, so the intersection of GPU and monitor leave only DP as a viable option.&lt;/p&gt;
&lt;p&gt;For memory, I got 16GB of Corsair Vengeance DDR3. 16GB should be plenty for now.&lt;/p&gt;
&lt;p&gt;Motherboard - the main consideration, as mentioned above, is to have a DP output. This is why I got the Asus Q87M, which is a bit higher-end than the minimal motherboard I could get for my setup. It has DP output as well as a bunch of other goodies like two USB 3.0 ports.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="storage"&gt;
&lt;h3&gt;Storage&lt;/h3&gt;
&lt;p&gt;Another minor reason for the upgrade was to move on from a magnetic disk to SSD. For this new setup I got a 250GB Samsung 840 EVO SSD. I was pondering the size I need, but really for anything above the 100-200GB mark that would probably be backup data so I could use my external HDD to supplement that. On the laptop this system is replacing I never went above 200GB total.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="miscellanea"&gt;
&lt;h3&gt;Miscellanea&lt;/h3&gt;
&lt;p&gt;Since I don't have a discrete GPU and the Haswell CPUs are not overly power-hungry, I could get by with a small power supply. So I got a good, quiet Antec 380W supply. As for the case, one of the simpler CoolerMaster ones that promised to be quiet (and indeed it is).&lt;/p&gt;
&lt;p&gt;That's it! In 2013 there are no floppy drives, CD/DVD drives, sound cards, external network cards and a bunch of other crud we used to shove into our desktops just a few short years ago. Since my setup uses Intel's integrated graphics, it's super minimal - there are no PCI cards on the motherboard at all.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="software"&gt;
&lt;h3&gt;Software&lt;/h3&gt;
&lt;p&gt;After a very short consideration I went for the latest and greatest Ubuntu - 13.10.&lt;/p&gt;
&lt;p&gt;I'm very impressed with how quick and easy it is to install an Ubuntu desktop these days. It takes considerably less time and effort than it took to install Windows XP, say a couple of years ago. Part of that can be attributed to the speed of the system (the SSD is smoking fast - Ubuntu installed in just a few minutes), lack of external hardware and other stuff. But all in all, it's a pleasant experience to have a quick setup where everything (including the fancy WQHD monitor on a DP connection) just works with almost no tweaking. I was planning to spend the whole weekend on setting this thing up, and ended up doing it in just a couple of hours spread over week-day evenings and mornings.&lt;/p&gt;
&lt;p&gt;And of course, one of my favorite parts of the Ubuntu experience is that all the software you need is just a &lt;tt class="docutils literal"&gt;sudo &lt;span class="pre"&gt;apt-get&lt;/span&gt;&lt;/tt&gt; away. In addition, many desktop programs (like Dropbox and Chrome) just let you download &lt;tt class="docutils literal"&gt;.deb&lt;/tt&gt; files and install them.&lt;/p&gt;
&lt;p&gt;Online support is so much better these days, thanks to Google and Ask Ubuntu. To answer any question (how do I make the mouse faster? what's a good graphical program to show detailed hardware information?), just type it into Google with &amp;quot;ubuntu 13.10&amp;quot; attached and in all likeness the answer is a couple of clicks away. For me, Ubuntu/Linux has been OS of choice of years, but even for the more general public I could agree that &lt;a class="reference external" href="http://www.zdnet.com/intel-the-year-of-the-linux-desktop-is-here-7000020849/"&gt;2013 is the year of the Linux desktop&lt;/a&gt;, based on my experience. Really, I should probably go order something from Ubuntu's overpriced gift shop just to contribute back :-)&lt;/p&gt;
&lt;p&gt;Finally, I can't overestimate the convenience of having all your configuration (&amp;quot;dot-files&amp;quot;) in a Git repository so making your system behave just like you other systems is only a &lt;tt class="docutils literal"&gt;git pull&lt;/tt&gt; and a few soft links away.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h3&gt;Performance&lt;/h3&gt;
&lt;p&gt;A couple of years ago when LLVM &amp;amp; Clang were much smaller and could still link successfully on my laptop, it took me about 15 minutes for a full build. Today I built them on the new machine in under 10 minutes (9:35) - which is impressive, given how much they grew in these two years. The peak memory usage (with &lt;tt class="docutils literal"&gt;make &lt;span class="pre"&gt;-j8&lt;/span&gt;&lt;/tt&gt;) climbed to over 6GB, which aligns with my observations of thrashing on the laptop. The full regression suite (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;check-all&lt;/span&gt;&lt;/tt&gt;) runs in 1:33 minutes, which is pretty good.&lt;/p&gt;
&lt;p&gt;CPython builds 40% faster (0:51 vs. 1:30); its full test suite runs 35% faster (1:23 vs. 2:06).&lt;/p&gt;
&lt;p&gt;Node.js builds more than twice as fast (0:46 vs. 1:51).&lt;/p&gt;
&lt;p&gt;That's about all the benchmarking I intend to do because that's what I ultimately care about - compiling stuff and running tests - for large projects, quickly in parallel.&lt;/p&gt;
&lt;p&gt;The SSD adds a lot of snappiness to the system. It boots up very quickly, everything responds immediately. &lt;tt class="docutils literal"&gt;pss&lt;/tt&gt; / &lt;tt class="docutils literal"&gt;grep&lt;/tt&gt; searches are super-fast. It's a great new age where HDDs with their horrible seek times can be placed on the shelves of history.&lt;/p&gt;
&lt;/div&gt;

    </summary><category term="Hardware &amp; Gadgets"></category><category term="Linux"></category></entry><entry><title>Getting started with libjit - part 2</title><link href="http://eli.thegreenplace.net/2013/11/12/getting-started-with-libjit-part-2" rel="alternate"></link><updated>2013-11-12T06:04:17-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-11-12:2013/11/12/getting-started-with-libjit-part-2</id><summary type="html">
        &lt;p&gt;This is part 2 in a series of articles on libjit. &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;Part 1&lt;/a&gt; served as a basic introduction to the library and showed how to get started, along with some simple performance measurements. In this part, I want to discuss how to implement more interesting things with libjit, focusing on the fascinating boundary between JITed and host code.&lt;/p&gt;
&lt;p&gt;The &amp;quot;host&amp;quot; is the program that creates machine code at run-time and arranges for it to be executed. It's crucially important to understand this - complexity in the middle notwithstanding, JITing is eventually all about &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction/"&gt;some code in your process calling some other code&lt;/a&gt;. On the source level, this may be challenging to envision. Therefore, it's more useful to think about it on the binary level - after the host program is compiled and is actually executed in memory as machine code itself. I hope that the examples in this article will help explaining this concept. As usual, I'm using a pseudo-literate-programming approach - if the code samples aren't as readable as prose, please let me know.&lt;/p&gt;
&lt;div class="section" id="calls-from-jited-to-jited-and-from-jited-to-host"&gt;
&lt;h3&gt;Calls from JITed to JITed and from JITed to host&lt;/h3&gt;
&lt;p&gt;The iterative GCD example in &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;Part 1&lt;/a&gt; demonstrated a self-contained JITed function that made no external calls. Let's now look at a more involved example - how JITed functions can call other JITed functions, and how they can call code in the host. The full code, as usual, is in the &lt;a class="reference external" href="https://github.com/eliben/libjit-samples"&gt;libjit-samples repository&lt;/a&gt;. Here I'll reveal it gradually, with explanations. Let's start by defining this simple JITed function:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Builds this function, and returns an uncompiled jit_function_t:&lt;/span&gt;
&lt;span style="color: #007f00"&gt;//&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// int jit_adder(int x, y) {&lt;/span&gt;
&lt;span style="color: #007f00"&gt;//    return x + y;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// }&lt;/span&gt;
jit_function_t &lt;span style="color: #00007f"&gt;build_jit_adder&lt;/span&gt;(jit_context_t context) {
  jit_context_build_start(context);

  &lt;span style="color: #007f00"&gt;// Create function signature and object. int (*)(int, int)&lt;/span&gt;
  jit_type_t params[&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;] = {jit_type_int, jit_type_int};
  jit_type_t signature = jit_type_create_signature(
      jit_abi_cdecl, jit_type_int, params, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
  jit_function_t F = jit_function_create(context, signature);

  &lt;span style="color: #007f00"&gt;// x, y are the parameters; sum is a temporary&lt;/span&gt;
  jit_value_t x = jit_value_get_param(F, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
  jit_value_t y = jit_value_get_param(F, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
  jit_value_t sum = jit_value_create(F, jit_type_int);

  &lt;span style="color: #007f00"&gt;// sum = x + y&lt;/span&gt;
  jit_value_t temp_sum = jit_insn_add(F, x, y);
  jit_insn_store(F, sum, temp_sum);

  &lt;span style="color: #007f00"&gt;// return sum&lt;/span&gt;
  jit_insn_return(F, sum);
  jit_context_build_end(context);
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; F;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[if you went over &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;part 1&lt;/a&gt;, this code should be trivial to grok].&lt;/p&gt;
&lt;p&gt;Now, let's define a very simple function in the host program:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;native_mult&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; a, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; b) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; a * b;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, let's use libjit to build a JITed function that does this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// void foo(int x, int y, int* result) {&lt;/span&gt;
&lt;span style="color: #007f00"&gt;//   int t = jit_adder(x, y);&lt;/span&gt;
&lt;span style="color: #007f00"&gt;//   *result = native_mult(t, y);&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are at least two things here we haven't seen before. One is calling &lt;tt class="docutils literal"&gt;jit_adder&lt;/tt&gt; - a JITed function. The other is calling &lt;tt class="docutils literal"&gt;native_mult&lt;/tt&gt; - a host function. Without further ado, here's how we build &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Returns an uncompiled jit_function_t&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// Note that jit_adder is a jit_function_t that&amp;#39;s passed into this builder.&lt;/span&gt;
jit_function_t &lt;span style="color: #00007f"&gt;build_foo&lt;/span&gt;(jit_context_t context, jit_function_t jit_adder) {
  jit_context_build_start(context);

  &lt;span style="color: #007f00"&gt;// Create function signature and object. void (*)(int, int, void*)&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// libjit treats all native pointers as void*.&lt;/span&gt;
  jit_type_t params[] = {jit_type_int, jit_type_int, jit_type_void_ptr};
  jit_type_t signature = jit_type_create_signature(
      jit_abi_cdecl, jit_type_void, params, &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
  jit_function_t F = jit_function_create(context, signature);

  &lt;span style="color: #007f00"&gt;// x, y, result are the parameters; t is a temporary&lt;/span&gt;
  jit_value_t x = jit_value_get_param(F, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
  jit_value_t y = jit_value_get_param(F, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
  jit_value_t result = jit_value_get_param(F, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;);
  jit_value_t t = jit_value_create(F, jit_type_int);

  &lt;span style="color: #007f00"&gt;// t = jit_adder(x, y)&lt;/span&gt;
  jit_value_t adder_args[] = {x, y};
  jit_value_t call_temp = jit_insn_call(
      F, &lt;span style="color: #7f007f"&gt;&amp;quot;jit_adder&amp;quot;&lt;/span&gt;, jit_adder, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, adder_args, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);

  jit_insn_store(F, t, call_temp);

  &lt;span style="color: #007f00"&gt;// Prepare calling native_mult: create its signature&lt;/span&gt;
  jit_type_t mult_params[] = {jit_type_int, jit_type_int};
  jit_type_t mult_signature = jit_type_create_signature(
      jit_abi_cdecl, jit_type_int, params, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);

  &lt;span style="color: #007f00"&gt;// x = native_mult(t, y)&lt;/span&gt;
  jit_value_t mult_args[] = {t, y};
  jit_value_t res = jit_insn_call_native(
      F, &lt;span style="color: #7f007f"&gt;&amp;quot;native_mult&amp;quot;&lt;/span&gt;, native_mult, mult_signature,
      mult_args, &lt;span style="color: #00007f; font-weight: bold"&gt;sizeof&lt;/span&gt;(mult_args) / &lt;span style="color: #00007f; font-weight: bold"&gt;sizeof&lt;/span&gt;(jit_value_t), JIT_CALL_NOTHROW);
  jit_insn_store(F, x, res);

  &lt;span style="color: #007f00"&gt;// *result = x&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// Note that this creates a store of a value libjit considers to be a&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// jit_type_int, so the pointer must point to at least that size.&lt;/span&gt;
  jit_insn_store_relative(F, result, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, x);

  jit_context_build_end(context);
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; F;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The new libjit APIs used here for calling into other JITed code and into host code are &lt;tt class="docutils literal"&gt;jit_insn_call&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;jit_insn_call_native&lt;/tt&gt;, respectively. One interesting thing to note is that for the native function, the libjit API accepts the raw function pointer - the address of the host function in memory. To know how to pass parameters to the native function and how to receive the return value back from it, a libjit &amp;quot;signature&amp;quot; is created with &lt;tt class="docutils literal"&gt;jit_type_create_signature&lt;/tt&gt; first.&lt;/p&gt;
&lt;p&gt;I had previously mentioned the boundary between JITed and host code. The following diagram will hopefully help clarify what I mean:&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/10/libjit_native_boundary.png" /&gt;
&lt;p&gt;What it tries to depict is what actually happens at run-time when the JITed &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is executed. It calls &lt;tt class="docutils literal"&gt;jit_adder&lt;/tt&gt;, which was also JITed so it's somewhere on the heap (see &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction/"&gt;my introduction to JITing&lt;/a&gt; for more background). It also calls &lt;tt class="docutils literal"&gt;native_mult&lt;/tt&gt;, which resides within the host program, so it's in the &lt;tt class="docutils literal"&gt;.text&lt;/tt&gt; section. As stated before, understanding the program flow at this level is easier than at the source level, because when the program runs, host code and JITed code are practically equals - they're both chunks of machine code tucked somewhere in the executable memory pages of the running process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="passing-pointers-from-host-to-jited-code"&gt;
&lt;h3&gt;Passing pointers from host to JITed code&lt;/h3&gt;
&lt;p&gt;Another novelty introduced by &lt;tt class="docutils literal"&gt;build_foo&lt;/tt&gt; is that the result is not &lt;tt class="docutils literal"&gt;return&lt;/tt&gt;-ed to the host code. Rather, the host code passes a pointer into the JITed code, into which &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; writes its result. libjit makes this quite easy to express. The third argument of &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is declared to be a pointer in the signature. Then, &lt;tt class="docutils literal"&gt;jit_insn_store_relative&lt;/tt&gt; is called, which expects a pointer as its destination argument, along with an offset and generates code to store the value to &lt;tt class="docutils literal"&gt;[dest + offest]&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Here's how we invoke &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Run foo with arguments and return its result&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;run_foo&lt;/span&gt;(jit_function_t jit_foo, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; x, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; y) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; result, *presult = &amp;amp;result;
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* args[] = {&amp;amp;x, &amp;amp;y, &amp;amp;presult};

  jit_function_apply(jit_foo, args, &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;);
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; result;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The way &lt;tt class="docutils literal"&gt;result&lt;/tt&gt; is passed in needs some explaining. &lt;tt class="docutils literal"&gt;jit_function_apply&lt;/tt&gt; accepts &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; as an array of &lt;tt class="docutils literal"&gt;void*&lt;/tt&gt;; quoting from the docs - &amp;quot;each element in &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; is a pointer to one of the arguments&amp;quot;. So normal (non-pointer) arguments are also passed by pointer as you see above. What do we do, then, when we actually need to pass a pointer in? Right, we also pass it by pointer, just like everything else. Hence &lt;tt class="docutils literal"&gt;presult&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-the-standard-c-library-from-jited-code"&gt;
&lt;h3&gt;Using the standard C library from JITed code&lt;/h3&gt;
&lt;p&gt;We've seen how JITed code can call native code using &lt;tt class="docutils literal"&gt;jit_insn_call_native&lt;/tt&gt;. Can the same technique be used to leverage the standard C library from JITed code? Absolutely. C library functions are just normal native functions after all. Let's see an example. The following is a code sample that JITs a simple &lt;tt class="docutils literal"&gt;void foo()&lt;/tt&gt; and makes it call &lt;tt class="docutils literal"&gt;puts&lt;/tt&gt; to print out a string.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;  &lt;span style="color: #007f00"&gt;// void foo()&lt;/span&gt;
  jit_function_t F = jit_function_create(context,
      jit_type_create_signature(jit_abi_cdecl, jit_type_void, &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;));

&lt;span style="color: #007f00"&gt;  // Approach #1: allocate the string buffer on stack inside the jit-ed&lt;/span&gt;
&lt;span style="color: #007f00"&gt;  // function and store the desired characters into it.&lt;/span&gt;

&lt;span style="color: #007f00"&gt;  // char* bufptr&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#define CONST_BYTE(v) (jit_value_create_nint_constant(F, jit_type_ubyte, v))&lt;/span&gt;
  jit_type_t type_cstring = jit_type_create_pointer(jit_type_sys_char, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
  jit_value_t bufptr = jit_value_create(F, type_cstring);

  &lt;span style="color: #007f00"&gt;// Make bufptr point to a 4-byte buffer allocated on the stack&lt;/span&gt;
  jit_insn_store(F, bufptr, jit_insn_alloca(F, CONST_BYTE(&lt;span style="color: #007f7f"&gt;4&lt;/span&gt;)));

  &lt;span style="color: #007f00"&gt;// Store &amp;quot;abc&amp;quot; (with explicit terminating zero) into bufptr&lt;/span&gt;
  jit_insn_store_relative(F, bufptr, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, CONST_BYTE(&lt;span style="color: #7f007f"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;));
  jit_insn_store_relative(F, bufptr, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, CONST_BYTE(&lt;span style="color: #7f007f"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;));
  jit_insn_store_relative(F, bufptr, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, CONST_BYTE(&lt;span style="color: #7f007f"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;));
  jit_insn_store_relative(F, bufptr, &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;, CONST_BYTE(&lt;span style="color: #7f007f"&gt;&amp;#39;\x00&amp;#39;&lt;/span&gt;));

  &lt;span style="color: #007f00"&gt;// Create the signature of puts: int (*)(char*)&lt;/span&gt;
  jit_type_t puts_signature = jit_type_create_signature(
      jit_abi_cdecl, jit_type_int, &amp;amp;type_cstring, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);

  &lt;span style="color: #007f00"&gt;// puts(bufptr);&lt;/span&gt;
  jit_insn_call_native(
      F, &lt;span style="color: #7f007f"&gt;&amp;quot;puts&amp;quot;&lt;/span&gt;, puts, puts_signature, &amp;amp;bufptr, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, JIT_CALL_NOTHROW);

  &lt;span style="color: #007f00"&gt;// Approach #2: use the address of a string literal in the host code&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// directly, storing it into a constant. Note that this has to explicitly&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// specify that host pointers are 64-bit.&lt;/span&gt;

  jit_value_t hostmemptr = jit_value_create_long_constant(
      F, type_cstring, (&lt;span style="color: #00007f; font-weight: bold"&gt;long&lt;/span&gt;)&lt;span style="color: #7f007f"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;);

  jit_insn_call_native(
      F, &lt;span style="color: #7f007f"&gt;&amp;quot;puts&amp;quot;&lt;/span&gt;, puts, puts_signature, &amp;amp;hostmemptr, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, JIT_CALL_NOTHROW);

  jit_dump_function(stdout, F, &lt;span style="color: #7f007f"&gt;&amp;quot;F [uncompiled]&amp;quot;&lt;/span&gt;);
  jit_function_compile(F);
  jit_dump_function(stdout, F, &lt;span style="color: #7f007f"&gt;&amp;quot;F [compiled]&amp;quot;&lt;/span&gt;);

  &lt;span style="color: #007f00"&gt;// Run&lt;/span&gt;
  jit_function_apply(F, &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;, &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code demonstrates two alternative ways to get a string constant into the JITed code:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Using purely JITed instructions to allocate a 4-byte buffer on the stack and store the characters &lt;tt class="docutils literal"&gt;{'a', 'b', 'c', '\0'}&lt;/tt&gt; into it.&lt;/li&gt;
&lt;li&gt;Passing a pointer to the host-allocated string constant &lt;tt class="docutils literal"&gt;&amp;quot;foobar&amp;quot;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;jit_value_create_long_constant&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first way is more straightforward, IMHO, because the second one touches once more on the interface between host and JITed code. When &lt;tt class="docutils literal"&gt;jit_value_create_long_constant&lt;/tt&gt; is called, it expects a numeric constant. By passing &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(long)&amp;quot;foobar&amp;quot;&lt;/span&gt;&lt;/tt&gt; into it, we pass the address of the string constant &lt;a class="footnote-reference" href="#id4" id="id3"&gt;[1]&lt;/a&gt;. When the JITed code runs and tries to access this address (by passing it to &lt;tt class="docutils literal"&gt;puts&lt;/tt&gt; - back into host-code!), the address still points at the string constant, so everything works.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="final-words"&gt;
&lt;h3&gt;Final words&lt;/h3&gt;
&lt;p&gt;In this article I tried to make a special focus on the interface between host and JITed code. This is to emphasize the importance of this interface - which is sometimes tricky to grok, but nonetheless is one of the most important things about modern JITs.&lt;/p&gt;
&lt;p&gt;For example, the technique of passing a host pointer directly to JITed code shown in the previous section is just a hint of the tricks employed by modern JITs. The shared in-process execution of host and JITed code enables such things to be done without losing much performance in the process.&lt;/p&gt;
&lt;p&gt;Note that some JITs allow more advanced execution modes, such as a remote code emission mode, where code is emitted to run in a different process. For example, LLVM's MCJIT does that for the LLDB (debugger) use case to emit code that will run in the debugged process's memory space. In this case special provision is obviously required to have references between host and JITed code.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that by casting the pointer to &lt;tt class="docutils literal"&gt;long&lt;/tt&gt;, we also expose a platform-specific detail: this code runs on 64-bit Linux, which is LP64.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </summary><category term="Articles"></category><category term="Assembly"></category><category term="C &amp; C++"></category><category term="Code generation"></category></entry><entry><title>JavaScript (ES 5) hack for clean multi-line strings</title><link href="http://eli.thegreenplace.net/2013/11/09/javascript-es-5-hack-for-clean-multi-line-strings" rel="alternate"></link><updated>2013-11-09T15:40:10-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-11-09:2013/11/09/javascript-es-5-hack-for-clean-multi-line-strings</id><summary type="html">
        &lt;p&gt;JavaScript lacks convenient syntax for multiline strings (the equivalent of Python's triple-quotes or Perl's &amp;quot;here blocks&amp;quot;), unless you consider this convenient:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; s = &lt;span style="color: #7f007f"&gt;&amp;quot;\&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;line one\n\&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;line two\n\&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;line &amp;#39;three&amp;#39;\n&amp;quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is something ECMAScript 6 is rumored to support (along with other pink fairies and unicorns), once it gets published and adopted. But in the meantime, intrepid JavaScript programmers are left out in the dark. Unless you &lt;em&gt;really&lt;/em&gt; need this to preserve sanity and are willing to resort to unconventional methods.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/11/meme-hack.jpg" /&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; MultiString = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(f) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; f.toString().split(&lt;span style="color: #7f007f"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;).slice(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, -&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;).join(&lt;span style="color: #7f007f"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;);
}

&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; ms = MultiString(&lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {&lt;span style="color: #007f00"&gt;/**&lt;/span&gt;
&lt;span style="color: #007f00"&gt;line one&lt;/span&gt;
&lt;span style="color: #007f00"&gt;line two&lt;/span&gt;
&lt;span style="color: #007f00"&gt;line &amp;#39;three&amp;#39;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;**/&lt;/span&gt;});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yes, it's as horrible as it looks. And yes, it's sometimes convenient. Naturally for a couple of 3-line strings I probably wouldn't bother. But when you need to cleanly embed multiple long multi-line strings (templating, anyone?) in your source code, I find this pretty useful.&lt;/p&gt;

    </summary><category term="Javascript"></category></entry><entry><title>How to JIT - an introduction</title><link href="http://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction" rel="alternate"></link><updated>2013-11-05T05:59:12-08:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-11-05:2013/11/05/how-to-jit-an-introduction</id><summary type="html">
        &lt;p&gt;When I wrote the &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;introductory article for libjit&lt;/a&gt;, I aimed it at programmers who know what JITs are, at least to some extent. I did mention what a JIT is, but only very briefly. The purpose of this article is to provide a better introductory overview of JITing, with code samples that don't rely on any libraries.&lt;/p&gt;
&lt;div class="section" id="defining-jit"&gt;
&lt;h3&gt;Defining JIT&lt;/h3&gt;
&lt;p&gt;JIT is simply an acronym for &amp;quot;Just In Time&amp;quot;. That, in itself, doesn't help much - the term is quite cryptic and seems to have little to do with programming. First, let's define what &amp;quot;a JIT&amp;quot; actually refers to. I find the following way to think about this useful:&lt;/p&gt;
&lt;blockquote&gt;
Whenever a program, while running, creates and runs some new executable code which was not part of the program when it was stored on disk, it’s a JIT.&lt;/blockquote&gt;
&lt;p&gt;What about the historical usage of the term &amp;quot;JIT&amp;quot;, though? Luckily, John Aycock from the University of Calgary has written a very interesting paper named &amp;quot;A Brief History of Just-In-Time&amp;quot; (google it, PDFs are available online) looking at JIT techniques from a historical point of view. According to Aycock's paper, the first mention of code generation and execution during program runtime is apparent as early as McCarthy's LISP paper from 1960. In later work, such as Thompson's 1968 regex paper, it was even more apparent (regexes are compiled into machine code and executed on the fly).&lt;/p&gt;
&lt;p&gt;The term JIT was first brought into use in computing literature by James Gosling for Java. Aycock mentions that Gosling has borrowed the term from the domain of &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Just_in_time_%28business%29"&gt;manufacturing&lt;/a&gt; and started using it in the early 1990s.&lt;/p&gt;
&lt;p&gt;This is as far as I'll go into history here. Read the Aycock paper if you're interested in more details. Let's now see what the definition quoted above means in practice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="jit-create-machine-code-then-run-it"&gt;
&lt;h3&gt;JIT - create machine code, then run it&lt;/h3&gt;
&lt;p&gt;I think that JIT technology is easier to explain when divided into two distinct phases:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Phase 1: create &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Machine_code"&gt;machine code&lt;/a&gt; at program run-time.&lt;/li&gt;
&lt;li&gt;Phase 2: execute that machine code, also at program run-time.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Phase 1 is where 99% of the challenges of JITing are. But it's also the less mystical part of the process, because this is exactly what a compiler does. Well known compilers like &lt;tt class="docutils literal"&gt;gcc&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;clang&lt;/tt&gt; translate C/C++ source code into machine code. The machine code is emitted into an output stream, but it could very well be just kept in memory (and in fact, both &lt;tt class="docutils literal"&gt;gcc&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;clang/llvm&lt;/tt&gt; have building blocks for keeping the code in memory for JIT execution). Phase 2 is what I want to focus on in this article.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="running-dynamically-generated-code"&gt;
&lt;h3&gt;Running dynamically-generated code&lt;/h3&gt;
&lt;p&gt;Modern operating systems are picky about what they allow a program to do at runtime. The wild-west days of the past came to an end with the advent of &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Protected_mode"&gt;protected mode&lt;/a&gt;, which allows an OS to restrict chunks of virtual memory with various permissions. So in &amp;quot;normal&amp;quot; code, you can create new data dynamically on the heap, but &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Executable_space_protection"&gt;you can't just run stuff from the heap&lt;/a&gt; without asking the OS to explicitly allow it.&lt;/p&gt;
&lt;p&gt;At this point I hope it's obvious that machine code is just data - a stream of bytes. So, this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt;[] code = {&lt;span style="color: #007f7f"&gt;0x48&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0x89&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0xf8&lt;/span&gt;};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Really depends on the eye of the beholder. To some, it's just some data that could represent anything. To others, it's the binary encoding of real, valid x86-64 machine code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;mov %rdi, %rax
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So getting machine code into memory is easy. But how to make it runnable, and then run it?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="let-s-see-some-code"&gt;
&lt;h3&gt;Let's see some code&lt;/h3&gt;
&lt;p&gt;The rest of this article contains code samples for a POSIX-compliant Unix OS (specifically Linux). On other OSes (like Windows) the code would be different in the details, but not in spirit. All modern OSes have convenient APIs to implement the same thing.&lt;/p&gt;
&lt;p&gt;Without further ado, here's how we dynamically create a function in memory and execute it. The function is intentionally very simple, implementing this C code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;long&lt;/span&gt; &lt;span style="color: #00007f"&gt;add4&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;long&lt;/span&gt; num) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; num + &lt;span style="color: #007f7f"&gt;4&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's a first try (the full code with a Makefile is available in &lt;a class="reference external" href="https://github.com/eliben/libjit-samples"&gt;this repo&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span style="color: #007f00"&gt;#include &amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;


&lt;span style="color: #007f00"&gt;// Allocates RWX memory of given size and returns a pointer to it. On failure,&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// prints out the error and returns NULL.&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* &lt;span style="color: #00007f"&gt;alloc_executable_memory&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;size_t&lt;/span&gt; size) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* ptr = mmap(&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, size,
                   PROT_READ | PROT_WRITE | PROT_EXEC,
                   MAP_PRIVATE | MAP_ANONYMOUS, -&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (ptr == (&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;*)-&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) {
    perror(&lt;span style="color: #7f007f"&gt;&amp;quot;mmap&amp;quot;&lt;/span&gt;);
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; ptr;
}

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;emit_code_into_memory&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt;* m) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt; code[] = {
    &lt;span style="color: #007f7f"&gt;0x48&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0x89&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0xf8&lt;/span&gt;,                   &lt;span style="color: #007f00"&gt;// mov %rdi, %rax&lt;/span&gt;
    &lt;span style="color: #007f7f"&gt;0x48&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0x83&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0xc0&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0x04&lt;/span&gt;,             &lt;span style="color: #007f00"&gt;// add $4, %rax&lt;/span&gt;
    &lt;span style="color: #007f7f"&gt;0xc3&lt;/span&gt;                                &lt;span style="color: #007f00"&gt;// ret&lt;/span&gt;
  };
  memcpy(m, code, &lt;span style="color: #00007f; font-weight: bold"&gt;sizeof&lt;/span&gt;(code));
}

&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;size_t&lt;/span&gt; SIZE = &lt;span style="color: #007f7f"&gt;1024&lt;/span&gt;;
&lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;long&lt;/span&gt; (*JittedFunc)(&lt;span style="color: #00007f; font-weight: bold"&gt;long&lt;/span&gt;);

&lt;span style="color: #007f00"&gt;// Allocates RWX memory directly.&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;run_from_rwx&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* m = alloc_executable_memory(SIZE);
  emit_code_into_memory(m);

  JittedFunc func = m;
  &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; result = func(&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;);
  printf(&lt;span style="color: #7f007f"&gt;&amp;quot;result = %d\n&amp;quot;&lt;/span&gt;, result);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main 3 steps performed by this code are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; to allocate a readable, writable and executable chunk of memory on the heap.&lt;/li&gt;
&lt;li&gt;Copy the machine code implementing &lt;tt class="docutils literal"&gt;add4&lt;/tt&gt; into this chunk.&lt;/li&gt;
&lt;li&gt;Execute code from this chunk by casting it to a function pointer and calling through it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that step 3 can only happen because the memory chunk containing the machine code is &lt;em&gt;executable&lt;/em&gt;. Without setting the right permission, that call would result in a runtime error from the OS (most likely a segmentation fault). This would happen if, for example, we allocated &lt;tt class="docutils literal"&gt;m&lt;/tt&gt; with a regular call to &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt;, which allocates readable and writable, but not executable memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="digression-heap-malloc-and-mmap"&gt;
&lt;h3&gt;Digression - heap, malloc and mmap&lt;/h3&gt;
&lt;p&gt;Diligent readers may have noticed a half-slip I made in the previous section, by referring to memory returned from &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; as &amp;quot;heap memory&amp;quot;. Very strictly speaking, &amp;quot;heap&amp;quot; is a name that designates the memory used by &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;free&lt;/tt&gt; et. al. to manage runtime-allocated memory, as opposed to &amp;quot;stack&amp;quot; which is managed implicitly by the compiler.&lt;/p&gt;
&lt;p&gt;That said, it's not so simple :-) While traditionally (i.e. a long time ago) &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; only used one source for its memory (the &lt;tt class="docutils literal"&gt;sbrk&lt;/tt&gt; system call), these days most malloc implementations use &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; in many cases. The details differ between OSes and implementations, but often &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; is used for the large chunks and &lt;tt class="docutils literal"&gt;sbrk&lt;/tt&gt; for the small chunks. The tradeoffs have to do with the relative efficiency of the two methods of requesting more memory from the OS.&lt;/p&gt;
&lt;p&gt;So calling memory provided by &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; &amp;quot;heap memory&amp;quot; is not a mistake, IMHO, and that's what I intend to keep on doing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="caring-more-about-security"&gt;
&lt;h3&gt;Caring more about security&lt;/h3&gt;
&lt;p&gt;The code shown above has a problem - it's a security hole. The reason is the RWX (Readable, Writable, eXecutable) chunk of memory it allocates - a paradise for attacks and exploits. So let's be a bit more responsible about it. Here's some slightly modified code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Allocates RW memory of given size and returns a pointer to it. On failure,&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// prints out the error and returns NULL. Unlike malloc, the memory is allocated&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// on a page boundary so it&amp;#39;s suitable for calling mprotect.&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* &lt;span style="color: #00007f"&gt;alloc_writable_memory&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;size_t&lt;/span&gt; size) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* ptr = mmap(&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, size,
                   PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (ptr == (&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;*)-&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) {
    perror(&lt;span style="color: #7f007f"&gt;&amp;quot;mmap&amp;quot;&lt;/span&gt;);
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;NULL&lt;/span&gt;;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; ptr;
}

&lt;span style="color: #007f00"&gt;// Sets a RX permission on the given memory, which must be page-aligned. Returns&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// 0 on success. On failure, prints out the error and returns -1.&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;make_memory_executable&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* m, &lt;span style="color: #00007f; font-weight: bold"&gt;size_t&lt;/span&gt; size) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (mprotect(m, size, PROT_READ | PROT_EXEC) == -&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) {
    perror(&lt;span style="color: #7f007f"&gt;&amp;quot;mprotect&amp;quot;&lt;/span&gt;);
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; -&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
}

&lt;span style="color: #007f00"&gt;// Allocates RW memory, emits the code into it and sets it to RX before&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// executing.&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;emit_to_rw_run_from_rx&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* m = alloc_writable_memory(SIZE);
  emit_code_into_memory(m);
  make_memory_executable(m, SIZE);

  JittedFunc func = m;
  &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; result = func(&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;);
  printf(&lt;span style="color: #7f007f"&gt;&amp;quot;result = %d\n&amp;quot;&lt;/span&gt;, result);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's equivalent to the earlier snippet in all respects except one: the memory is first allocated with RW permissions (just like a normal &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; would do). This is all we really need to write our machine code into it. When the code is there, we use &lt;tt class="docutils literal"&gt;mprotect&lt;/tt&gt; to change the chunk's permission from RW to RX, making it executable but &lt;em&gt;no longer writable&lt;/em&gt;. So the effect is the same, but at no point in the execution of our program the chunk is both writable and executable, which is good from a security point of view.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-about-malloc"&gt;
&lt;h3&gt;What about malloc?&lt;/h3&gt;
&lt;p&gt;Could we use &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; instead of &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; for allocating the chunk in the previous snippet? After all, RW memory is exactly what &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; provides. Yes, we could. However, it's more trouble than it's worth, really. The reason is that protection bits can only be set on virtual memory page boundaries. Therefore, had we used &lt;tt class="docutils literal"&gt;malloc&lt;/tt&gt; we'd have to manually ensure that the allocation is aligned at a page boundary. Otherwise, &lt;tt class="docutils literal"&gt;mprotect&lt;/tt&gt; could have unwanted effects from failing to enabling/disabling more than actually required. &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; takes care of this for us by only allocating at page boundaries (because &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt;, by design, maps whole pages).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tying-loose-ends"&gt;
&lt;h3&gt;Tying loose ends&lt;/h3&gt;
&lt;p&gt;This article started with a high-level overview of what we mean when we say JIT, and ended with hands-on code snippets that show how to dynamically emit machine code into memory and execute it.&lt;/p&gt;
&lt;p&gt;The technique shown here is pretty much how real JIT engines (e.g. LLVM and libjit) emit and run executable machine code from memory. What remains is just a &amp;quot;simple&amp;quot; matter of synthesizing that machine code from something else.&lt;/p&gt;
&lt;p&gt;LLVM has a full compiler available, so it can actually translate C and C++ code (through LLVM IR) to machine code at runtime, and then execute it. libjit picks the ball up at a much lower level - it can serve as a backend for a compiler. In fact, &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/"&gt;my introductory article on libjit&lt;/a&gt; already demonstrates how to emit and run non-trivial code with libjit. But JITing is a more general concept. Emitting code at run-time can be done for &lt;a class="reference external" href="http://pyevolve.sourceforge.net/wordpress/?p=914"&gt;data structures&lt;/a&gt;, &lt;a class="reference external" href="http://sljit.sourceforge.net/"&gt;regular expressions&lt;/a&gt;  and even &lt;a class="reference external" href="http://luajit.org/ext_ffi.html"&gt;accessing C from language VMs&lt;/a&gt;. Digging in my blog's archives helped me find a mention of some &lt;a class="reference external" href="http://eli.thegreenplace.net/2005/09/04/cool-hack-creating-custom-subroutines-on-the-fly-in-perl/"&gt;JITing I did 8 years ago&lt;/a&gt;. That was Perl code generating more Perl code at run-time (from a XML description of a serialization format), but the idea is the same.&lt;/p&gt;
&lt;p&gt;This is why I felt that splitting the JITing concept into two phases is important. For phase 2 (which was explained in this article), the implementation is relatively obvious and uses well defined OS APIs. For phase 1, the possibilites are endless and what you do ultimately depends on the application you're developing.&lt;/p&gt;
&lt;/div&gt;

    </summary><category term="Articles"></category><category term="C &amp; C++"></category><category term="Code generation"></category><category term="Compilation"></category></entry><entry><title>JavaScript gotcha for Pythonistas: bound methods</title><link href="http://eli.thegreenplace.net/2013/10/28/javascript-gotcha-for-pythonistas-bound-methods" rel="alternate"></link><updated>2013-10-28T06:09:18-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-10-28:2013/10/28/javascript-gotcha-for-pythonistas-bound-methods</id><summary type="html">
        &lt;p&gt;Today while writing some JavaScript code I ran into an interesting gotcha I wanted to briefly mention. It has to do with method binding; more specifically, the behavior I'm used to from Python. Here's a code sample:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;MyKlass&lt;/span&gt;:
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.num = &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;

        f = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.foo
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.result = f(&lt;span style="color: #007f7f"&gt;10&lt;/span&gt;)

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, othernum):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.num + othernum

mk = MyKlass()
&lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(mk.result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The interesting part is invoking &lt;tt class="docutils literal"&gt;self.foo&lt;/tt&gt; indirectly via &lt;tt class="docutils literal"&gt;f()&lt;/tt&gt;. This works and prints 12 as expected. It works because the assignment &lt;tt class="docutils literal"&gt;f = self.foo&lt;/tt&gt; assigns a &lt;em&gt;bound method&lt;/em&gt; to &lt;tt class="docutils literal"&gt;f&lt;/tt&gt;. By &amp;quot;bound&amp;quot;, I mean that the method knows which object it belongs to, and when its body is executed &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; is set to the right thing.&lt;/p&gt;
&lt;p&gt;The same does not hold in JavaScript. Here's a straightforward translation:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #7f007f"&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;;

&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; MyKlass = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.num = &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;

  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; f = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.foo;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.result = f(&lt;span style="color: #007f7f"&gt;10&lt;/span&gt;);
}

MyKlass.prototype.foo = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(othernum) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.num + othernum;
}

&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; mk = &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; MyKlass();
console.log(mk);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This doesn't work. I get an error from Node.js:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;  return this.num + othernum;
             ^
TypeError: Cannot read property &amp;#39;num&amp;#39; of undefined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what's going on? The reason is that, unlike in Python, the assignment &lt;tt class="docutils literal"&gt;f = this.foo&lt;/tt&gt; does not assign a bound method to &lt;tt class="docutils literal"&gt;f&lt;/tt&gt;. It's simply a property lookup on the object &lt;tt class="docutils literal"&gt;this&lt;/tt&gt;; it indeed has the property &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;, which is a function. &lt;tt class="docutils literal"&gt;f&lt;/tt&gt; now refers to that function. That's it. There is no implicit binding going on.&lt;/p&gt;
&lt;p&gt;Once the problem is understood, it's easy to solve. The most direct solution is to bind the method explicitly on assignment, using &lt;a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"&gt;Function.prototype.bind&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; bound_f = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.foo.bind(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;);
&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.result = bound_f(&lt;span style="color: #007f7f"&gt;10&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An alternative solution is not to bind &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; when a new reference to it is made, but do it when it's invoked through that reference. This can be done using  &lt;a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"&gt;Function.prototype.call&lt;/a&gt; (or equivalently using its cousin &lt;tt class="docutils literal"&gt;apply&lt;/tt&gt;):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; f = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.foo;
&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.result = f.call(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;20&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This difference between the two languages exists because unlike Python, JavaScript does not have a first-class entity for a &lt;em&gt;bound method&lt;/em&gt;. This is not surprising, because the Python method is bound to an instance, but instances in the &amp;quot;classical&amp;quot; sense don't exist in JavaScript (see how the &lt;em&gt;class&lt;/em&gt; and &lt;em&gt;method&lt;/em&gt; concepts from &amp;quot;classical OO&amp;quot; are simulated above with JS's constructor functions and prototypal inheritance).&lt;/p&gt;
&lt;p&gt;What does exist in JavaScript is lexical binding and closures. While the &lt;tt class="docutils literal"&gt;bind&lt;/tt&gt; method is new in ES5, its effect can be simulated very easily:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f"&gt;Function&lt;/span&gt;.prototype.bind = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(obj) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; self = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; self.apply(obj, arguments);
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the actual implementation of &lt;tt class="docutils literal"&gt;bind&lt;/tt&gt; would be just a little more complicated because &lt;tt class="docutils literal"&gt;bind&lt;/tt&gt; also supports partial application of arguments (some of the arguments can be provided during binding, and the rest on invocation).&lt;/p&gt;

    </summary><category term="Javascript"></category><category term="Python"></category></entry><entry><title>Classical inheritance in JavaScript ES5</title><link href="http://eli.thegreenplace.net/2013/10/22/classical-inheritance-in-javascript-es5" rel="alternate"></link><updated>2013-10-22T06:06:17-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-10-22:2013/10/22/classical-inheritance-in-javascript-es5</id><summary type="html">
        &lt;p&gt;JavaScript's prototype-based inheritance is interesting and has its uses, but sometimes one just wants to express classical inheritance, familiar from C++ and Java. This need has been recognized by the ECMAScript committee and classes are being discussed for inclusion in the next version of the standard.&lt;/p&gt;
&lt;p&gt;It was surprisingly hard for me to find a good and simple code sample that shows how to cleanly and correctly express inheritance with ES5 (a lot of links discuss how to implement the pre-ES5 tools required for that) and explains why the thing works. Mozilla's &lt;a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"&gt;Object.Create reference&lt;/a&gt; came close, but not quite there because it still left some open questions.&lt;/p&gt;
&lt;p&gt;Hence this short post. Without further ado, the following code defines a parent class named &lt;tt class="docutils literal"&gt;Shape&lt;/tt&gt; with a constructor and a method, and a derived class named &lt;tt class="docutils literal"&gt;Circle&lt;/tt&gt; that has its own method:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Shape - superclass&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// x,y: location of shape&amp;#39;s bounding rectangle&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt; Shape(x, y) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.x = x;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.y = y;
}

&lt;span style="color: #007f00"&gt;// Superclass method&lt;/span&gt;
Shape.prototype.move = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(x, y) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.x += x;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.y += y;
}

&lt;span style="color: #007f00"&gt;// Circle - subclass&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt; Circle(x, y, r) {
  &lt;span style="color: #007f00"&gt;// Call constructor of superclass to initialize superclass-derived members.&lt;/span&gt;
  Shape.call(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;, x, y);

  &lt;span style="color: #007f00"&gt;// Initialize subclass&amp;#39;s own members&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.r = r;
}

&lt;span style="color: #007f00"&gt;// Circle derives from Shape&lt;/span&gt;
Circle.prototype = &lt;span style="color: #00007f"&gt;Object&lt;/span&gt;.create(Shape.prototype);
Circle.prototype.constructor = Circle;

&lt;span style="color: #007f00"&gt;// Subclass methods. Add them after Circle.prototype is created with&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// Object.create&lt;/span&gt;
Circle.prototype.area = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.r * &lt;span style="color: #007f7f"&gt;2&lt;/span&gt; * &lt;span style="color: #00007f"&gt;Math&lt;/span&gt;.PI;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most interesting part here, the one that actually performs the feat of inheritance is these two lines, so I'll explain them a bit:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Circle.prototype = &lt;span style="color: #00007f"&gt;Object&lt;/span&gt;.create(Shape.prototype);
Circle.prototype.constructor = Circle;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first line is the magic - it sets up the &lt;em&gt;prototype chain&lt;/em&gt;. To understand it, you must first understand that &amp;quot;the prototype of an object&amp;quot; and &amp;quot;the &lt;tt class="docutils literal"&gt;.prototype&lt;/tt&gt; property of an object&amp;quot; are different things. If you don't, go read on that a bit. The first line, interpreted very technically, says: the prototype of new objects created with the &lt;tt class="docutils literal"&gt;Circle&lt;/tt&gt; constructor is an object whose prototype is the prototype of objects created by &lt;tt class="docutils literal"&gt;Shape&lt;/tt&gt; constructor. Yeah, that's a handful. But it can be simplified as: each &lt;tt class="docutils literal"&gt;Circle&lt;/tt&gt; has a &lt;tt class="docutils literal"&gt;Shape&lt;/tt&gt; as its prototype.&lt;/p&gt;
&lt;p&gt;What about the second line? While not strictly necessary, it's there to preserve some useful invariants, as we'll see below. Since the assignment to &lt;tt class="docutils literal"&gt;Circle.prototype&lt;/tt&gt; kills the existing &lt;tt class="docutils literal"&gt;Circle.prototype.constructor&lt;/tt&gt; (which was set to &lt;tt class="docutils literal"&gt;Circle&lt;/tt&gt; when the &lt;tt class="docutils literal"&gt;Circle&lt;/tt&gt; constructor was created), we restore it.&lt;/p&gt;
&lt;p&gt;Let's whip up a JavaScript console and load that code inside, to quickly try some stuff:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt; &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; shp = &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; Shape(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;)
&lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;
&amp;gt; [shp.x, shp.y]
[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;]
&amp;gt; shp.move(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
&lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;
&amp;gt; [shp.x, shp.y]
[&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;... but we're here for the circles:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt; &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; cir = &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; Circle(&lt;span style="color: #007f7f"&gt;5&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;6&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;)
&lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;
&amp;gt; [cir.x, cir.y, cir.r]
[&lt;span style="color: #007f7f"&gt;5&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;6&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;]
&amp;gt; cir.move(&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;)
&lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;
&amp;gt; [cir.x, cir.y, cir.r]
[&lt;span style="color: #007f7f"&gt;6&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;7&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;]
&amp;gt; cir.area()
&lt;span style="color: #007f7f"&gt;12.566370614359172&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So far so good, a &lt;tt class="docutils literal"&gt;Circle&lt;/tt&gt; initialized itself correctly using the &lt;tt class="docutils literal"&gt;Shape&lt;/tt&gt; constructor; it responds to the methods inherited from &lt;tt class="docutils literal"&gt;Shape&lt;/tt&gt;, and to its own &lt;tt class="docutils literal"&gt;area&lt;/tt&gt; method too.&lt;/p&gt;
&lt;p&gt;Let's check that the prototype shenanigans worked as expected:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt; &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; shape_proto = &lt;span style="color: #00007f"&gt;Object&lt;/span&gt;.getPrototypeOf(shp)
&lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;
&amp;gt; &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; circle_proto = &lt;span style="color: #00007f"&gt;Object&lt;/span&gt;.getPrototypeOf(cir)
&lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;
&amp;gt; &lt;span style="color: #00007f"&gt;Object&lt;/span&gt;.getPrototypeOf(circle_proto) === shape_proto
&lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Great. Now let's see what &lt;tt class="docutils literal"&gt;instanceof&lt;/tt&gt; has to say:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt; cir &lt;span style="color: #00007f; font-weight: bold"&gt;instanceof&lt;/span&gt; Shape
&lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;
&amp;gt; cir &lt;span style="color: #00007f; font-weight: bold"&gt;instanceof&lt;/span&gt; Circle
&lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;
&amp;gt; shp &lt;span style="color: #00007f; font-weight: bold"&gt;instanceof&lt;/span&gt; Shape
&lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;
&amp;gt; shp &lt;span style="color: #00007f; font-weight: bold"&gt;instanceof&lt;/span&gt; Circle
&lt;span style="color: #00007f; font-weight: bold"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, here are some things we can do with the &lt;tt class="docutils literal"&gt;constructor&lt;/tt&gt; property that wouldn't have been possible had we not preserved it:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt; cir.constructor === Circle
&lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// Create a new Circle object based on an existing Circle instance&lt;/span&gt;
&amp;gt; &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; new_cir = &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; cir.constructor(&lt;span style="color: #007f7f"&gt;3&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;4&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1.5&lt;/span&gt;)
&lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;
&amp;gt; new_cir
Circle {x: &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;, y: &lt;span style="color: #007f7f"&gt;4&lt;/span&gt;, r: &lt;span style="color: #007f7f"&gt;1.5&lt;/span&gt;, constructor: &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;, area: &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A lot of existing code (and programmers) expect the &lt;tt class="docutils literal"&gt;constructor&lt;/tt&gt; property of objects to point back to the constructor function used to create them with &lt;tt class="docutils literal"&gt;new&lt;/tt&gt;. In addition, it is sometimes useful to be able to create a new object of the same class as an existing object, and here as well the &lt;tt class="docutils literal"&gt;constructor&lt;/tt&gt; property is useful.&lt;/p&gt;
&lt;p&gt;So that is how we express classical inheritance in JavaScript. It is very explicit, and hence on the long-ish side. Hopefully the future ES standards will provide nice sugar for succinct &lt;tt class="docutils literal"&gt;class&lt;/tt&gt; definitions.&lt;/p&gt;

    </summary><category term="Javascript"></category></entry><entry><title>Getting started with libjit - part 1</title><link href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1" rel="alternate"></link><updated>2013-10-17T06:52:25-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-10-17:2013/10/17/getting-started-with-libjit-part-1</id><summary type="html">
        &lt;p&gt;libjit is a very interesting project. It's a C library for generating executable machine code at runtime. As such, it can serve as a back-end of a JIT compiler. libjit was originally created as part of the larger DotGNU project (portable .NET runtime). Since DotGNU has been discontinued, libjit has fallen on and off into oblivion, but recently it's being maintained again.&lt;/p&gt;
&lt;p&gt;libjit is not easy to get started with, and hence this series of articles. I spent a couple of days getting it to build and writing some simple programs using it, so I wanted to document this effort. libjit is one of those typical open-source projects in which the only real authority is the latest source code. Don't even look at the last &amp;quot;released&amp;quot; version - the code in Git is much more up-to-date. Similar for documentation: while the &lt;a class="reference external" href="http://www.gnu.org/software/libjit/doc/libjit.html"&gt;online docs&lt;/a&gt; are a pretty good place to get started, they are direly out of date when compared to the source code. That said, the project's source code is clean and well-documented C, so it's pretty easy to grok. Also, the tutorial part of the documentation is useful - make sure you go over it before reading this post; otherwise, it may be difficult to understand what libjit is about.&lt;/p&gt;
&lt;div class="section" id="a-few-words-on-jits"&gt;
&lt;h3&gt;A few words on JITs&lt;/h3&gt;
&lt;p&gt;JITs have become very popular in the past decade or so due to their use in popular mainstream languages like Java, JavaScript and C#. However, the idea of recompiling a program at runtime is almost as old as programming itself &lt;a class="footnote-reference" href="#id5" id="id1"&gt;[1]&lt;/a&gt;. Generating native machine code from higher-level bytecode at runtime is a concept many language designers have encountered in the past 50 years, and the problems/tradeoffs they ran into are comfortingly similar. In other words, it's an old and familiar problem.&lt;/p&gt;
&lt;p&gt;While &amp;quot;a JIT&amp;quot; is usually thought about as part of some larger bytecode virtual machine (such as the JVM), it's a more general concept. I find the following way to think about this useful:&lt;/p&gt;
&lt;blockquote&gt;
Whenever a program, while running, creates and runs some new executable code which was not part of the program when it was stored on disk, it's a JIT.&lt;/blockquote&gt;
&lt;p&gt;libjit fits this description well, since it's more general than the traditional VM association of JITs is (even though libjit was also originally conceived for the purpose of implementing a VM). True, libjit can be used to speed-up a VM by compiling bytecode to machine code at runtime. But it can be used for other things as well:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Dynamic code generation from DSLs like regexes.&lt;/li&gt;
&lt;li&gt;Dynamic code generation for specialized data structures and algorithms.&lt;/li&gt;
&lt;li&gt;Implementing FFI (Foreign Function Interface) mechanisms for interfacing with native code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As we'll see, libjit is very general, so the possibilities are only limited by the imagination.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-libjit-api"&gt;
&lt;h3&gt;The libjit API&lt;/h3&gt;
&lt;p&gt;[reminder: please go over &lt;a class="reference external" href="http://www.gnu.org/software/libjit/doc/libjit_3.html"&gt;the tutorial in the official docs of libjit&lt;/a&gt; before reading on]&lt;/p&gt;
&lt;p&gt;I found the libjit API to be very well designed and intuitive. Once you spend some time with it, it becomes obvious how to do additional things without even looking them up. What follows is a short summary of how it works.&lt;/p&gt;
&lt;p&gt;By means of its API calls, libjit builds an in-memory intermediate representation of a fairly low level bytecode. In formal terms, the IR  is based on a &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Three-address_code"&gt;three-address code&lt;/a&gt; &lt;a class="footnote-reference" href="#id6" id="id2"&gt;[2]&lt;/a&gt;. This is somewhat similar to LLVM IR, although there are also important differences. For example, unlike LLVM, libjit does not have a serialized textual or binary representation of its IR - it only exists in memory.&lt;/p&gt;
&lt;p&gt;Some of the most important data structures / objects in libjit are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;jit_value_t&lt;/tt&gt;: a generic &lt;em&gt;value&lt;/em&gt; that serves as an argument to, and the potential return value from, libjit operations.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;jit_label_t&lt;/tt&gt;: represents a jump target, just like in assembly languages.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;jit_function_t&lt;/tt&gt;: represents a JIT-ed function that contains instructions and labels, can be compiled, run, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JIT &lt;em&gt;instructions&lt;/em&gt; are created by means of &lt;tt class="docutils literal"&gt;jit_insn_*&lt;/tt&gt; calls. These calls accept the function object to add the instruction to, as well as potentially some values and/or labels. If the instruction returns a value, the API call will return a &lt;tt class="docutils literal"&gt;jit_value_t&lt;/tt&gt; that represents it. Instructions are added to functions linearly - think of a function consisting of a sequence of instructions - each new &lt;tt class="docutils literal"&gt;jit_insn_*&lt;/tt&gt; call appends one instruction to the end of that sequence.&lt;/p&gt;
&lt;p&gt;Let's now get to a complete example that shows how these interact in practice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="building-libjit"&gt;
&lt;h3&gt;Building libjit&lt;/h3&gt;
&lt;p&gt;First things first. I cloned the latest code from Git. libjit doesn't come with a &lt;tt class="docutils literal"&gt;configure&lt;/tt&gt; script; rather, it needs to be generated with autotools using the provided &lt;tt class="docutils literal"&gt;auto_gen.sh&lt;/tt&gt; script. I had to install &lt;tt class="docutils literal"&gt;libtool&lt;/tt&gt; first, and a couple of other build dependencies:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ sudo apt-get install libtool flex bison texinfo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After this, I could run &lt;tt class="docutils literal"&gt;./auto_gen.sh&lt;/tt&gt; followed by the usual &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;configure-make&lt;/span&gt;&lt;/tt&gt; sequence. &lt;tt class="docutils literal"&gt;make check&lt;/tt&gt; can also be used to run the tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linking-with-libjit"&gt;
&lt;h3&gt;Linking with libjit&lt;/h3&gt;
&lt;p&gt;The libjit makefile creates both a static archive and a shared library, so you can choose whether you want to link libjit in statically or dynamically. Note that the library is quite large (a couple of MBs). Here's a portion of my makefile that compiles a program (&lt;tt class="docutils literal"&gt;gcd_iter.c&lt;/tt&gt;, which we'll see soon) and links it successfully with libjit:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;LIBJIT_PATH = $$HOME/test/libjit
LIBJIT_INCLUDE_PATH = &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LIBJIT_PATH&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt;/include
LIBJIT_LIB_PATH = &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LIBJIT_PATH&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt;/jit/.libs
LIBJIT_AR = &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LIBJIT_LIB_PATH&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt;/libjit.a

CC = gcc
LD = gcc
CCOPT = -g -O0
CCFLAGS = -c &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;CCOPT&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt;
LDFLAGS = -lpthread -lm -ldl

gcd_iter: gcd_iter.o
      &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LD&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt; $^ &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LIBJIT_AR&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LDFLAGS&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt; -o $@

gcd_iter.o: gcd_iter.c
      &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;CC&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt; -I&lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;LIBJIT_INCLUDE_PATH&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt; -I. &lt;span style="color: #00007f; font-weight: bold"&gt;$(&lt;/span&gt;CCFLAGS&lt;span style="color: #00007f; font-weight: bold"&gt;)&lt;/span&gt; $^ -o $@
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a completely generic &amp;quot;out of source&amp;quot; build. Your code can be located anywhere - all you need to supply is &lt;tt class="docutils literal"&gt;LIBJIT_PATH&lt;/tt&gt;. It builds and links libjit statically.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-a-simple-program"&gt;
&lt;h3&gt;Creating a simple program&lt;/h3&gt;
&lt;p&gt;The libjit tutorial has code for recursive GCD computation. Let's see how to write an iterative one, which contains a loop and somewhat more temporary value traffic. We'll build a JIT function that implements this algorithm:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;gcd_iter&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; u, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; v) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; t;
  &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; (v) {
    t = u;
    u = v;
    v = t % v;
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; u &amp;lt; &lt;span style="color: #007f7f"&gt;0&lt;/span&gt; ? -u : u; &lt;span style="color: #007f00"&gt;/* abs(u) */&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here it is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Returns an uncompiled jit_function_t.&lt;/span&gt;
jit_function_t &lt;span style="color: #00007f"&gt;build_gcd_func&lt;/span&gt;(jit_context_t context) {
  jit_context_build_start(context);

  &lt;span style="color: #007f00"&gt;// Create function signature and object. int (*)(int, int)&lt;/span&gt;
  jit_type_t params[&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;] = {jit_type_int, jit_type_int};
  jit_type_t signature = jit_type_create_signature(
      jit_abi_cdecl, jit_type_int, params, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
  jit_function_t F = jit_function_create(context, signature);

  &lt;span style="color: #007f00"&gt;// u, v are function parameters; t is a temporary value.&lt;/span&gt;
  jit_value_t u, v, t;
  u = jit_value_get_param(F, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);
  v = jit_value_get_param(F, &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
  t = jit_value_create(F, jit_type_int);

  &lt;span style="color: #007f00"&gt;// Create the while (v) condition with a label that allows to loop back.&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;//&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// label_while:&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;//   if (v == 0) goto label_after_while&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;//   .. contents of while loop&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;//&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// label_after_while is created as undefined at this point, so that&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// instructions can have forward references to it. It will be placed later.&lt;/span&gt;
  jit_label_t label_while = jit_label_undefined;
  jit_label_t label_after_while = jit_label_undefined;
  jit_value_t const0 = jit_value_create_nint_constant(F, jit_type_int, &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;);

  jit_insn_label(F, &amp;amp;label_while);
  jit_value_t cmp_v_0 = jit_insn_eq(F, v, const0);
  jit_insn_branch_if(F, cmp_v_0, &amp;amp;label_after_while);

  &lt;span style="color: #007f00"&gt;// t = u&lt;/span&gt;
  jit_insn_store(F, t, u);
  &lt;span style="color: #007f00"&gt;// u = v&lt;/span&gt;
  jit_insn_store(F, u, v);

  &lt;span style="color: #007f00"&gt;// v = t % v&lt;/span&gt;
  jit_value_t rem = jit_insn_rem(F, t, v);
  jit_insn_store(F, v, rem);

  &lt;span style="color: #007f00"&gt;//   goto label_while&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// label_after_while:&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;//   ...&lt;/span&gt;
  jit_insn_branch(F, &amp;amp;label_while);
  jit_insn_label(F, &amp;amp;label_after_while);

  &lt;span style="color: #007f00"&gt;//   if (u &amp;gt;= 0) goto label_positive&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;//   return -u&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// label_pos:&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;//   return u&lt;/span&gt;
  jit_label_t label_positive = jit_label_undefined;
  jit_value_t cmp_u_0 = jit_insn_ge(F, u, const0);
  jit_insn_branch_if(F, cmp_u_0, &amp;amp;label_positive);

  jit_value_t minus_u = jit_insn_neg(F, u);
  jit_insn_return(F, minus_u);
  jit_insn_label(F, &amp;amp;label_positive);
  jit_insn_return(F, u);

  jit_context_build_end(context);
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; F;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code should be quite readable now, but for extra points take a look at the reference documentation for the APIs used. Just a word of caution: the most up-to-date reference documentation for libjit is in code comments in the latests git snapshot.&lt;/p&gt;
&lt;p&gt;Another note, on error reporting. libjit is, unfortunately, not very good at it. If you do something wrong, it will bite you. I've spent almost an hour chasing a bizarre stack-thrashing bug because &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; was not initialized with &lt;tt class="docutils literal"&gt;jit_value_create&lt;/tt&gt;. I had initially written the code expecting &lt;tt class="docutils literal"&gt;jit_insn_store(F, t, u)&lt;/tt&gt; to just do the right thing. It doesn't. And it doesn't tell you about it either. Initialize your &lt;tt class="docutils literal"&gt;jit_value_t&lt;/tt&gt; variables!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="interpreted-vs-compiled"&gt;
&lt;h3&gt;Interpreted vs. compiled&lt;/h3&gt;
&lt;p&gt;As mentioned above, the libjit API defines an IR for describing programs. libjit has a built-in interpreter that can execute programs directly from this IR, without lowering further to machine code. This is used on architectures for which libjit doesn't yet have a backend. On architectures that do have a backend (like the x86-64 machine I'm working on), the default build sequence will only link the machine-specific backend in.&lt;/p&gt;
&lt;p&gt;This can be changed by passing the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--enable-interpreter&lt;/span&gt;&lt;/tt&gt; flag to &lt;tt class="docutils literal"&gt;./configure&lt;/tt&gt;. The flag tells the configuration script to set up the interpreter as the backend, leaving the machine-specific code generators out. This can be useful for debugging libjit as well. We'll see some performance numbers for the interpreter later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="running-the-jit-ed-code-apply-vs-direct-invocation"&gt;
&lt;h3&gt;Running the JIT-ed code: apply vs. direct invocation&lt;/h3&gt;
&lt;p&gt;How do we run the GCD function built by &lt;tt class="docutils literal"&gt;build_gcd_func&lt;/tt&gt;? The most straightforward way is using &lt;tt class="docutils literal"&gt;jit_function_apply&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;jit_function_t gcd = build_gcd_func(context);

&lt;span style="color: #007f00"&gt;// Compile (JIT) the function to machine code&lt;/span&gt;
jit_context_build_start(context);
jit_function_compile(gcd);
jit_context_build_end(context);

&lt;span style="color: #007f00"&gt;// Run the function on argv input&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; u = atoi(argv[&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;]);
&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; v = atoi(argv[&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;]);
&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* args[&lt;span style="color: #007f7f"&gt;2&lt;/span&gt;] = {&amp;amp;u, &amp;amp;v};

jit_int result;
jit_function_apply(gcd, args, &amp;amp;result);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;jit_function_apply&lt;/tt&gt; is a fully general method for invoking JIT-ed code from dynamic language runtimes. It makes no assumptions for the &lt;em&gt;caller&lt;/em&gt; - the addresses of arguments are taken, and &lt;tt class="docutils literal"&gt;jit_function_apply&lt;/tt&gt; uses the signature of the called function object to figure out how to provide these arguments to the actual function (w.r.t. calling convention, etc) &lt;a class="footnote-reference" href="#id7" id="id3"&gt;[3]&lt;/a&gt;. It also provides the ability to compile the function on-demand, sets up libjit-specific exception handling, etc.&lt;/p&gt;
&lt;p&gt;While great for dynamic language runtimes, when we just want to call JIT-ed code from a compiled C or C++ program, &lt;tt class="docutils literal"&gt;jit_function_apply&lt;/tt&gt; carries needless overhead. Since the caller in this case almost certainly has the same calling convention (or, in other words, shares the ABI) it's wasteful to go through this general process - why not just get the pointer of the entry point of the JIT-ed code and invoke it directly?&lt;/p&gt;
&lt;p&gt;This is exactly what the libjit &lt;em&gt;closure&lt;/em&gt; &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[4]&lt;/a&gt; mechanism provides. Using a closure, the &lt;tt class="docutils literal"&gt;jit_function_apply&lt;/tt&gt; call is replaced with this:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; (*FF)(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;);
FF gcd_f = jit_function_to_closure(gcd);
&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; result = gcd_f(u, v);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;jit_function_to_closure&lt;/tt&gt; returns the address of the entry point (the first instruction) of the JIT-ed code. To call it directly, we must tell the compiler (of the calling code) how to interpret the address, by specifying a function pointer type.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h3&gt;Performance&lt;/h3&gt;
&lt;p&gt;I ran the GCD computation on two large primes (which resulted in 17 iterations before returning 1), 5 million times in a loop, and compared the runtime of the various libjit run methods (interpreter, apply, closure) vs. the same function implemented in C and compiled natively with &lt;tt class="docutils literal"&gt;gcc &lt;span class="pre"&gt;-O0&lt;/span&gt;&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/10/libjit_chart_1.png" /&gt;
&lt;p&gt;Some thoughts on these results:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The interpreter is indeed slow, but not as slow as I'd expect. I'm actually impressed that it provides reasonable performance, given how low-level the libjit IR is.&lt;/li&gt;
&lt;li&gt;The large difference between apply and closure is due to the short function runtime. Only 17 iterations of the GCD loop fly by quickly, but for &lt;tt class="docutils literal"&gt;jit_function_apply&lt;/tt&gt; we pay the large overhead for switching from native to JIT-ed code on every call. If the function was longer-running, I'm sure that the difference between apply and closure would be smaller. Note also that the overhead is only paid when moving from native to JIT and back - calls bounded within the JIT-ed code are fast.&lt;/li&gt;
&lt;li&gt;It does not surprise me that libjit (with the closure call approach) beats &lt;tt class="docutils literal"&gt;gcc &lt;span class="pre"&gt;-O0&lt;/span&gt;&lt;/tt&gt;. Keep in mind that &lt;tt class="docutils literal"&gt;gcc &lt;span class="pre"&gt;-O0&lt;/span&gt;&lt;/tt&gt; starts from C code, while for libjit we laid out a very low-level IR representation manually. So we've basically done all the compilation work and handed the results to execution. Still, some things (like register allocation and peephole optimizations) live below this level, which is why &lt;tt class="docutils literal"&gt;gcc &lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt; managed to produce code that's 25% faster than libjit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h3&gt;What's next&lt;/h3&gt;
&lt;p&gt;In future parts of this article I intend to look at the machine code generated by libjit, as well as explore its other features such as calls from JITed to native code. All the code for the article is free (public domain) and available in my &lt;a class="reference external" href="https://github.com/eliben/libjit-samples"&gt;libjit-samples&lt;/a&gt;  Github repository.&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/hline.jpg" style="width: 320px; height: 5px;" /&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The paper &amp;quot;A brief history of Just-In-Time&amp;quot; by John Aycock states that the earliest signs for JIT ideas can be found in McCarthy's original LISP research from the early 1960s. It was just not called &amp;quot;JIT&amp;quot; those days - this term was coined for Java and taken from the world of manufacturing.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I originally quoted the &lt;a class="reference external" href="http://en.wikipedia.org/wiki/DotGNU"&gt;DotGNU Wikipedia page&lt;/a&gt; which also said that libjit IR keeps variables in static single assignment (SSA) form. After discussing this with Aleksey Demakov, the current maintainer of libjit, I removed that part because libjit doesn't really use SSA. Store instructions may be used to assign different values to the same variable within a single basic block, and there are also no Phi nodes. In LLVM, on the other hand, all register values are kept in SSA form.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is similar to how foreign function interfaces (FFI) work; for example, &lt;a class="reference external" href="http://sourceware.org/libffi/"&gt;libffi&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Not the best usage for the term closure, IMHO, but I'll stick to it since this is the nomenclature in libjit's code and documentation.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

    </summary><category term="Articles"></category><category term="Assembly"></category><category term="C &amp; C++"></category><category term="Code generation"></category></entry><entry><title>Some notes on logging and SSH access from cron jobs</title><link href="http://eli.thegreenplace.net/2013/10/08/some-notes-on-logging-and-ssh-access-from-cron-jobs" rel="alternate"></link><updated>2013-10-08T05:56:34-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-10-08:2013/10/08/some-notes-on-logging-and-ssh-access-from-cron-jobs</id><summary type="html">
        &lt;p&gt;In the process of making the &lt;a class="reference external" href="https://github.com/python/cpython"&gt;semi-official CPython mirror on Github&lt;/a&gt; auto-update, I ventured into cron-land; it's a land I've hardly been to before, so here's a quick blog post describing some of the interesting things I learned. This was written for Ubuntu 12.04, but should apply with very minimal changes to any Linux.&lt;/p&gt;
&lt;p&gt;The basic stuff: &lt;tt class="docutils literal"&gt;crontab &lt;span class="pre"&gt;-e&lt;/span&gt;&lt;/tt&gt; to edit your crontab, &lt;tt class="docutils literal"&gt;crontab &lt;span class="pre"&gt;-l&lt;/span&gt;&lt;/tt&gt; to dump it to stdout.&lt;/p&gt;
&lt;p&gt;If you're wondering which tasks cron ran recently look in &lt;tt class="docutils literal"&gt;/var/log/syslog&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;A common problem that comes up with writing crontabs is that the environment the cron jobs are executed in are different from your normal environment. They will have your username, but not much in terms of environment variables you have that set up the way your terminal experience looks. A good way to see what kind of environment cron has when it runs your jobs is to add this rule:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;*/1 * * * * env &amp;gt; /temp/my-cronenv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This tells cron to dump its environment to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/tmp/my-cronenv&lt;/span&gt;&lt;/tt&gt; every minute. Once you have a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;my-cronenv&lt;/span&gt;&lt;/tt&gt; file, you can reproduce running your jobs in cron's environment by running them as:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ env - `&lt;code&gt;cat __abENT__#8260;temp__abENT__#8260;my-cronenv&lt;/code&gt;`  &amp;lt;the script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another common question that comes up is &amp;quot;how to do logging from my cron jobs?&amp;quot;. The mechanics of logging itself depend on the language the script is written in, of course. For Python there's the &lt;tt class="docutils literal"&gt;logging&lt;/tt&gt; package. But where to store those logs? If you want your logs to be where all the cool kids' logs are, that would be &lt;tt class="docutils literal"&gt;/var/log&lt;/tt&gt;. But you usually don't have non-sudo permissions in that directory. So do this, replacing &lt;tt class="docutils literal"&gt;foobar&lt;/tt&gt; with your username:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ sudo mkdir /var/log/foobar_logs
$ sudo chown foobar /var/log/foobar_logs/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From now on, you're free to create new files and edit existing ones in &lt;tt class="docutils literal"&gt;/var/log/foobar_logs&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;A hairier problem exists with SSH. Suppose that you want your cron job to log into some remote server (whether for Git access, &lt;tt class="docutils literal"&gt;scp&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;rsync&lt;/tt&gt;, or remote command execution) for which you've diligently set up a public/private key pair. And you even went as far as to run &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;ssh-agent&lt;/span&gt;&lt;/tt&gt; on your local machine to avoid entering that pesky private key passphrase every time (you do use a passphrase for your secret key, right?) How do you make sure that your cron jobs have proper access to ssh-agent and don't need the passphrase?&lt;/p&gt;
&lt;p&gt;There's a number of ways to go about this, but I found &lt;a class="reference external" href="http://oceanpark.com/notes/howto_ssh_keychain_public_key_authentication_forwarding.html"&gt;this walkthrough using keychain&lt;/a&gt; effective.&lt;/p&gt;
&lt;p&gt;First, install the &lt;tt class="docutils literal"&gt;keychain&lt;/tt&gt; program. Second, add this to your &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.bash_profile&lt;/span&gt;&lt;/tt&gt; (we don't need this to run for every terminal, just on login):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;# Use keychain to keep ssh-agent information available in a file
/usr/bin/keychain $HOME/.ssh/id_rsa
source $HOME/.keychain/${HOSTNAME}-sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Tweak as needed for the location of your private SSH keys. Also, make sure your &lt;tt class="docutils literal"&gt;.bash_profile&lt;/tt&gt; is actually invoked at start-up. When logging into Ubuntu graphically, this may not be the case unless it's sourced in &lt;tt class="docutils literal"&gt;.profile&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Third, add this to the cron job script (if your cron job is a Python program, just wrap it in a shell script):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;source $HOME/.keychain/${HOSTNAME}-sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's all.&lt;/p&gt;

    </summary><category term="Linux"></category><category term="Software &amp; Tools"></category></entry><entry><title>Summary of reading: July - September 2013</title><link href="http://eli.thegreenplace.net/2013/10/04/summary-of-reading-july-september-2013" rel="alternate"></link><updated>2013-10-04T05:43:17-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-10-04:2013/10/04/summary-of-reading-july-september-2013</id><summary type="html">
        &lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;Man's Search for Meaning&amp;quot; by Viktor Frankl - The first half of the book is the author's auto-biographic story of his time in various Nazi concentration and work  camps during WWII. It's your usual, pretty horrible, holocaust story. He links it to the second part of the book as well, which is an explanation of his method of psychoanalysis - focusing on finding meaning in life as a means for mental health. There's really not much to it, though, so the second part of the book felt quite repetitive and tedious. Overall I'd say I liked the book, but not as much as I hoped I would.&lt;/li&gt;
&lt;li&gt;&amp;quot;The Moon is Down&amp;quot; by John Steinbeck - Not a usual book for Steinbeck - a fictitious account of a German-occupied town during World War II (even though Germany itself isn't mentioned, it's very clear what the book refers to). It was interesting to read about the background for this work, and especially its propaganda value in occupied Northern Europe - and how clueless the couch critics of New York were in first reviewing it. All in all, quite an interesting short read.&lt;/li&gt;
&lt;li&gt;&amp;quot;Team Geek&amp;quot; by Brian W. Fitzpatrick and Ben Collins-Sussman - a short collection of essays on being part of a programming team. Some of it is for team leaders, but most is aimed at rank programmers. The authors mix together a lot of experiences from both the corporate world and large open source projects. Personally I think the dynamics of the two are very different. For example, one of the better known parts of the book (which I think was some kind of popular talk) - &amp;quot;dealing with poisonous people&amp;quot; - is looked at from the perspective of an open-source project and thus is only partially applicable to a team at a workplace. If you've never read &amp;quot;peopleware&amp;quot; kinds of books before, it's recommended. Otherwise, not much new material here. On the other hand the book is very short and easy to read so if you just have a couple of hours to spare you'll be through it.&lt;/li&gt;
&lt;li&gt;&amp;quot;Thinking Fast and Slow&amp;quot; by Daniel Kahneman - This book is so packed with useful information it's both fun and a burden to read. It's a burden because information gleaned from it requires some thinking and digesting, and you just can't read too much of it in one sitting. A lot of nonfiction books keep hammering on the same idea on and on. Not Kahneman. He provides many different angles to the points he presents and if you lose attention for a period of time you're surely going to miss some interesting content. I really liked the presentation of the major dichotomies - system 1 vs. system 2, econs vs. humans and the experiencing vs. the remembering self. Some of the stuff will probably take me additional time to fully digest. Highly recommended if you're interested in a breakdown of the way the human thought process works.&lt;/li&gt;
&lt;li&gt;&amp;quot;A Farewell to Arms&amp;quot; by Ernest Hemingway - I have a half-vague memory of reading another book by Hemingway 15 years ago or so. My impression was &amp;quot;boring description of the author slacking off and drinking alcohol all day&amp;quot; (it was probably The Sun Also Rises). So I decided to give Hemingway another try and took a more acclaimed work - &amp;quot;A Farewall to Arms&amp;quot;. What can I say, I still didn't like it. I have a hunch that this book was considered very novel and daring 100 years ago, and of course there's the anti-war sentiment which is always a good reason for a Nobel prize. All them silly Austrians and Italians fighting over some mountains without anyone really knowing why. But what did the protagonist have to do at that war? Also, unknown. The love story is tiresome and very mundane by today's standards; the tragic end very much expected and very much useless. The alcohol is still there - like clockwork. A blog of drinking. You thought &amp;quot;here's what I had for lunch&amp;quot; blogging is 21st century? Think again. To conclude, I guess Hemingway and me, we just don't have that special connection readers have with authors they actually like.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Re-reads:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&amp;quot;Travels with Charley&amp;quot; by John Steinbeck&lt;/li&gt;
&lt;li&gt;&amp;quot;Eat, Drink, and Be Healthy&amp;quot; by Walter C. Willett&lt;/li&gt;
&lt;/ul&gt;
    </summary><category term="Book reviews"></category></entry><entry><title>pss v1.39 released</title><link href="http://eli.thegreenplace.net/2013/09/20/pss-v1-39-released" rel="alternate"></link><updated>2013-09-20T19:43:47-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-09-20:2013/09/20/pss-v1-39-released</id><summary type="html">
        Version 1.39 of &lt;a href="https://github.com/eliben/pss"&gt;pss&lt;/a&gt; was released today (on &lt;a href="https://pypi.python.org/pypi/pss/"&gt;PyPI&lt;/a&gt; too).

Here's the changelog for this version:

&lt;ul&gt;
&lt;li&gt;Fixed a number of problems with mixing regex pattern and extensions in file searching (see Github issues #2 and #3).&lt;/li&gt;
&lt;li&gt;Sped up searching for multiple regex file patterns (such as '--cmake --make') by ~10%.&lt;/li&gt;
&lt;li&gt;Fixed a colorama bug that caused intermittent coloring problems on 64-bit Windows (pull request #7 by Ben Hoyt).&lt;/li&gt;
&lt;li&gt;Added --color-line option to specify custom line number coloring (issue #11 by Ben Hoyt).&lt;/li&gt;
&lt;li&gt;Added the .pyw extension to Python patterns (issue #12).&lt;/li&gt;
&lt;li&gt;Added the .go extension for Go (issue #14).&lt;/li&gt;
&lt;/ul&gt;

With the help of &lt;a href="https://travis-ci.org/eliben/pss"&gt;Travis CI&lt;/a&gt; and &lt;a href="http://eli.thegreenplace.net/2012/05/07/automating-boring-testing-activities-with-tox/"&gt;tox&lt;/a&gt; I'm giving pss a pretty good spin on Linux. Since it's a pure Python program with no external dependencies I'm 99.5% sure it works on OS X and Windows, although I don't test it before releasing; pss has many users on these platforms, so I'd hear something pretty quick if things would break.

As usual, help with testing on various platforms is always appreciated. Drop me a note if you run pss successfully (and especially if you have problems) on some less common platform.



    </summary><category term="Software &amp; Tools"></category></entry><entry><title>Analyzing function CFGs with LLVM</title><link href="http://eli.thegreenplace.net/2013/09/16/analyzing-function-cfgs-with-llvm" rel="alternate"></link><updated>2013-09-16T07:16:53-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-09-16:2013/09/16/analyzing-function-cfgs-with-llvm</id><summary type="html">
        &lt;p&gt;A common question about LLVM that comes up on Stack Overflow is how to build the  control-flow graph (CFG) of a function and then topologically sort it, or some variation of this. To save myself answering time in the future, I figured I'll just throw a quick post together that shows off a number of capabilities LLVM provides in this domain.&lt;/p&gt;
&lt;p&gt;First of all, people asking this question often miss the fact that basic blocks (BBs) are already organized in a CFG, and there's no need to build a new graph in order to run interesting analyses.&lt;/p&gt;
&lt;p&gt;Each BB has a list of &lt;em&gt;successors&lt;/em&gt; - BBs to which control-flow may transfer from this BB. It can be easily obtained by looking at the terminator instruction of the BB (by definition, a BB has a single terminator):&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// BB is a BasicBlock*&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// ...&lt;/span&gt;
&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; TerminatorInst *TInst = BB-&amp;gt;getTerminator();
&lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; I = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, NSucc = TInst-&amp;gt;getNumSuccessors(); I &amp;lt; NSucc; ++I) {
  BasicBlock *Succ = TInst-&amp;gt;getSuccessor(I);
  &lt;span style="color: #007f00"&gt;// Do stuff with Succ&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This interlinking of BBs constitutes a graph we can traverse in any way we see fit. For example, here is an implementation of topological sorting:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;TopoSorter&lt;/span&gt; {
&lt;span style="color: #00007f; font-weight: bold"&gt;public&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; runToposort(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; Function &amp;amp;F) {
    outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;Topological sort of &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;:\n&amp;quot;&lt;/span&gt;;
    &lt;span style="color: #007f00"&gt;// Initialize the color map by marking all the vertices white.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (Function::const_iterator I = F.begin(), IE = F.end(); I != IE; ++I) {
      ColorMap[I] = TopoSorter::WHITE;
    }

    &lt;span style="color: #007f00"&gt;// The BB graph has a single entry vertex from which the other BBs should&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;// be discoverable - the function entry block.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;bool&lt;/span&gt; success = recursiveDFSToposort(&amp;amp;F.getEntryBlock());
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (success) {
      &lt;span style="color: #007f00"&gt;// Now we have all the BBs inside SortedBBs in reverse topological order.&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (BBVector::const_reverse_iterator RI = SortedBBs.rbegin(),
                                            RE = SortedBBs.rend();
                                            RI != RE; ++RI) {
        outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; (*RI)-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
      }
    } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
      outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; Sorting failed\n&amp;quot;&lt;/span&gt;;
    }
  }
&lt;span style="color: #00007f; font-weight: bold"&gt;private&lt;/span&gt;:
  &lt;span style="color: #00007f; font-weight: bold"&gt;enum&lt;/span&gt; Color {WHITE, GREY, BLACK};
  &lt;span style="color: #007f00"&gt;// Color marks per vertex (BB).&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; DenseMap&amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BasicBlock *, Color&amp;gt; BBColorMap;
  &lt;span style="color: #007f00"&gt;// Collects vertices (BBs) in &amp;quot;finish&amp;quot; order. The first finished vertex is&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// first, and so on.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; SmallVector&amp;lt;&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BasicBlock *, &lt;span style="color: #007f7f"&gt;32&lt;/span&gt;&amp;gt; BBVector;
  BBColorMap ColorMap;
  BBVector SortedBBs;

  &lt;span style="color: #007f00"&gt;// Helper function to recursively run topological sort from a given BB.&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// Returns true if the sort succeeded and false otherwise; topological sort&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// may fail if, for example, the graph is not a DAG (detected a cycle).&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;bool&lt;/span&gt; recursiveDFSToposort(&lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; BasicBlock *BB) {
    ColorMap[BB] = TopoSorter::GREY;
    &lt;span style="color: #007f00"&gt;// For demonstration, using the lowest-level APIs here. A BB&amp;#39;s successors&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;// are determined by looking at its terminator instruction.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; TerminatorInst *TInst = BB-&amp;gt;getTerminator();
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;unsigned&lt;/span&gt; I = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;, NSucc = TInst-&amp;gt;getNumSuccessors(); I &amp;lt; NSucc; ++I) {
      BasicBlock *Succ = TInst-&amp;gt;getSuccessor(I);
      Color SuccColor = ColorMap[Succ];
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (SuccColor == TopoSorter::WHITE) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (!recursiveDFSToposort(Succ))
          &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;false&lt;/span&gt;;
      } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (SuccColor == TopoSorter::GREY) {
        &lt;span style="color: #007f00"&gt;// This detects a cycle because grey vertices are all ancestors of the&lt;/span&gt;
        &lt;span style="color: #007f00"&gt;// currently explored vertex (in other words, they&amp;#39;re &amp;quot;on the stack&amp;quot;).&lt;/span&gt;
        outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; Detected cycle: edge from &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; BB-&amp;gt;getName() &amp;lt;&amp;lt;
                  &lt;span style="color: #7f007f"&gt;&amp;quot; to &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; Succ-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;false&lt;/span&gt;;
      }
    }
    &lt;span style="color: #007f00"&gt;// This BB is finished (fully explored), so we can add it to the vector.&lt;/span&gt;
    ColorMap[BB] = TopoSorter::BLACK;
    SortedBBs.push_back(BB);
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;true&lt;/span&gt;;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[The full code that also contains the other snippets in this post is &lt;a class="reference external" href="https://github.com/eliben/llvm-clang-samples/blob/master/src/bb_toposort_sccs.cpp"&gt;available here&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;It uses the simple recursive &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Depth-first_search"&gt;DFS&lt;/a&gt; algorithm outlined in &amp;quot;Introduction to Algorithms&amp;quot; by Cormen et al. During the recursive search, vertices are marked &amp;quot;grey&amp;quot; when first encountered and &amp;quot;black&amp;quot; when they're &lt;em&gt;finished&lt;/em&gt;. A finished vertex is one whose outgoing edges have all been explored. Topological sorting is the list of all vertices sorted by finish time, from last to first (this is also called &amp;quot;reverse post-order&amp;quot;). In our specific case, a BB is a vertex and links to its successors are edges.&lt;/p&gt;
&lt;p&gt;For this CFG:&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/09/diamond-cfg.png" /&gt;
&lt;p&gt;We'll get:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Topological sort of func:
  AA
  BB
  CC
  DD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's an important caveat, however. Topological order is only defined for directed graphs without cycles (DAGs). While the basic block graph is directed, it's not necessarily cycle-free. In fact, any loop in the code translates to a cycle in the BB graph. The code above detects this and reports an error, refusing to provide a sort when a cycle is found.&lt;/p&gt;
&lt;p&gt;For example, consider this CFG with some loops in it:&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/09/loopy-cfg.png" /&gt;
&lt;p&gt;The code will now complain:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;Topological sort of func:
  Detected cycle: edge from BB4 to BB3
  Sorting failed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that we know how to do it the hard way, let's see some of the useful tools LLVM has in its coffers. The header &lt;tt class="docutils literal"&gt;llvm/ADT/PostOrderIterator.h&lt;/tt&gt; offers iterators for going over BBs inside a function in post-order traversal. Here's the complete usage snippet:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;Basic blocks of &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; in post-order:\n&amp;quot;&lt;/span&gt;;
&lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (po_iterator&amp;lt;BasicBlock *&amp;gt; I = po_begin(&amp;amp;F.getEntryBlock()),
                               IE = po_end(&amp;amp;F.getEntryBlock());
                               I != IE; ++I) {
  outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;  &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; (*I)-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall that topological sort is reverse post-order, though. So if it's really that order you need, consider the &lt;tt class="docutils literal"&gt;ReversePostOrderTraversal&lt;/tt&gt; class from the same header. Note that neither detects cycles, however. In the presence of cycles these iterators will produce some traversal, but it won't be the topological order because it's simply undefined in such cases. If you want a tool to detect cycles, there's &lt;tt class="docutils literal"&gt;FindFunctionBackedges&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;llvm/Analysis/CFG.h&lt;/tt&gt;. It essentially runs the same DFS as I showed above, though using an iterative algorithm with an explicit stack instead of the recursion.&lt;/p&gt;
&lt;p&gt;One interesting thing to note about &lt;tt class="docutils literal"&gt;po_iterator&lt;/tt&gt; and its kin is that they can be used for &lt;em&gt;any&lt;/em&gt; kind of graph, not just the graph of basic blocks. They can be used for graphs of functions in inter-procedural analysis, for nodes in an expression graph, and so on. This magic is achieved by means of the &lt;tt class="docutils literal"&gt;GraphTraits&lt;/tt&gt; mechanism (&lt;tt class="docutils literal"&gt;llvm/ADT/GraphTraits.h&lt;/tt&gt;), which lets us decouple graph representations from the actual algorithms that work on all kinds of graphs. The template specialization that makes this work for basic blocks can be found in &lt;tt class="docutils literal"&gt;llvm/Support/CFG.h&lt;/tt&gt; - in this header you can also find iterators for going over the successors (and predecessors) of BBs without manually querying the terminator instruction.&lt;/p&gt;
&lt;p&gt;Back to topological sort though. Since many interesting functions will have loops and thus cycles, what do we do about them? The answer is &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Strongly_connected_components"&gt;storngly-connected components&lt;/a&gt; (SCCs). If we identify the SCCs of the BB graph, we can topologically sort these SCCs and still do interesting analyses. A loop would usually collapse into a single SCC, for example. So how do we go about implementing this?&lt;/p&gt;
&lt;p&gt;Luckily, LLVM already has a tool to help us. The header &lt;tt class="docutils literal"&gt;llvm/ADT/SCCIterator.h&lt;/tt&gt; defines &lt;tt class="docutils literal"&gt;scc_iterator&lt;/tt&gt; which iterates over the SCCs in a graph in post-order. This lets us topologically sort the SCCs similarly to the way we'd sort BBs in a cycle-less graph. In fact, in a cycle-less graph each BB is a SCC on its own, so the SCC approach is a generalization. Using &lt;tt class="docutils literal"&gt;scc_iterator&lt;/tt&gt; is easy:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #007f00"&gt;// Use LLVM&amp;#39;s Strongly Connected Components (SCCs) iterator to produce&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// a reverse topological sort of SCCs.&lt;/span&gt;
outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;SCCs for &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot; in post-order:\n&amp;quot;&lt;/span&gt;;
&lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (scc_iterator&amp;lt;Function *&amp;gt; I = scc_begin(&amp;amp;F),
                              IE = scc_end(&amp;amp;F);
                              I != IE; ++I) {
  &lt;span style="color: #007f00"&gt;// Obtain the vector of BBs in this SCC and print it out.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; std::vector&amp;lt;BasicBlock *&amp;gt; &amp;amp;SCCBBs = *I;
  outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;  SCC: &amp;quot;&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (std::vector&amp;lt;BasicBlock *&amp;gt;::const_iterator BBI = SCCBBs.begin(),
                                                 BBIE = SCCBBs.end();
                                                 BBI != BBIE; ++BBI) {
    outs() &amp;lt;&amp;lt; (*BBI)-&amp;gt;getName() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;  &amp;quot;&lt;/span&gt;;
  }
  outs() &amp;lt;&amp;lt; &lt;span style="color: #7f007f"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the loopy CFG shown above, this code will print:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;SCCs for func in post-order:
  SCC: DD
  SCC: CC2  CC1  CC
  SCC: BB4  BB3
  SCC: BB2  BB1  BB
  SCC: AA
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[Note that this is post-order, not reverse post-order; hence the topological sort is showing in the list from the bottom up.]&lt;/p&gt;
&lt;p&gt;I hope this was a useful peek into the CFG analysis capabilities of LLVM. I've given a lot of pointers into the code and these can serve as starting points for some serious code-reading. It's pretty cool to see how many different tools LLVM has for this purpose, and especially nice to see that most of them apply to any kind of graph, thanks to the &lt;tt class="docutils literal"&gt;GraphTraits&lt;/tt&gt; mechanism.&lt;/p&gt;

    </summary><category term="Compilation"></category><category term="LLVM &amp; Clang"></category></entry><entry><title>Fixing tests by writing more tests</title><link href="http://eli.thegreenplace.net/2013/08/14/fixing-tests-by-writing-more-tests" rel="alternate"></link><updated>2013-08-14T06:01:31-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-08-14:2013/08/14/fixing-tests-by-writing-more-tests</id><summary type="html">
        &lt;p&gt;When a test fails, the first instinct is usually to dive right in - go through the code, sprinkle printouts and logging statements all around, fire up the debugger, and so on. But often, the correct approach is to write additional tests. Does this sound crazy? Well, it isn't. It's one of those true and tried techniques used by many experienced programmers.&lt;/p&gt;
&lt;p&gt;Allow me to elaborate. Tests for software fall broadly into the following categories. This taxonomy is a blunt generalization and varies considerably with software size and other characteristics. But it's not important in itself - I just use it to illustrate my point. So starting with the most specific and ending with the most general, these are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Unit tests&lt;/li&gt;
&lt;li&gt;Module-level tests&lt;/li&gt;
&lt;li&gt;Whole program tests&lt;/li&gt;
&lt;li&gt;Integration tests (with other software)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the first item (highly specific, targeted tests) on the list to the last (very general tests), coverage grows, as well as the complexity of debugging a failure. Debugging a unit test failure is usually quite easy. Integration tests can be devilishly difficult to debug, or even isolate and analyze. An unrelated component of the system may start failing intermittently when some other component (which passed all of its own tests) is changed. A compiler may start generating wrong code, but only when bootstrapped by compiling itself. It's those cases that send programmers crying to their therapist's couch.&lt;/p&gt;
&lt;p&gt;So back to my original point. I posit that a great way to debug general tests is to write additional specific tests. Your module-level tests are failing? Write more unit tests. Your integration tests are failing? Write additional whole program tests, module tests or unit tests. The more specific the new tests are, the better. Remember that the most specific tests are the easiest to debug.&lt;/p&gt;
&lt;p&gt;Debugging is all about the scientific method - you make assumptions and test them. Based on the results you make additional assumptions. Rinse. Repeat. While pondering about why something doesn't work - fortify your assumptions by writing tests for them. Facing a failing high-level test, try to write a more specific test that also fails. The benefits of this are two-fold. First, this will help you find the bug. Bugs are usually results of bad assumptions. This is especially true on the high generality level when pieces of software get integrated with others. More specific tests help verify those assumptions and are easier to debug. Second, you'll have more tests in the system when this bug-hunt ends, and that's always a good thing.&lt;/p&gt;

    </summary><category term="Programming"></category></entry><entry><title>pycparser v2.10 released</title><link href="http://eli.thegreenplace.net/2013/08/03/pycparser-v2-10-released" rel="alternate"></link><updated>2013-08-03T06:53:18-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-08-03:2013/08/03/pycparser-v2-10-released</id><summary type="html">
        &lt;p&gt;A few minutes ago I've tagged &lt;a class="reference external" href="https://github.com/eliben/pycparser"&gt;pycparser&lt;/a&gt; v2.10 and pushed the release to &lt;a class="reference external" href="https://pypi.python.org/pypi/pycparser"&gt;PyPI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The biggest feature in this release is the ability to handle even darker context-sensitive corners of C. For example, consider this snippet of C code, taken from &lt;a class="reference external" href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;my article on context sensitivity of C's grammar&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;typedef&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; AA;

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;foo&lt;/span&gt;()
{
  AA AA;
  &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; BB = AA * &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The line saying &lt;tt class="docutils literal"&gt;AA AA&lt;/tt&gt; is defining a new variable named &lt;tt class="docutils literal"&gt;AA&lt;/tt&gt; of type &lt;tt class="docutils literal"&gt;AA&lt;/tt&gt;. From that point on, within &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;, the variable shadows the type. &lt;tt class="docutils literal"&gt;pycparser&lt;/tt&gt; now parses this correctly:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;FileAST:
  Typedef &amp;lt;ext[0]&amp;gt;: name=AA, quals=[], storage=[&amp;#39;typedef&amp;#39;]
    TypeDecl &amp;lt;type&amp;gt;: declname=AA, quals=[]
      IdentifierType &amp;lt;type&amp;gt;: names=[&amp;#39;int&amp;#39;]
  FuncDef &amp;lt;ext[1]&amp;gt;:
    Decl &amp;lt;decl&amp;gt;: name=foo, quals=[], storage=[], funcspec=[]
      FuncDecl &amp;lt;type&amp;gt;:
        TypeDecl &amp;lt;type&amp;gt;: declname=foo, quals=[]
          IdentifierType &amp;lt;type&amp;gt;: names=[&amp;#39;void&amp;#39;]
    Compound &amp;lt;body&amp;gt;:
      Decl &amp;lt;block_items[0]&amp;gt;: name=AA, quals=[], storage=[], funcspec=[]
        TypeDecl &amp;lt;type&amp;gt;: declname=AA, quals=[]
          IdentifierType &amp;lt;type&amp;gt;: names=[&amp;#39;AA&amp;#39;]
      Decl &amp;lt;block_items[1]&amp;gt;: name=BB, quals=[], storage=[], funcspec=[]
        TypeDecl &amp;lt;type&amp;gt;: declname=BB, quals=[]
          IdentifierType &amp;lt;type&amp;gt;: names=[&amp;#39;int&amp;#39;]
        BinaryOp &amp;lt;init&amp;gt;: op=*
          ID &amp;lt;left&amp;gt;: name=AA
          Constant &amp;lt;right&amp;gt;: type=int, value=2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Most of the work for this change was contributed by &lt;a class="reference external" href="https://github.com/Syeberman"&gt;Sye van der Veen&lt;/a&gt; who heroically hacked pycparser's grammar rules into submission by using even more context information than was used before. As I predicted in &lt;a class="reference external" href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;that same article&lt;/a&gt;, all of this made the code somewhat less palatable and is in line with the general observation that LALR-based parsers are sorely inadequate for parsing real-life programming languages.&lt;/p&gt;
&lt;p&gt;On a positive note, this is a user-focused release. Some of the internal implementation's clarity was sacrificed to provide a better end product, which is a parser that can handle more cases in the language. I hope users find it useful.&lt;/p&gt;

    </summary><category term="Compilation"></category><category term="Python"></category></entry><entry><title>pycparser - call for testing before release</title><link href="http://eli.thegreenplace.net/2013/07/30/pycparser-call-for-testing-before-release" rel="alternate"></link><updated>2013-07-30T21:38:07-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-07-30:2013/07/30/pycparser-call-for-testing-before-release</id><summary type="html">
        The previous release of &lt;a href="https://github.com/eliben/pycparser"&gt;pycparser&lt;/a&gt; was 7 months ago, and it's time for another one. In addition to the usual collection of small fixes, this time there's actually a major feature to try out.

I finally caved in and accepted &lt;a href="https://github.com/eliben/pycparser/pull/1"&gt;a patch&lt;/a&gt; that makes &lt;code&gt;pycparser&lt;/code&gt; somewhat more resilient to a number of ugly context &lt;a href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited/"&gt;sensitivity artifacts of C&lt;/a&gt;. As expected, this made the code more complex and harder to understand (and punched a few additional holes through the leaky Yacc abstraction), but practicality beats purity - &lt;code&gt;pycparser&lt;/code&gt; is now expected to accept more corner cases and correctly parse more code. I guess I should blog about the technical details a bit. Some day...

If you're using pycparser or have used it in the past, I'd appreciate some help exercising it before I push the new release. If you find anything fishy, &lt;a href="https://github.com/eliben/pycparser/issues"&gt;please open an issue&lt;/a&gt;. 
    </summary><category term="Compilation"></category><category term="Python"></category></entry><entry><title>Displaying all argv in x64 assembly</title><link href="http://eli.thegreenplace.net/2013/07/24/displaying-all-argv-in-x64-assembly" rel="alternate"></link><updated>2013-07-24T05:53:47-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-07-24:2013/07/24/displaying-all-argv-in-x64-assembly</id><summary type="html">
        &lt;p&gt;Recently I've been doing some x64 assembly hacking, and something I had to Google a bit and collect from a few places is how to go over all command-line arguments (colloquially known as &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; from C) and do something with them.&lt;/p&gt;
&lt;p&gt;I already discussed how arguments get passed into a program &lt;a class="reference external" href="http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/"&gt;in the past&lt;/a&gt; (not the C &lt;tt class="docutils literal"&gt;main&lt;/tt&gt;, mind you, but rather the real entry point of a program - &lt;tt class="docutils literal"&gt;_start&lt;/tt&gt;), so what was left is just a small matter of implementation. Here it is, in GNU Assembly (&lt;tt class="docutils literal"&gt;gas&lt;/tt&gt;) syntax for Linux. This is pure assembly code - it does not use the C standard library or runtime at all. It demonstrates a lot of interesting concepts such as reading command-line arguments, issuing Linux system calls and string processing.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;#---------------- DATA ----------------#
    .data
    # We need buf_for_itoa to be large enough to contain a 64-bit integer.
    # endbuf_for_itoa will point to the end of buf_for_itoa and is useful
    # for passing to itoa.
    .set BUFLEN, 32
buf_for_itoa:
    .space BUFLEN, 0x0
    .set endbuf_for_itoa, buf_for_itoa + BUFLEN - 1
newline_str:
    .asciz &amp;quot;\n&amp;quot;
argc_str:
    .asciz &amp;quot;argc: &amp;quot;


#---------------- CODE ----------------#
    .globl _start
    .text
_start:
    # On entry to _start, argc is in (%rsp), argv[0] in 8(%rsp),
    # argv[1] in 16(%rsp) and so on.
    lea argc_str, %rdi
    call print_cstring

    mov (%rsp), %r12               # save argc in r12

    # Convert the argc value to a string and print it out
    mov %r12, %rdi
    lea endbuf_for_itoa, %rsi
    call itoa
    mov %rax, %rdi
    call print_cstring
    lea newline_str, %rdi
    call print_cstring

    # In a loop, pick argv[n] for 0 &amp;lt;= n &amp;lt; argc and print it out,
    # followed by a newline. r13 holds n.
    xor %r13, %r13

.L_argv_loop:
    mov 8(%rsp, %r13, 8), %rdi      # argv[n] is in (rsp + 8 + 8*n)
    call print_cstring
    lea newline_str, %rdi
    call print_cstring
    inc %r13
    cmp %r12, %r13
    jl .L_argv_loop

    # exit(0)
    mov $60, %rax
    mov $0, %rdi
    syscall
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code uses a couple of support functions. The first is &lt;tt class="docutils literal"&gt;print_cstring&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;# Function print_cstring
#   Print a null-terminated string to stdout.
# Arguments:
#   rdi     address of string
# Returns: void
print_cstring:
    # Find the terminating null
    mov %rdi, %r10
.L_find_null:
    cmpb $0, (%r10)
    je .L_end_find_null
    inc %r10
    jmp .L_find_null
.L_end_find_null:
    # r10 points to the terminating null. so r10-rdi is the length
    sub %rdi, %r10

    # Now that we have the length, we can call sys_write
    # sys_write(unsigned fd, char* buf, size_t count)
    mov $1, %rax
    # Populate address of string into rsi first, because the later
    # assignment of fd clobbers rdi.
    mov %rdi, %rsi
    mov $1, %rdi
    mov %r10, %rdx
    syscall
    ret
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;More interestingly, here is &lt;tt class="docutils literal"&gt;itoa&lt;/tt&gt;. It's a bit more general than what I actually use in the main program because it also supports negative numbers. It can convert any number that fits into a 64-bit register. Note the unusual API for receiving and returning the place where the actual string is written. Since it's very natural for an &lt;tt class="docutils literal"&gt;itoa&lt;/tt&gt; implementation to emit the digits in reverse, I wanted to avoid actual string reversing by writing the digits into a buffer from the end towards the beginning.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;# Function itoa
#   Convert an integer to a null-terminated string in memory.
#   Assumes that there is enough space allocated in the target
#   buffer for the representation of the integer. Since the number itself
#   is accepted in the register, its value is bounded.
# Arguments:
#   rdi:    the integer
#   rsi:    address of the *last* byte in the target buffer
# Returns:
#   rax:    address of the first byte in the target string that
#           contains valid information.
itoa:
    movb $0, (%rsi)        # Write the terminating null and advance.

    # If the input number is negative, we mark it by placing 1 into r9
    # and negate it. In the end we check if r9 is 1 and add a &amp;#39;-&amp;#39; in front.
    mov $0, %r9
    cmp $0, %rdi
    jge .L_input_positive
    neg %rdi
    mov $1, %r9
.L_input_positive:

    mov %rdi, %rax          # Place the number into rax for the division.
    mov $10, %r8            # The base is in r8

.L_next_digit:
    # Prepare rdx:rax for division by clearing rdx. rax remains from the
    # previous div. rax will be rax / 10, rdx will be the next digit to
    # write out.
    xor %rdx, %rdx
    div %r8
    # Write the digit to the buffer, in ascii
    dec %rsi
    add $0x30, %dl
    movb %dl, (%rsi)

    cmp $0, %rax            # We&amp;#39;re done when the quotient is 0.
    jne .L_next_digit

    # If we marked in r9 that the input is negative, it&amp;#39;s time to add that
    # &amp;#39;-&amp;#39; in front of the output.
    cmp $1, %r9
    jne .L_itoa_done
    dec %rsi
    movb $0x2d, (%rsi)

.L_itoa_done:
    mov %rsi, %rax          # rsi points to the first byte now; return it.
    ret
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some notes about the code:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;GAS vs. Intel syntax: I used to believe the Intel syntax is better looking, but grew to tolerate GAS because it's the default used by tools on Linux. After a very short time you get used to it and don't really mind it any longer. Yes, even the weird indirect addressing syntax (&lt;tt class="docutils literal"&gt;mov &lt;span class="pre"&gt;8(%rsp,&lt;/span&gt; %r13, 8), %rdi&lt;/tt&gt;) grows on you. In other words, focus on the code, not syntax.&lt;/li&gt;
&lt;li&gt;I could pick any representation for strings, but ended up going with the C-like null-terminated strings. If you look carefully at &lt;tt class="docutils literal"&gt;print_cstring&lt;/tt&gt; you'll notice that a length-prefix representation could be better since the &lt;tt class="docutils literal"&gt;write&lt;/tt&gt; system call doesn't care about the null and wants the length passed explicitly. However, since real life assembly code often does have to inter-operate with C, null-terminated strings make more sense.&lt;/li&gt;
&lt;li&gt;Even though my own functions could use any calling convention, I'm sticking with the System V AMD64 ABI. It's natural because system calls use it as well w.r.t. argument and return value passing. AFAIU they can also clobber scratch registers so care must be taken to preserve information in registers around system calls.&lt;/li&gt;
&lt;/ul&gt;

    </summary><category term="Assembly"></category></entry><entry><title>Hand-written lexer in Javascript compared to the regex-based ones</title><link href="http://eli.thegreenplace.net/2013/07/16/hand-written-lexer-in-javascript-compared-to-the-regex-based-ones" rel="alternate"></link><updated>2013-07-16T06:25:10-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-07-16:2013/07/16/hand-written-lexer-in-javascript-compared-to-the-regex-based-ones</id><summary type="html">
        &lt;p&gt;A &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/06/25/regex-based-lexical-analysis-in-python-and-javascript/"&gt;few weeks ago I wrote&lt;/a&gt; about the comparison between regex-based lexers in Python and Javascript. Javascript running on Node.js (V8) ended up being much faster than Python, and in both languages a speed improvement could be gained by switching to a single regex and letting the regex engine do the hard work.&lt;/p&gt;
&lt;p&gt;However, in the real world you'll find that most lexers (particularly lexers for real programming languages) are not written that way. They are carefully hand-written to go over the input and dispatch to the appropriate token handling code depending on the first character encountered.&lt;/p&gt;
&lt;p&gt;This technique makes more sense for complex languages because it's much more flexible than regexes (for instance, representing nested comments with regexes is a big challenge). But I was curious also about its performance implications.&lt;/p&gt;
&lt;p&gt;So I hacked together a hand-written lexer for exactly the same language used in the previous benchmark and also exercised it on the same large file to make sure the results are correct. Its runtime, however, surprised me. Here's the runtime of lexing a large-ish document (smaller is better):&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/07/lexer_runtime_vs_handwritten.png" /&gt;
&lt;p&gt;I was expecting the runtime to be much closer to the single-regex version; in fact I was expecting it to be a bit slower (because most of the regex engine work is done at a lower level). But it turned out to be much faster, more than 2.5x. Another case of the real world beating intuition.&lt;/p&gt;
&lt;p&gt;I was lazy to look, but if V8's regex implementation is anything like Python's, then alternation of many options (&lt;tt class="docutils literal"&gt;foo|bar&lt;/tt&gt;) is not as efficient as one might expect because the regex engine does not use real DFAs, but rather backtracking. So alternation essentially means iteration deep in the regex engine. On the other hand, the hand-written code seems like something quite optimizable by a JIT compiler like V8 (the types are simple and consistent) so there's a good chance it got converted into tight machine code. Throw some inlining in and the speed is not very unlikely.&lt;/p&gt;
&lt;p&gt;Anyway, here is the hand-written lexer. It's significantly more code than the regex-based ones, but I can't say it was particularly difficult to write - the main part took a bit more than an hour, or so. If you have any additional ideas about the speed difference, I'll be happy to hear about them.&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #7f007f"&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;;

&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; Lexer = exports.Lexer = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf = &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buflen = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;

  &lt;span style="color: #007f00"&gt;// Operator table, mapping operator -&amp;gt; token name&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.optable = {
    &lt;span style="color: #7f007f"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;PLUS&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;MINUS&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;MULTIPLY&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;PERIOD&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;\\&amp;#39;&lt;/span&gt;: &lt;span style="color: #7f007f"&gt;&amp;#39;BACKSLASH&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;COLON&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;%&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;PERCENT&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;PIPE&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;!&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;EXCLAMATION&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;?&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;QUESTION&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;POUND&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;amp;&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;AMPERSAND&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;;&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;SEMI&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;COMMA&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;L_PAREN&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;R_PAREN&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;L_ANG&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;R_ANG&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;{&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;L_BRACE&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;}&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;R_BRACE&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;[&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;L_BRACKET&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;]&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;R_BRACKET&amp;#39;&lt;/span&gt;,
    &lt;span style="color: #7f007f"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;:  &lt;span style="color: #7f007f"&gt;&amp;#39;EQUALS&amp;#39;&lt;/span&gt;
  };
}

&lt;span style="color: #007f00"&gt;// Initialize the Lexer&amp;#39;s buffer. This resets the lexer&amp;#39;s internal&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// state and subsequent tokens will be returned starting with the&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// beginning of the new buffer.&lt;/span&gt;
Lexer.prototype.input = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(buf) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf = buf;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buflen = buf.length;
}

&lt;span style="color: #007f00"&gt;// Get the next token from the current buffer. A token is an object with&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// the following properties:&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - name: name of the pattern that this token matched (taken from rules).&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - value: actual string value of the token.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - pos: offset in the current buffer where the token starts.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;//&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// If there are no more tokens in the buffer, returns null. In case of&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// an error throws Error.&lt;/span&gt;
Lexer.prototype.token = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;._skipnontokens();
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos &amp;gt;= &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buflen) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
  }

  &lt;span style="color: #007f00"&gt;// The char at this.pos is part of a real token. Figure out which.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; c = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.charAt(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos);

  &lt;span style="color: #007f00"&gt;// &amp;#39;/&amp;#39; is treated specially, because it starts a comment if followed by&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// another &amp;#39;/&amp;#39;. If not followed by another &amp;#39;/&amp;#39;, it&amp;#39;s the DIVIDE&lt;/span&gt;
  &lt;span style="color: #007f00"&gt;// operator.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (c === &lt;span style="color: #7f007f"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; next_c = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.charAt(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (next_c === &lt;span style="color: #7f007f"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;._process_comment();
    } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; {name: &lt;span style="color: #7f007f"&gt;&amp;#39;DIVIDE&amp;#39;&lt;/span&gt;, value: &lt;span style="color: #7f007f"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, pos: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos++};
    }
  } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
    &lt;span style="color: #007f00"&gt;// Look it up in the table of operators&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; op = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.optable[c];
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (op !== &lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; {name: op, value: c, pos: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos++};
    } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
      &lt;span style="color: #007f00"&gt;// Not an operator - so it&amp;#39;s the beginning of another token.&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (Lexer._isalpha(c)) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;._process_identifier();
      } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (Lexer._isdigit(c)) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;._process_number();
      } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (c === &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;._process_quote();
      } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
        &lt;span style="color: #00007f; font-weight: bold"&gt;throw&lt;/span&gt; &lt;span style="color: #00007f"&gt;Error&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;Token error at &amp;#39;&lt;/span&gt; + &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos);
      }
    }
  }
}

Lexer._isnewline = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(c) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; c === &lt;span style="color: #7f007f"&gt;&amp;#39;\r&amp;#39;&lt;/span&gt; || c === &lt;span style="color: #7f007f"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
}

Lexer._isdigit = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(c) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; c &amp;gt;= &lt;span style="color: #7f007f"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; c &amp;lt;= &lt;span style="color: #7f007f"&gt;&amp;#39;9&amp;#39;&lt;/span&gt;;
}

Lexer._isalpha = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(c) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; (c &amp;gt;= &lt;span style="color: #7f007f"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; c &amp;lt;= &lt;span style="color: #7f007f"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;) ||
         (c &amp;gt;= &lt;span style="color: #7f007f"&gt;&amp;#39;A&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; c &amp;lt;= &lt;span style="color: #7f007f"&gt;&amp;#39;Z&amp;#39;&lt;/span&gt;) ||
         c === &lt;span style="color: #7f007f"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; || c === &lt;span style="color: #7f007f"&gt;&amp;#39;$&amp;#39;&lt;/span&gt;;
}

Lexer._isalphanum = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(c) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; (c &amp;gt;= &lt;span style="color: #7f007f"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; c &amp;lt;= &lt;span style="color: #7f007f"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;) ||
         (c &amp;gt;= &lt;span style="color: #7f007f"&gt;&amp;#39;A&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; c &amp;lt;= &lt;span style="color: #7f007f"&gt;&amp;#39;Z&amp;#39;&lt;/span&gt;) ||
         (c &amp;gt;= &lt;span style="color: #7f007f"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; c &amp;lt;= &lt;span style="color: #7f007f"&gt;&amp;#39;9&amp;#39;&lt;/span&gt;) ||
         c === &lt;span style="color: #7f007f"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; || c === &lt;span style="color: #7f007f"&gt;&amp;#39;$&amp;#39;&lt;/span&gt;;
}

Lexer.prototype._process_number = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; endpos = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; (endpos &amp;lt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buflen &amp;amp;&amp;amp;
         Lexer._isdigit(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.charAt(endpos))) {
    endpos++;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; tok = {
    name: &lt;span style="color: #7f007f"&gt;&amp;#39;NUMBER&amp;#39;&lt;/span&gt;,
    value: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.substring(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos, endpos),
    pos: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos
  };
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = endpos;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; tok;
}

Lexer.prototype._process_comment = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; endpos = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos + &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;
  &lt;span style="color: #007f00"&gt;// Skip until the end of the line&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; c = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.charAt(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos + &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;);
  &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; (endpos &amp;lt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buflen &amp;amp;&amp;amp;
         !Lexer._isnewline(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.charAt(endpos))) {
    endpos++;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; tok = {
    name: &lt;span style="color: #7f007f"&gt;&amp;#39;COMMENT&amp;#39;&lt;/span&gt;,
    value: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.substring(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos, endpos),
    pos: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos
  };
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = endpos + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; tok;
}

Lexer.prototype._process_identifier = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; endpos = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; (endpos &amp;lt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buflen &amp;amp;&amp;amp;
         Lexer._isalphanum(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.charAt(endpos))) {
    endpos++;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; tok = {
    name: &lt;span style="color: #7f007f"&gt;&amp;#39;IDENTIFIER&amp;#39;&lt;/span&gt;,
    value: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.substring(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos, endpos),
    pos: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos
  };
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = endpos;
  &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; tok;
}

Lexer.prototype._process_quote = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #007f00"&gt;// this.pos points at the opening quote. Find the ending quote.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; end_index = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.indexOf(&lt;span style="color: #7f007f"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;, &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;);

  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (end_index === -&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;throw&lt;/span&gt; &lt;span style="color: #00007f"&gt;Error&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;Unterminated quote at &amp;#39;&lt;/span&gt; + &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos);
  } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; tok = {
      name: &lt;span style="color: #7f007f"&gt;&amp;#39;QUOTE&amp;#39;&lt;/span&gt;,
      value: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.substring(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos, end_index + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;),
      pos: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos
    };
    &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = end_index + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;;
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; tok;
  }
}

Lexer.prototype._skipnontokens = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos &amp;lt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buflen) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; c = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.charAt(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (c == &lt;span style="color: #7f007f"&gt;&amp;#39; &amp;#39;&lt;/span&gt; || c == &lt;span style="color: #7f007f"&gt;&amp;#39;\t&amp;#39;&lt;/span&gt; || c == &lt;span style="color: #7f007f"&gt;&amp;#39;\r&amp;#39;&lt;/span&gt; || c == &lt;span style="color: #7f007f"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos++;
    } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
      &lt;span style="color: #00007f; font-weight: bold"&gt;break&lt;/span&gt;;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;

    </summary><category term="Compilation"></category><category term="Javascript"></category></entry><entry><title>Library order in static linking</title><link href="http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking" rel="alternate"></link><updated>2013-07-09T05:56:27-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-07-09:2013/07/09/library-order-in-static-linking</id><summary type="html">
        &lt;p&gt;I'll start with a slightly sneaky but educational example. Suppose we have this code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;volatile&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt; src[] = {&lt;span style="color: #007f7f"&gt;1&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;3&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;4&lt;/span&gt;, &lt;span style="color: #007f7f"&gt;5&lt;/span&gt;};
&lt;span style="color: #00007f; font-weight: bold"&gt;volatile&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt; dst[&lt;span style="color: #007f7f"&gt;50&lt;/span&gt;] = {&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;};

&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* memcpy(&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* dst, &lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt;* src, &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; len);

&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;main&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; argc, &lt;span style="color: #00007f; font-weight: bold"&gt;const&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt;* argv[])
{
    memcpy(dst, src, &lt;span style="color: #00007f; font-weight: bold"&gt;sizeof&lt;/span&gt;(src) / &lt;span style="color: #00007f; font-weight: bold"&gt;sizeof&lt;/span&gt;(src[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;]));
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; dst[&lt;span style="color: #007f7f"&gt;4&lt;/span&gt;];
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It runs just fine and the return value is 5. Now, suppose this is part of a larger project that consists of many object files and libraries, and somewhere within the project there's a library that contains this code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00007f"&gt;memcpy&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt;* aa, &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt;* bb, &lt;span style="color: #00007f; font-weight: bold"&gt;char&lt;/span&gt;* cc) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; i;
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style="color: #007f7f"&gt;100&lt;/span&gt;; ++i) {
        cc[i] = aa[i] + bb[i];
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If the previous snippet gets linked with this library, what happens? Would you expect it to still return 5? Return something else? Crash? The answer is: it depends - the result can be either correct or a segmentation fault. It depends on the order in which the objects and libraries in the project were fed to the linker.&lt;/p&gt;
&lt;p&gt;If you fully understand why this depends on linking order, as well as how to avoid the problem (and more serious problems, like circular dependencies) then congratulate yourself and move on - this article is probably not for you. Otherwise, read on.&lt;/p&gt;
&lt;div class="section" id="the-basics"&gt;
&lt;h3&gt;The basics&lt;/h3&gt;
&lt;p&gt;Let's start by defining the scope of this article: first, my examples are demonstrating the use of the gcc and binutils toolchain on Linux. Compatible toolchains (like clang instead of gcc) apply too. Second, the discussion here resolves around &lt;em&gt;static&lt;/em&gt; linking that's done at compile/link time.&lt;/p&gt;
&lt;p&gt;To understand why linking order matters, it's first instructional to understand how the linker works with respect to linking libraries and objects together. Just as a quick reminder - an object file both &lt;em&gt;provides&lt;/em&gt; (exports) external symbols &lt;em&gt;to&lt;/em&gt; other objects and libraries, and &lt;em&gt;expects&lt;/em&gt; (imports) symbols &lt;em&gt;from&lt;/em&gt; other objects and libraries. For example, in this C code:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; imported(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt;);

&lt;span style="color: #00007f; font-weight: bold"&gt;static&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;internal&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; x) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; x * &lt;span style="color: #007f7f"&gt;2&lt;/span&gt;;
}

&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #00007f"&gt;exported&lt;/span&gt;(&lt;span style="color: #00007f; font-weight: bold"&gt;int&lt;/span&gt; x) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; imported(x) * internal(x);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The names of the functions speak for themselves. Let's compile it and look at the symbol table:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc -c x.c
$ nm x.o
000000000000000e T exported
                 U imported
0000000000000000 t internal
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means: &lt;tt class="docutils literal"&gt;exported&lt;/tt&gt; is an external symbol - defined in the object file and visible from the outside. &lt;tt class="docutils literal"&gt;imported&lt;/tt&gt; is an undefined symbol; in other words, the linker is expected to find it elsewhere. When we talk about linking later, the term &lt;em&gt;undefined&lt;/em&gt; can become confusing - so it helps to remember that this is where it comes from originally. &lt;tt class="docutils literal"&gt;internal&lt;/tt&gt; is defined within the object but invisible from the outside.&lt;/p&gt;
&lt;p&gt;Now, a &lt;em&gt;library&lt;/em&gt; is simply a collection of object files. Just a bunch of object files glued together. Creating a library is a very trivial operation that doesn't do anything special besides placing many object files into the same file. This in itself is important, because a horde of object files is not convenient to deal with. For example, on my system &lt;tt class="docutils literal"&gt;libc.a&lt;/tt&gt; (the static version of the C library) consists of almost 1500 object files. It's way nicer to just carry &lt;tt class="docutils literal"&gt;libc.a&lt;/tt&gt; around.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-linking-process"&gt;
&lt;h3&gt;The linking process&lt;/h3&gt;
&lt;p&gt;This section defines the linking process in a somewhat dry, algorithmic manner. This process is the key to understanding why linking order matters.&lt;/p&gt;
&lt;p&gt;Consider a linker invocation:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc main.o -L/some/lib/dir -lfoo -lbar -lbaz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The linker is almost always invoked through the compiler driver &lt;tt class="docutils literal"&gt;gcc&lt;/tt&gt; when compiling C or C++ code. This is because the driver knows how to provide the correct command-line arguments to the linker itself (&lt;tt class="docutils literal"&gt;ld&lt;/tt&gt;) with all the support libraries, etc. We'll see more of this later.&lt;/p&gt;
&lt;p&gt;Anyhow, as you can see the object files and libraries are provided in a certain order on the command-line, from left to right. This is the linking order. Here's what the linker does:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The linker maintains a &lt;em&gt;symbol table&lt;/em&gt;. This symbol table does a bunch of things, but among them is keeping two lists:&lt;ul&gt;
&lt;li&gt;A list of symbols exported by all the objects and libraries encountered so far.&lt;/li&gt;
&lt;li&gt;A list of undefined symbols that the encountered objects and libraries requested to import and were not found yet.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When the linker encounters a new object file, it looks at:&lt;ul&gt;
&lt;li&gt;The symbols it exports: these are added to the list of exported symbols mentioned above. If any symbol is in the undefined list, it's removed from there because it has now been found. If any symbol has already been in the exported list, we get a &amp;quot;multiple definition&amp;quot; error: two different objects export the same symbol and the linker is confused.&lt;/li&gt;
&lt;li&gt;The symbols it imports: these are added to the list of undefined symbols, unless they can be found in the list of exported symbols.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When the linker encounters a new library, things are a bit more interesting. The linker goes over all the objects in the library. For each one, it first looks at the symbols it exports.&lt;ul&gt;
&lt;li&gt;If any of the symbols it exports are on the undefined list, the object is added to the link and the next step is executed. Otherwise, the next step is skipped.&lt;/li&gt;
&lt;li&gt;If the object has been added to the link, it's treated as described above - its undefined and exported symbols get added to the symbol table.&lt;/li&gt;
&lt;li&gt;Finally, if &lt;em&gt;any&lt;/em&gt; of the objects in the library has been included in the link, the library is rescanned again - it's possible that symbols imported by the included object can be found in other objects within the same library.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When the linker finishes, it looks at the symbol table. If any symbols remain in the undefined list, the linker will throw an &amp;quot;undefined reference&amp;quot; error. For example, when you create an executable and forget to include the file with the &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; function, you'll get something like:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;/usr/lib/x86_64-linux-gnu/crt1.o: In function &amp;#39;_start&amp;#39;:
(.text+0x20): undefined reference to &amp;#39;main&amp;#39;
collect2: ld returned 1 exit status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that after the linker has looked at a library, it won't look at it again. Even if it exports symbols that may be needed by some later library. The only time where a linker goes back to rescan objects it has already seen happens within a single library - as mentioned above, once an object from some library is taken into the link, all other objects in the same library will be rescanned. Flags passed to the linker can tweak this process - again, we'll see some examples later.&lt;/p&gt;
&lt;p&gt;Also note that when a library is examined, an object file within it can be left out of the link if it does not provide symbols that the symbol table needs. This is a very important feature of static linking. The C library I mentioned before makes a heavy use of this feature, by mostly splitting itself to an-object-per-function. So, for example if the only C standard library function your code uses is &lt;tt class="docutils literal"&gt;strlen&lt;/tt&gt;, only &lt;tt class="docutils literal"&gt;strlen.o&lt;/tt&gt; will be taken into the link from &lt;tt class="docutils literal"&gt;libc.a&lt;/tt&gt; - and your executable will be very small.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-examples"&gt;
&lt;h3&gt;Simple examples&lt;/h3&gt;
&lt;p&gt;The previous section can be hard to digest, so here are some simple examples that show the process in action.&lt;/p&gt;
&lt;p&gt;Let's start with the most basic case, of linking two objects together:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ cat simplefunc.c
int func(int i) {
    return i + 21;
}

$ cat simplemain.c
int func(int);

int main(int argc, const char* argv[])
{
    return func(argc);
}

$ gcc -c simplefunc.c
$ gcc -c simplemain.c
$ gcc simplefunc.o simplemain.o
$ ./a.out ; echo $?
22
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Everything links and works as expected. Note that since these are object files, the linking order does not matter. Object files are always taken into the link. We can pass them to the linker in reversed order and it still works:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc simplemain.o simplefunc.o
$ ./a.out ; echo $?
22
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's do something different. Let's put &lt;tt class="docutils literal"&gt;simplefunc.c&lt;/tt&gt; into a library:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ ar r libsimplefunc.a simplefunc.o
$ ranlib libsimplefunc.a
$ gcc  simplemain.o -L. -lsimplefunc
$ ./a.out ; echo $?
22
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Works like a charm. But note what happens if the linking order is reversed now:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  -L. -lsimplefunc  simplemain.o
simplemain.o: In function &amp;#39;main&amp;#39;:
simplemain.c:(.text+0x15): undefined reference to &amp;#39;func&amp;#39;
collect2: ld returned 1 exit status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Understanding the linking algorithm outlined above makes this case simple to explain. When the linker encounters &lt;tt class="docutils literal"&gt;libsimplefunc.a&lt;/tt&gt;, it still hasn't seen &lt;tt class="docutils literal"&gt;simplemain.o&lt;/tt&gt;, which means that &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; is not yet on the undefined list. When the linker looks into the library it sees &lt;tt class="docutils literal"&gt;simplefunc.o&lt;/tt&gt; that exports &lt;tt class="docutils literal"&gt;func&lt;/tt&gt;. But since it doesn't need &lt;tt class="docutils literal"&gt;func&lt;/tt&gt;, this object file is not included in the link. When the linker does reach &lt;tt class="docutils literal"&gt;simplemain.o&lt;/tt&gt; and sees that &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; is, indeed required, it's added to the undefined list (because it's not on the exported list). The linker then reaches the end of the link and &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; is still undefined.&lt;/p&gt;
&lt;p&gt;Note how this doesn't happen in the previous linking order - since &lt;tt class="docutils literal"&gt;simplemain.o&lt;/tt&gt; comes first, &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; is on the undefined list &lt;em&gt;before&lt;/em&gt; the linker sees the library, so the object file exporting it does get included.&lt;/p&gt;
&lt;p&gt;This brings us to the most important corollary of the linking process outlined above:&lt;/p&gt;
&lt;blockquote&gt;
If object or library AA needs a symbol from library BB, then AA should come &lt;em&gt;before&lt;/em&gt; library BB in the command-line invocation of the linker.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="circular-dependency"&gt;
&lt;h3&gt;Circular dependency&lt;/h3&gt;
&lt;p&gt;The corollary above is an important summary of the linking process - it's certainly much more practical to keep in mind because it's so short. But it makes one wonder - what happens if AA needs a symbol from BB, but BB also needs a symbol from AA? While officially this isn't a good programming practice, in reality it happens quite a lot. But AA can't come both before and after BB on the command-line, right? That's just silly. Wait, is it, really?&lt;/p&gt;
&lt;p&gt;Let's see an example and start simple. Imagine that instead of &lt;tt class="docutils literal"&gt;simplefunc.c&lt;/tt&gt;, the &lt;tt class="docutils literal"&gt;func&lt;/tt&gt; symbol is provided thus:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ cat func_dep.c
int bar(int);

int func(int i) {
    return bar(i + 1);
}
$ cat bar_dep.c
int func(int);

int bar(int i) {
    if (i &amp;gt; 3)
        return i;
    else
        return func(i);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These two files depend on each other and get placed into different libraries. If we link them in one order, we fail:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  simplemain.o -L.  -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function &amp;#39;func&amp;#39;:
func_dep.c:(.text+0x14): undefined reference to &amp;#39;bar&amp;#39;
collect2: ld returned 1 exit status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, the other order does work:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  simplemain.o -L. -lfunc_dep -lbar_dep
$ ./a.out ; echo $?
4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Quiz: can you figure out why? Hint: just go over the linking process algorithm with this command-line. What undefined symbols does the symbol table contain when the linker first sees &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-lfunc_dep&lt;/span&gt;&lt;/tt&gt;?&lt;/p&gt;
&lt;p&gt;But this is a very simple case. Let's look at a trickier one. We'll add a dependency to &lt;tt class="docutils literal"&gt;bar&lt;/tt&gt; on another function from &lt;tt class="docutils literal"&gt;libfunc_dep.a&lt;/tt&gt;, but one that lives in a different object:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ cat bar_dep.c
int func(int);
int frodo(int);

int bar(int i) {
    if (i &amp;gt; 3)
        return frodo(i);
    else
        return func(i);
}

$ cat frodo_dep.c
int frodo(int i) {
    return 6 * i;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We'll recompile all these files into separate objects, and the &lt;tt class="docutils literal"&gt;libfunc_dep.a&lt;/tt&gt; library will now be:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ ar r libfunc_dep.a func_dep.o frodo_dep.o
$ ranlib libfunc_dep.a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's a drawing of the libraries, with arrows showing the dependencies:&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/07/circdep2.png" /&gt;
&lt;p&gt;Now linking fails no matter what order we list the libraries in:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep
./libbar_dep.a(bar_dep.o): In function &amp;#39;bar&amp;#39;:
bar_dep.c:(.text+0x17): undefined reference to &amp;#39;frodo&amp;#39;
collect2: ld returned 1 exit status
$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function &amp;#39;func&amp;#39;:
func_dep.c:(.text+0x14): undefined reference to &amp;#39;bar&amp;#39;
collect2: ld returned 1 exit status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To solve this, consider that it's perfectly valid to list a library more than once on the link linke; so in fact, we can provide &lt;tt class="docutils literal"&gt;libfunc_dep.a&lt;/tt&gt; both before and after &lt;tt class="docutils literal"&gt;libbar_dep.a&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another quiz: will the same trick work providing &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-lbar_dep&lt;/span&gt;&lt;/tt&gt; twice? Why not?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-linker-flags-to-control-the-process"&gt;
&lt;h3&gt;Using linker flags to control the process&lt;/h3&gt;
&lt;p&gt;As I've mentioned above, the linker has a number of interesting flags that can be used to control the process in a fine-grained manner. For example, circular dependency problems can be easily resolved with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--start-group&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--end-group&lt;/span&gt;&lt;/tt&gt;. Here's an instructive portion from &lt;tt class="docutils literal"&gt;man ld&lt;/tt&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;--start-group archives --end-group&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The specified archives are searched repeatedly until no new undefined references are created.  Normally, an archive is searched only once in the order that it is specified on the command line.  If a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an archive that appears later on the command line, the linker would not be able to resolve that reference.  By grouping the archives, they all be searched repeatedly until all possible references are resolved.&lt;/p&gt;
&lt;p&gt;Using this option has a significant performance cost.  It is best to use it only when there are unavoidable circular references between two or more archives.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here's how this helps in our case:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc simplemain.o -L. -Wl,--start-group -lbar_dep -lfunc_dep -Wl,--end-group
$ ./a.out ; echo $?
24
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's interesting to note the &amp;quot;significant performance cost&amp;quot; warning in the excerpt above. This explains &lt;em&gt;why&lt;/em&gt; the linking process is the way it is. Presumably, linkers could just re-scan the whole library list until no new symbols got resolved. This would eliminate most circular-dependency and linking order problems in the world, but it would also be slow. Linking is already a critical part of the compilation time of large systems, since it looks at the whole program and requires quite a bit of memory. It's better to make it as fast as possible for well-behaved programs (that got their linking order right), and provide special options like groups for the difficult circular dependency cases.&lt;/p&gt;
&lt;p&gt;There's at least one another linker flag that can help us resolve the circular dependency here. We can use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--undefined&lt;/span&gt;&lt;/tt&gt; flag to tell the linker - &amp;quot;buddy, here's a symbol I want you to add to the undefined list&amp;quot;. In our case this makes the link error go away even though the libraries are specified only once:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc simplemain.o -L. -Wl,--undefined=bar -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Figuring out why this works is left as an exercise to the reader.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="back-to-the-original-example"&gt;
&lt;h3&gt;Back to the original example&lt;/h3&gt;
&lt;p&gt;Let's go back to the example this article started with. &lt;tt class="docutils literal"&gt;main&lt;/tt&gt; assumes it gets the correct &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt; from the C library, but the &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt; it gets linked with does something else. Assuming the &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt; here was packed into the &lt;tt class="docutils literal"&gt;libstray_memcpy.a&lt;/tt&gt; library:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  -L. main_using_memcpy.o -lstray_memcpy
$ ./a.out
Segmentation fault (core dumped)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the expected behavior. Since &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-lstray_memcpy&lt;/span&gt;&lt;/tt&gt; was provided after &lt;tt class="docutils literal"&gt;main_using_memcpy.o&lt;/tt&gt; on the command-line, it gets linked in. But what happens if the order is reversed:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  -L. -lstray_memcpy main_using_memcpy.o
$ ./a.out ; echo $?
5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The program links and works correctly. The reason for this is simple: even without us explicitly asking for it, gcc asks the linker to link the C library as well. The full linker invocation command of gcc is pretty complex, and can be examined by passing the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-###&lt;/span&gt;&lt;/tt&gt; flag to gcc. But in our case this amounts to:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;$ gcc  -L. -lstray_memcpy main_using_memcpy.o -lc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the linker sees &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-lstray_memcpy&lt;/span&gt;&lt;/tt&gt;, the symbol table does not yet have an undefined entry for &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt;, so the object file with the wrong function does not get linked. The linker adds this undefined entry only after it sees &lt;tt class="docutils literal"&gt;main_using_memcpy.o&lt;/tt&gt;. Then, when it reaches &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-lc&lt;/span&gt;&lt;/tt&gt;, the object file holding &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt; from the C library &lt;em&gt;does&lt;/em&gt; get linked in because by now &lt;tt class="docutils literal"&gt;memcpy&lt;/tt&gt; is on the undefined list.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The algorithm used by the linker to resolve symbols between objects and libraries is pretty simple. As long as you keep it in mind, linker errors and related problems should be easy to understand. If you still run into problematic situations you're not sure how to resolve, this article mentioned two tools that can be very useful in debugging such problems: one is &lt;tt class="docutils literal"&gt;nm&lt;/tt&gt;, which shows the symbol table of an object or a whole library. The other is the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-###&lt;/span&gt;&lt;/tt&gt; flag that gcc accepts and as a result shows the full commands it passes to the underlying tools.&lt;/p&gt;
&lt;/div&gt;

    </summary><category term="Articles"></category><category term="Linkers and loaders"></category></entry><entry><title>Summary of reading: April - June 2013</title><link href="http://eli.thegreenplace.net/2013/07/02/summary-of-reading-april-june-2013" rel="alternate"></link><updated>2013-07-02T05:47:10-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-07-02:2013/07/02/summary-of-reading-april-june-2013</id><summary type="html">
        &lt;ul class="simple"&gt;
&lt;li&gt;Roughing It&amp;quot; by Mark Twain - a kind of a &amp;quot;travel log&amp;quot; of the author's years spent in Nevada, California and Hawaii in the 1860s. While reading the book I actually had to look up &amp;quot;high tale&amp;quot; in a dictionary - I've never seen such a concentration of obvious exaggerations before; I suppose it has gone out of style in the last 100+ years of literature, and I'm happy - it's really distracting. This makes the book less than great, though it's still a very interesting read - the accounts of life in the 19th century &amp;quot;West&amp;quot; are fascinating. Amid the jokes, Twain provides detailed and interesting historical background on such topics as the Mormons, the gold/silver rush and the early days of Hawaii as an American territory.&lt;/li&gt;
&lt;li&gt;&amp;quot;The Architecture of Open Source Applications, Volume 1&amp;quot; - descriptions of the architecture of 25 open-source projects, from known ones like Mercurial, LLVM and Sendmail to some small and obscure ones (perhaps well known only in small circles). The idea is great, and the book could be great, if only the quality of the chapters was uniformly good. But as each chapter had a completely different set of authors, the quality naturally varies a lot. Some chapters are fascinating, and some are unreadable. Overall I liked the book, however, and I may read the second volume at some point.&lt;/li&gt;
&lt;li&gt;&amp;quot;Eloquent JavaScript&amp;quot; by Marihn Haverbeke - a readable, short and dense introduction to JavaScript. I doubt that folks new to programming can learn much from it, but for someone with experience in other languages it's just right. At less than 200 pages (~150 for just the core JavaScript parts) it can be consumed very quickly. It's a shame it only covers ES3 and not ES5, but that's not too bad. Reading it also emphasizes just how quirky JavaScript is. Even though the author is naturally quite fond of the language (it seems to be his main go-to tool and he did write a book about it...), he can't help himself but mention how this or that feature is badly designed, confusing and shouldn't be used.&lt;/li&gt;
&lt;li&gt;&amp;quot;A Winter's Tale&amp;quot; by Stephen King - a rather weird short book. Feels like a creepy experiment for a story-within-a-story writing.&lt;/li&gt;
&lt;li&gt;&amp;quot;The Body&amp;quot; by Stephen King - an entertaining book about a group of teenagers going on a weird trip to look at the body of a dead kid some tens of miles away from their town. The writing is good, but not great - though I must admit the author certainly has a lot of creativity to tap into.&lt;/li&gt;
&lt;/ul&gt;
    </summary><category term="Book reviews"></category></entry><entry><title>Regex-based lexical analysis in Python and Javascript</title><link href="http://eli.thegreenplace.net/2013/06/25/regex-based-lexical-analysis-in-python-and-javascript" rel="alternate"></link><updated>2013-06-25T05:36:06-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-06-25:2013/06/25/regex-based-lexical-analysis-in-python-and-javascript</id><summary type="html">
        &lt;p&gt;When I need a lexical analyzer, usually the first tool I turn to is a simple regex-based lexer I've been using for a few years now. Here is the most straightforward version, in Python. First, a couple of supporting classes:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; A simple Token structure. Token type, value and position.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, &lt;span style="color: #00007f"&gt;type&lt;/span&gt;, val, pos):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.type = &lt;span style="color: #00007f"&gt;type&lt;/span&gt;
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.val = val
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos = pos

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__str__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #7f007f"&gt;&amp;#39;%s(%s) at %s&amp;#39;&lt;/span&gt; % (&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.type, &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.val, &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)


&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;LexerError&lt;/span&gt;(Exception):
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, pos):
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos = pos
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, the lexer itself:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00007f"&gt;Lexer&lt;/span&gt;(&lt;span style="color: #00007f"&gt;object&lt;/span&gt;):
    &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; A simple regex-based lexer/tokenizer.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, rules, skip_whitespace=&lt;span style="color: #00007f"&gt;True&lt;/span&gt;):
        &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Create a lexer.&lt;/span&gt;

&lt;span style="color: #7f007f"&gt;            rules:&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                A list of rules. Each rule is a `&lt;code&gt;regex, type&lt;/code&gt;`&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                pair, where `&lt;code&gt;regex&lt;/code&gt;` is the regular expression used&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                to recognize the token and `&lt;code&gt;type&lt;/code&gt;` is the type&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                of the token to return when it&amp;#39;s recognized.&lt;/span&gt;

&lt;span style="color: #7f007f"&gt;            skip_whitespace:&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                If True, whitespace (\s+) will be skipped and not&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                reported by the lexer. Otherwise, you have to&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                specify your rules for whitespace, or it will be&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;                flagged as an error.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.rules = []
        &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; regex, &lt;span style="color: #00007f"&gt;type&lt;/span&gt; &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; rules:
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.rules.append((re.compile(regex), &lt;span style="color: #00007f"&gt;type&lt;/span&gt;))
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.skip_whitespace = skip_whitespace
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.re_ws_skip = re.compile(&lt;span style="color: #7f007f"&gt;&amp;#39;\S&amp;#39;&lt;/span&gt;)

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;input&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, buf):
        &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Initialize the lexer with a buffer as input.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.buf = buf
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Return the next token (a Token object) found in the&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            input buffer. None is returned if the end of the&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            buffer was reached.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            In case of a lexing error (the current chunk of the&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            buffer matches no rule), a LexerError is raised with&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            the position of the error.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos &amp;gt;= &lt;span style="color: #00007f"&gt;len&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.buf):
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.skip_whitespace:
            m = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.re_ws_skip.search(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.buf, &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)
            &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; m:
                &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos = m.start()
            &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
                &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt;

        &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; regex, &lt;span style="color: #00007f"&gt;type&lt;/span&gt; &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.rules:
            m = regex.match(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.buf, &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)
            &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; m:
                tok = Token(&lt;span style="color: #00007f"&gt;type&lt;/span&gt;, m.group(), &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)
                &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos = m.end()
                &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; tok

        &lt;span style="color: #007f00"&gt;# if we&amp;#39;re here, no rule matched&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;raise&lt;/span&gt; LexerError(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)

    &lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;tokens&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
        &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Returns an iterator to the tokens found in the buffer.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;while&lt;/span&gt; &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;:
            tok = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.token()
            &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; tok &lt;span style="color: #0000aa"&gt;is&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt;: &lt;span style="color: #00007f; font-weight: bold"&gt;break&lt;/span&gt;
            &lt;span style="color: #00007f; font-weight: bold"&gt;yield&lt;/span&gt; tok
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code is well-commented and self explanatory, but in general the approach is: get a bunch of regular expressions, try to match each - the first one that matches is the triggered &amp;quot;rule&amp;quot;, so a token can be returned. It's really straightforward code. Sample usage:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;rules = [
    (&lt;span style="color: #7f007f"&gt;&amp;#39;\d+&amp;#39;&lt;/span&gt;,             &lt;span style="color: #7f007f"&gt;&amp;#39;NUMBER&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;[a-zA-Z_]\w*&amp;#39;&lt;/span&gt;,    &lt;span style="color: #7f007f"&gt;&amp;#39;IDENTIFIER&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;\+&amp;#39;&lt;/span&gt;,              &lt;span style="color: #7f007f"&gt;&amp;#39;PLUS&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;\-&amp;#39;&lt;/span&gt;,              &lt;span style="color: #7f007f"&gt;&amp;#39;MINUS&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;\*&amp;#39;&lt;/span&gt;,              &lt;span style="color: #7f007f"&gt;&amp;#39;MULTIPLY&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;\/&amp;#39;&lt;/span&gt;,              &lt;span style="color: #7f007f"&gt;&amp;#39;DIVIDE&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;\(&amp;#39;&lt;/span&gt;,              &lt;span style="color: #7f007f"&gt;&amp;#39;LP&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;\)&amp;#39;&lt;/span&gt;,              &lt;span style="color: #7f007f"&gt;&amp;#39;RP&amp;#39;&lt;/span&gt;),
    (&lt;span style="color: #7f007f"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;,               &lt;span style="color: #7f007f"&gt;&amp;#39;EQUALS&amp;#39;&lt;/span&gt;),
]

lx = Lexer(rules, skip_whitespace=&lt;span style="color: #00007f"&gt;True&lt;/span&gt;)
lx.input(&lt;span style="color: #7f007f"&gt;&amp;#39;erw = _abc + 12*(R4-623902)  &amp;#39;&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;try&lt;/span&gt;:
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; tok &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; lx.tokens():
        &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(tok)
&lt;span style="color: #00007f; font-weight: bold"&gt;except&lt;/span&gt; LexerError &lt;span style="color: #00007f; font-weight: bold"&gt;as&lt;/span&gt; err:
    &lt;span style="color: #00007f; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;LexerError at position %s&amp;#39;&lt;/span&gt; % err.pos)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Shortly after I started using it, it was suggested that combining all the regexes into a single regex with alternation (the &lt;tt class="docutils literal"&gt;|&lt;/tt&gt; regex syntax) and using named groups to know which one matched would make the lexer faster. Here are the methods of &lt;tt class="docutils literal"&gt;Lexer&lt;/tt&gt; that need to change in order to implement that:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;__init__&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;, rules, skip_whitespace=&lt;span style="color: #00007f"&gt;True&lt;/span&gt;):
    &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Create a lexer.&lt;/span&gt;

&lt;span style="color: #7f007f"&gt;        rules:&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            A list of rules. Each rule is a `&lt;code&gt;regex, type&lt;/code&gt;`&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            pair, where `&lt;code&gt;regex&lt;/code&gt;` is the regular expression used&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            to recognize the token and `&lt;code&gt;type&lt;/code&gt;` is the type&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            of the token to return when it&amp;#39;s recognized.&lt;/span&gt;

&lt;span style="color: #7f007f"&gt;        skip_whitespace:&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            If True, whitespace (\s+) will be skipped and not&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            reported by the lexer. Otherwise, you have to&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            specify your rules for whitespace, or it will be&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;            flagged as an error.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;# All the regexes are concatenated into a single one&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;# with named groups. Since the group names must be valid&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;# Python identifiers, but the token types used by the&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;# user are arbitrary strings, we auto-generate the group&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;# names and map them to token types.&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;#&lt;/span&gt;
    idx = &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;
    regex_parts = []
    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.group_type = {}

    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; regex, &lt;span style="color: #00007f"&gt;type&lt;/span&gt; &lt;span style="color: #0000aa"&gt;in&lt;/span&gt; rules:
        groupname = &lt;span style="color: #7f007f"&gt;&amp;#39;GROUP%s&amp;#39;&lt;/span&gt; % idx
        regex_parts.append(&lt;span style="color: #7f007f"&gt;&amp;#39;(?P&amp;lt;%s&amp;gt;%s)&amp;#39;&lt;/span&gt; % (groupname, regex))
        &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.group_type[groupname] = &lt;span style="color: #00007f"&gt;type&lt;/span&gt;
        idx += &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;

    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.regex = re.compile(&lt;span style="color: #7f007f"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;.join(regex_parts))
    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.skip_whitespace = skip_whitespace
    &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.re_ws_skip = re.compile(&lt;span style="color: #7f007f"&gt;&amp;#39;\S&amp;#39;&lt;/span&gt;)

&lt;span style="color: #00007f; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00007f"&gt;token&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;):
    &lt;span style="color: #7f007f"&gt;&amp;quot;&amp;quot;&amp;quot; Return the next token (a Token object) found in the&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        input buffer. None is returned if the end of the&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        buffer was reached.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        In case of a lexing error (the current chunk of the&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        buffer matches no rule), a LexerError is raised with&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;        the position of the error.&lt;/span&gt;
&lt;span style="color: #7f007f"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos &amp;gt;= &lt;span style="color: #00007f"&gt;len&lt;/span&gt;(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.buf):
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.skip_whitespace:
            m = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.re_ws_skip.search(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.buf, &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)

            &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; m:
                &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos = m.start()
            &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt;:
                &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f"&gt;None&lt;/span&gt;

        m = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.regex.match(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.buf, &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)
        &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; m:
            groupname = m.lastgroup
            tok_type = &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.group_type[groupname]
            tok = Token(tok_type, m.group(groupname), &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)
            &lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos = m.end()
            &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; tok

        &lt;span style="color: #007f00"&gt;# if we&amp;#39;re here, no rule matched&lt;/span&gt;
        &lt;span style="color: #00007f; font-weight: bold"&gt;raise&lt;/span&gt; LexerError(&lt;span style="color: #00007f"&gt;self&lt;/span&gt;.pos)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;re.MatchObject.lastgroup&lt;/tt&gt; method provides the name of the last group that matched in the regex run, and can be used to efficiently find which rule matched the current token.&lt;/p&gt;
&lt;p&gt;This optimization makes the lexer more than twice as fast! Why does this make sense? First, if you think about it in the simplest way possible, the iteration over rules moved from Python code to C code (the implementation of the &lt;tt class="docutils literal"&gt;re&lt;/tt&gt; module). Second, it's even more than that. In the regex engine, &lt;tt class="docutils literal"&gt;|&lt;/tt&gt; alternation doesn't simply mean iteration. When the regex is built, all the sub-regexes get combined into a single NFA - some states may be combined, etc. In short, the speedup is not surprising.&lt;/p&gt;
&lt;div class="section" id="a-word-on-my-benchmark"&gt;
&lt;h3&gt;A word on my benchmark&lt;/h3&gt;
&lt;p&gt;My benchmark is pretty simple. I combined a number of &lt;a class="reference external" href="http://llvm.org/docs/TableGenFundamentals.html"&gt;TableGen&lt;/a&gt; source files into a single one that has ~20 KLOC and weighs around 1 MB; then I wrote down the lexical rules needed to tokenize TableGen and ran the lexer on the whole file. TableGen is a simple programming language, so this is a good simulation of reality.&lt;/p&gt;
&lt;p&gt;The first approach, &amp;quot;multi-regex&amp;quot; runs in 1.23 seconds on my machine. The second, &amp;quot;single-regex&amp;quot; runs in 0.57 seconds - 2.15x speedup.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="javascript"&gt;
&lt;h3&gt;Javascript&lt;/h3&gt;
&lt;p&gt;Lately I've been playing with Javascript again, so I decided to rewrite my lexer in that language to practice its regular expression handling.&lt;/p&gt;
&lt;p&gt;First, the simpler approach that mimics the Python multi-regex lexer:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; Lexer = exports.Lexer = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(rules, skip_ws) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.rules = [];
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; rules.length; ++i) {
    &lt;span style="color: #007f00"&gt;// The regexps are created with &amp;#39;^&amp;#39; since we want to match at&lt;/span&gt;
    &lt;span style="color: #007f00"&gt;// an exact offset.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.rules.push({pattern: &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; &lt;span style="color: #00007f"&gt;RegExp&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;^&amp;#39;&lt;/span&gt; + rules[i].pattern),
                     name: rules[i].name});
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws = skip_ws ? &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; &lt;span style="color: #00007f"&gt;RegExp&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;\\S&amp;#39;&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;) : &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf = &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
}

&lt;span style="color: #007f00"&gt;// Initialize the Lexer&amp;#39;s buffer. This resets the lexer&amp;#39;s internal state and&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// subsequent tokens will be returned starting with the beginning of the new&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// buffer.&lt;/span&gt;
Lexer.prototype.input = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(buf) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf = buf;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
}

&lt;span style="color: #007f00"&gt;// Get the next token from the current buffer. A token is an object with&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// the following properties:&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - name: name of the pattern that this token matched (taken from rules).&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - value: actual string value of the token.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - pos: offset in the current buffer where the token starts.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;//&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// If there are no more tokens in the buffer, returns null. In case of&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// an error throws Error.&lt;/span&gt;
Lexer.prototype.token = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #007f00"&gt;// End of input?&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos &amp;gt;= &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.length) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws.lastIndex = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos;
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; match = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws.exec(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (match) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos = match.index;
    } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
    }
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.rules.length; ++i) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; rule = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.rules[i];
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; match = rule.pattern.exec(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.substr(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos));
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (match) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; the_token = {name: rule.name, value: match[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;], pos: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos};
      &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos += match[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;].length;
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; the_token;
    }
  }

  &lt;span style="color: #007f00"&gt;// If we&amp;#39;re here, no rule matches so it&amp;#39;s an error.&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;throw&lt;/span&gt; &lt;span style="color: #00007f"&gt;Error&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;Cannot match a token at position &amp;#39;&lt;/span&gt; + &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.pos);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here I ran into a first serious deficiency of JS's regexes. There's no real equivalent to Python's &amp;quot;match at a position&amp;quot; functionality. This manifests differently in two places above:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Note that the whitespace skipping now has to define a &amp;quot;global&amp;quot; mode regex (with the &lt;tt class="docutils literal"&gt;&amp;quot;g&amp;quot;&lt;/tt&gt;) flag. This is to be able to use &lt;tt class="docutils literal"&gt;lastIndex&lt;/tt&gt; to tell the regex where to start skipping whitespace from. &lt;tt class="docutils literal"&gt;lastIndex&lt;/tt&gt; works only for the &amp;quot;global&amp;quot; mode.&lt;/li&gt;
&lt;li&gt;For matching the tokens themselves, the situation is more hairy. I would ideally want to say: match this rule at exactly this position (i.e. it has to start at the position, not later). But Javascript doesn't have that (or at least I didn't find it - feel free to suggest in the comments!), so I had to resort to a trick: first, all rule regexes are defined with a start anchor - &lt;tt class="docutils literal"&gt;^&lt;/tt&gt;. Second, the matching itself has to be done on a substring of the buffer, since &lt;tt class="docutils literal"&gt;^&lt;/tt&gt; matches only in the beginning of the buffer. Luckily, Javascript's &lt;tt class="docutils literal"&gt;substr&lt;/tt&gt; is very efficient so this didn't turn out to be a huge performance problem.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The above limitation made the code a bit more complex than I would've hoped for, but it's not really bad. The performance, on the other hand, is terrific. Running this on a recent version of Node.js (in other words, the V8 engine), it runs in 0.23 seconds, 5.3 times faster than the equivalent Python code and 2.5 times faster than even the optimized single-regex version.&lt;/p&gt;
&lt;p&gt;But what about a single-regex version in Javascript. Here it is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; Lexer = exports.Lexer = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(rules, skip_ws) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.rules = rules;
  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; regex_parts = [];
  &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; rules.length; ++i) {
    regex_parts.push(&lt;span style="color: #7f007f"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; + rules[i].pattern + &lt;span style="color: #7f007f"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;);
  }
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.regex = &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; &lt;span style="color: #00007f"&gt;RegExp&lt;/span&gt;(regex_parts.join(&lt;span style="color: #7f007f"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;), &lt;span style="color: #7f007f"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;);
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws = skip_ws ? &lt;span style="color: #00007f; font-weight: bold"&gt;new&lt;/span&gt; &lt;span style="color: #00007f"&gt;RegExp&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;\\S&amp;#39;&lt;/span&gt;, &lt;span style="color: #7f007f"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;) : &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf = &lt;span style="color: #7f007f"&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
}

&lt;span style="color: #007f00"&gt;// Initialize the Lexer&amp;#39;s buffer. This resets the lexer&amp;#39;s internal state and&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// subsequent tokens will be returned starting with the beginning of the new&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// buffer.&lt;/span&gt;
Lexer.prototype.input = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;(buf) {
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf = buf;
  &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.regex.lastIndex = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;;
}

&lt;span style="color: #007f00"&gt;// Get the next token from the current buffer. A token is an object with&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// the following properties:&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - name: name of the pattern that this token matched (taken from rules).&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - value: actual string value of the token.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// - pos: offset in the current buffer where the token starts.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;//&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// If there are no more tokens in the buffer, returns null.&lt;/span&gt;
&lt;span style="color: #007f00"&gt;// In case of an error, throws Error.&lt;/span&gt;
Lexer.prototype.token = &lt;span style="color: #00007f; font-weight: bold"&gt;function&lt;/span&gt;() {
  &lt;span style="color: #007f00"&gt;// End of input?&lt;/span&gt;
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.regex.lastIndex &amp;gt;= &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf.length) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws.lastIndex = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.regex.lastIndex;
    &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; match = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.skip_ws.exec(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf);
    &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (match) {
      &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.regex.lastIndex = match.index;
    } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
      &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;;
    }
  }

  &lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; result = &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.regex.exec(&lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.buf);
  &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (result === &lt;span style="color: #00007f; font-weight: bold"&gt;null&lt;/span&gt;) {
    &lt;span style="color: #00007f; font-weight: bold"&gt;throw&lt;/span&gt; &lt;span style="color: #00007f"&gt;Error&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;Cannot match a token at position &amp;#39;&lt;/span&gt; + &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.lexer.lastIndex);
  } &lt;span style="color: #00007f; font-weight: bold"&gt;else&lt;/span&gt; {
    &lt;span style="color: #00007f; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #00007f; font-weight: bold"&gt;var&lt;/span&gt; i = &lt;span style="color: #007f7f"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.rules.length; i++) {
      &lt;span style="color: #007f00"&gt;// Find the matching rulea SO question&lt;/span&gt;
      &lt;span style="color: #00007f; font-weight: bold"&gt;if&lt;/span&gt; (result[i + &lt;span style="color: #007f7f"&gt;1&lt;/span&gt;] !== &lt;span style="color: #00007f; font-weight: bold"&gt;undefined&lt;/span&gt;) {
        &lt;span style="color: #00007f; font-weight: bold"&gt;return&lt;/span&gt; {name: &lt;span style="color: #00007f; font-weight: bold"&gt;this&lt;/span&gt;.rules[i].name,
                value: result[&lt;span style="color: #007f7f"&gt;0&lt;/span&gt;], pos: result.index};
      }
    }
    &lt;span style="color: #007f00"&gt;// Shouldn&amp;#39;t get here, because at least one rule matched.&lt;/span&gt;
    &lt;span style="color: #00007f; font-weight: bold"&gt;throw&lt;/span&gt; &lt;span style="color: #00007f"&gt;Error&lt;/span&gt;(&lt;span style="color: #7f007f"&gt;&amp;#39;Internal error&amp;#39;&lt;/span&gt;);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You'll notice that the code here bends over backwards to overcome another annoying limitation of JS regexes. There are no named groups, and no way to quickly find out which group matched in a particular run, &lt;em&gt;without stupidly iterating over the results array&lt;/em&gt;! I was very surprised when I found this, and even asked &lt;a class="reference external" href="http://stackoverflow.com/questions/17149995/efficiently-find-which-group-matched-in-a-regexp-search"&gt;a SO question&lt;/a&gt;, where I was told that this is the way things are.&lt;/p&gt;
&lt;p&gt;The loop over the results object in the end of the &lt;tt class="docutils literal"&gt;token&lt;/tt&gt; method really bothers me a lot. It's so useless! My benchmark Tablegen tokenizer has ~30 rules, many of which have to be iterated over for each matching token.&lt;/p&gt;
&lt;p&gt;The performance, however, still became much better. This lexer runs the full benchmark in 0.15 seconds, 1.5 times faster than the multi-regex one, and 3.8 times faster than the Python equivalent. Note that the speedup here is smaller than the one experienced by the Python version - I attribute it to the silly result looping :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;This lexer turned out to be a good exercise of the language's regex capabilities. Back in the day, it helped me learn some tricks in the original Python implementation (such as optimizing regexes by combining them into a single one, and also named groups). It also made me run into a couple of deficiencies of JS's regex handling when I was porting the code. And to run into a deficiency you really need to scour the docs and examples carefully making sure you're not missing anything. As I mentioned above already - I'm very interested in feedback - if anything can be done differently, please let me know.&lt;/p&gt;
&lt;p&gt;Also, the performance comparison was interesting. Here it is again, in more graphical form:&lt;/p&gt;
&lt;img class="align-center" src="http://eli.thegreenplace.net/images/2013/06/lexer_runtime_chart.png" /&gt;
&lt;p&gt;There's no doubt that the popularity of Javascript has paid off. Huge efforts were spent by hordes of smart programmers &lt;em&gt;paid to optimize Javascript&lt;/em&gt; and the results are obvious. Even in a benchmark where one wouldn't expect the difference between languages to be large - because it's mostly a regex workload, and regexes are presumably implemented similarly deep down in the C/C++ layer - Javascript V8 effortlessly blows (C)Python out of the water.&lt;/p&gt;
&lt;/div&gt;

    </summary><category term="Compilation"></category><category term="Javascript"></category><category term="Python"></category></entry><entry><title>Keeping persistent history in bash</title><link href="http://eli.thegreenplace.net/2013/06/11/keeping-persistent-history-in-bash" rel="alternate"></link><updated>2013-06-11T19:27:17-07:00</updated><author><name>Eli Bendersky</name></author><id>tag:eli.thegreenplace.net,2013-06-11:2013/06/11/keeping-persistent-history-in-bash</id><summary type="html">
        &lt;p&gt;For someone spending most of his time in front of a Linux terminal, history is very important. But traditional bash history has a number of limitations, especially when multiple terminals are involved (I sometimes have dozens open). Also it's not very good at preserving just the history you're interested in across reboots.&lt;/p&gt;
&lt;p&gt;There are many approaches to improve the situation; here I want to discuss one I've been using very successfully in the past few months - a simple &amp;quot;persistent history&amp;quot; that keeps track of history across terminal instances, saving it into a dot-file in my home directory (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.persistent_history&lt;/span&gt;&lt;/tt&gt;). All commands, from all terminal instances, are saved there, forever. I found this tremendously useful in my work - it saves me time almost every day.&lt;/p&gt;
&lt;p&gt;Why does it go into a &lt;em&gt;separate&lt;/em&gt; history and not the &lt;em&gt;main&lt;/em&gt; one which is accessible by all the existing history manipulation tools? Because IMHO the latter is still worthwhile to be kept separate for the simple need of bringing up recent commands in a single terminal, without mixing up commands from other terminals. While the terminal is open, I want the press &amp;quot;Up&amp;quot; and get the previous command, even if I've executed a 1000 other commands in other terminal instances in the meantime.&lt;/p&gt;
&lt;p&gt;Persistent history is very easy to set up. Here's the relevant portion of my &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.bashrc&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;log_bash_persistent_history()
{
  [[
    $(history 1) =~ ^\ *[0-9]+\ +([^\ ]+\ [^\ ]+)\ +(.*)$
  ]]
  local date_part=&amp;quot;${BASH_REMATCH[1]}&amp;quot;
  local command_part=&amp;quot;${BASH_REMATCH[2]}&amp;quot;
  if [ &amp;quot;$command_part&amp;quot; != &amp;quot;$PERSISTENT_HISTORY_LAST&amp;quot; ]
  then
    echo $date_part &amp;quot;|&amp;quot; &amp;quot;$command_part&amp;quot; &amp;gt;&amp;gt; ~/.persistent_history
    export PERSISTENT_HISTORY_LAST=&amp;quot;$command_part&amp;quot;
  fi
}

# Stuff to do on PROMPT_COMMAND
run_on_prompt_command()
{
    log_bash_persistent_history
}

PROMPT_COMMAND=&amp;quot;run_on_prompt_command&amp;quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The format of the history file created by this is:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;2013-06-09 17:48:11 | cat ~/.persistent_history
2013-06-09 17:49:17 | vi /home/eliben/.bashrc
2013-06-09 17:49:23 | ls
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that an environment variable is used to avoid useless duplication (i.e. if I run &lt;tt class="docutils literal"&gt;ls&lt;/tt&gt; twenty times in a row, it will only be recorded once).&lt;/p&gt;
&lt;p&gt;OK, so we have &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.persistent_history&lt;/span&gt;&lt;/tt&gt;, how do we &lt;em&gt;use&lt;/em&gt; it? First, I should say that it's not used very often, which kind of connects to the point I made earlier about separating it from the much higher-use regular command history. Sometimes I just look into the file with &lt;tt class="docutils literal"&gt;vi&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;tail&lt;/tt&gt;, but mostly this alias does the trick for me:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;alias phgrep=&amp;#39;cat ~/.persistent_history|grep --color&amp;#39;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The alias name mirrors another alias I've been using for ages:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;alias hgrep=&amp;#39;history|grep --color&amp;#39;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another tool for managing persistent history is a trimmer. I said earlier this file keeps the history &amp;quot;forever&amp;quot;, which is a scary word - what if it grows too large? Well, first of all - worry not. At work my history file grew to about 2 MB after 3 months of heavy usage, and 2 MB is pretty small these days. Appending to the end of a file is very, very quick (I'm pretty sure it's a constant-time operation) so the size doesn't matter much. But trimming is easy:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;tail -20000 ~/.persistent_history | tee ~/.persistent_history
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Trims to the last 20000 lines. This should be sufficient for at least a couple of months of history, and your workflow should not really rely on more than that :-)&lt;/p&gt;
&lt;p&gt;Finally, what's the use of having a tool like this without employing it to collect some useless statistics. Here's a histogram of the 15 most common commands I've used on my home machine's terminal over the past 3 months:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;ls        : 865
vi        : 863
hg        : 741
cd        : 512
ll        : 289
pss       : 245
hst       : 200
python    : 168
make      : 167
git       : 148
time      : 94
python3   : 88
./python  : 88
hpu       : 82
cat       : 80
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some explanation: &lt;tt class="docutils literal"&gt;hst&lt;/tt&gt; is an alias for &lt;tt class="docutils literal"&gt;hg st&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;hpu&lt;/tt&gt; is an alias for &lt;tt class="docutils literal"&gt;hg pull &lt;span class="pre"&gt;-u&lt;/span&gt;&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;pss&lt;/tt&gt; is my &lt;a class="reference external" href="https://github.com/eliben/pss/"&gt;awesome pss tool&lt;/a&gt;, and is the reason why you don't see any calls to &lt;tt class="docutils literal"&gt;grep&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;find&lt;/tt&gt; in the list. The proportion of Mercurial vs. git commands is likely to change in the very near future &lt;a class="reference external" href="http://eli.thegreenplace.net/2013/06/09/switching-my-open-source-projects-from-bitbucket-to-github/"&gt;due to this&lt;/a&gt;.&lt;/p&gt;

    </summary><category term="Linux"></category><category term="Software &amp; Tools"></category></entry></feed>